<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: Generic SFrame Eager Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__eager__algorithms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Generic SFrame Eager Algorithms<div class="ingroups"><a class="el" href="group__sframe__physical.html">SFrame : Physical</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa10744bd79ea1690d46f800c003c2a94"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename TransformFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gaa10744bd79ea1690d46f800c003c2a94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#gaa10744bd79ea1690d46f800c003c2a94">turi::transform</a> (S &amp;&amp;input, T &amp;&amp;output, TransformFn transformfn, std::set&lt; size_t &gt; constraint_segments=std::set&lt; size_t &gt;())</td></tr>
<tr class="separator:gaa10744bd79ea1690d46f800c003c2a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d2d6771502a9e4b3dcc6518611fbe95"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename FilterFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga9d2d6771502a9e4b3dcc6518611fbe95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#ga9d2d6771502a9e4b3dcc6518611fbe95">turi::copy_if</a> (S &amp;&amp;input, T &amp;&amp;output, FilterFn filterfn, std::set&lt; size_t &gt; constraint_segments=std::set&lt; size_t &gt;(), size_t random_seed=size_t(-1))</td></tr>
<tr class="separator:ga9d2d6771502a9e4b3dcc6518611fbe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d178d3bf3b12b8bfcae1b24e2e56e0a"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename FilterFn , typename TransformFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga4d178d3bf3b12b8bfcae1b24e2e56e0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#ga4d178d3bf3b12b8bfcae1b24e2e56e0a">turi::copy_transform_if</a> (S &amp;&amp;input, T &amp;&amp;output, FilterFn filterfn, TransformFn transformfn, std::set&lt; size_t &gt; constraint_segments=std::set&lt; size_t &gt;(), size_t random_seed=size_t(-1))</td></tr>
<tr class="separator:ga4d178d3bf3b12b8bfcae1b24e2e56e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad750d10d75a759cde25e098d0105271b"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename FilterFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gad750d10d75a759cde25e098d0105271b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#gad750d10d75a759cde25e098d0105271b">turi::split</a> (S &amp;&amp;input, T &amp;&amp;output1, T &amp;&amp;output2, FilterFn filterfn, size_t random_seed=std::time(NULL))</td></tr>
<tr class="separator:gad750d10d75a759cde25e098d0105271b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga085e14fe4c4747d6be6088737cec74e8"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename SWriter , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;SWriter&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga085e14fe4c4747d6be6088737cec74e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#ga085e14fe4c4747d6be6088737cec74e8">turi::copy</a> (Iterator begin, Iterator end, SWriter &amp;&amp;writer)</td></tr>
<tr class="separator:ga085e14fe4c4747d6be6088737cec74e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebfc93a81ed0e7cd138f107f26e0ad2c"><td class="memTemplParams" colspan="2">template&lt;typename S , typename Iterator , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gaebfc93a81ed0e7cd138f107f26e0ad2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#gaebfc93a81ed0e7cd138f107f26e0ad2c">turi::copy</a> (S &amp;&amp;array, Iterator output, size_t limit=(size_t)(-1))</td></tr>
<tr class="separator:gaebfc93a81ed0e7cd138f107f26e0ad2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73eec4b557bb91e92b781c26df159a6"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename S , typename FunctionType , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gad73eec4b557bb91e92b781c26df159a6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ResultType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#gad73eec4b557bb91e92b781c26df159a6">turi::reduce</a> (S &amp;&amp;input, FunctionType f, ResultType init=ResultType())</td></tr>
<tr class="separator:gad73eec4b557bb91e92b781c26df159a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e52ecf89923b7a8dd68db7840576e69"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename T , typename TransformFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S1&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S2&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga3e52ecf89923b7a8dd68db7840576e69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#ga3e52ecf89923b7a8dd68db7840576e69">turi::binary_transform</a> (S1 &amp;&amp;input1, S2 &amp;&amp;input2, T &amp;&amp;output, TransformFn transformfn)</td></tr>
<tr class="separator:ga3e52ecf89923b7a8dd68db7840576e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385afe1bdc7987d31b716bd117aec241"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga385afe1bdc7987d31b716bd117aec241"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#ga385afe1bdc7987d31b716bd117aec241">turi::copy_range</a> (S &amp;&amp;input, T &amp;&amp;output, size_t start, size_t step, size_t end)</td></tr>
<tr class="separator:ga385afe1bdc7987d31b716bd117aec241"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3e52ecf89923b7a8dd68db7840576e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e52ecf89923b7a8dd68db7840576e69">&#9670;&nbsp;</a></span>binary_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S1 , typename S2 , typename T , typename TransformFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S1&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S2&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::binary_transform </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>input1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>input2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransformFn&#160;</td>
          <td class="paramname"><em>transformfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes input to output calling the transformfn on each input pair emitting the result to output.</p>
<p>This class accomplishes the abstract equivalent of </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> x in input1:</div><div class="line">   read next y in input2</div><div class="line">   write transformfn(x, y) to output</div></div><!-- fragment --><p>The input objects must be descendents of <a class="el" href="classturi_1_1siterable.html">siterable</a>, and the output object must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a>. <a class="el" href="classturi_1_1sarray.html">sarray</a> and swriter are two common instances of either.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input1</td><td>The first input to read from. Must be a descendent of siterable </td></tr>
    <tr><td class="paramname">input2</td><td>The second input to read from. Must be a descendent of siterable </td></tr>
    <tr><td class="paramname">output</td><td>The output writer to write to. Must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a> </td></tr>
    <tr><td class="paramname">transformfn</td><td>The transform operation to perform on the inputs to generate the output </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html#l00543">543</a> of file <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="ga085e14fe4c4747d6be6088737cec74e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga085e14fe4c4747d6be6088737cec74e8">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename SWriter , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;SWriter&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::copy </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SWriter &amp;&amp;&#160;</td>
          <td class="paramname"><em>writer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes to an SWriter from a standard input iterator sequence.</p>
<p>This class accomplishes the abstract equivalent of </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> x in range(begin, end) (regular iterator):</div><div class="line">    write x to output (swriter)</div></div><!-- fragment --><p>The input must be a pair of iterators, and the output object must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The precise arrangement of the data in the segment will depend on the iterator type. If the iterator range is at minimal a forward_iterator, The resultant data is blocked across the segments of the writer. i.e. if the writer has 4 segments, the first 1/4 of the data will go to segment 1, the next 1/4 will go to segment 2, etc. Otherwise, if the iterator range is an input iterator, it will be striped across the segments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The start of the forward iterator sequence to write to the writer. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the forward iterator sequence to write to the writer. </td></tr>
    <tr><td class="paramname">output</td><td>The output writer to write to. Must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_2build_2src_2core_2storage_2sframe_interface_2unity_sframe_8hpp-example.html#a1">/build/src/core/storage/sframe_interface/unity_sframe.hpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html#l00416">416</a> of file <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="gaebfc93a81ed0e7cd138f107f26e0ad2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebfc93a81ed0e7cd138f107f26e0ad2c">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename Iterator , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::copy </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code>(size_t)(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the contents of an SArray to regular output iterator.</p>
<p>This class accomplishes the abstract equivalent of: </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> x in sarray</div><div class="line">    write x to output</div></div><!-- fragment --><p>The input object must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The SArray to read from </td></tr>
    <tr><td class="paramname">output</td><td>The output iterator to write to. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html#l00441">441</a> of file <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="ga9d2d6771502a9e4b3dcc6518611fbe95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d2d6771502a9e4b3dcc6518611fbe95">&#9670;&nbsp;</a></span>copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename FilterFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::copy_if </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilterFn&#160;</td>
          <td class="paramname"><em>filterfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>constraint_segments</em> = <code>std::set&lt;size_t&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>random_seed</em> = <code>size_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters input to output calling the filterfn on each input and emitting the input to output only if the filter function evaluates to true.</p>
<p>This class accomplishes the abstract equivalent of </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> x in input:</div><div class="line">   <span class="keywordflow">if</span> (filterfn(x)) write x to output</div></div><!-- fragment --><p>The input object must be a descendent of <a class="el" href="classturi_1_1siterable.html">siterable</a>, and the output object must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a>. <a class="el" href="classturi_1_1sarray.html">sarray</a> and swriter are two common instances of either.</p>
<p>The output object should be of the same number of segments as the input object. If they are of different number of segments, this function will attempt to change the number of segments of the output object. Changing the number of segments is generally a successful operation unless writes have already occured on the output. If the number of segments do not match, and if the number of output segments cannot be set, this function will throw a string exception and fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to read from. Must be a descendent of siterable </td></tr>
    <tr><td class="paramname">output</td><td>The output writer to write to. Must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a> </td></tr>
    <tr><td class="paramname">filterfn</td><td>The filter operation to perform on the input. If the filterfn evaluates to true, the input is copied to the output. </td></tr>
    <tr><td class="paramname">constraint_segments</td><td>The set of segments to operate on. If empty (default) will operate on all segments. Only valid segment numbers will be operated on. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html#l00137">137</a> of file <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="ga385afe1bdc7987d31b716bd117aec241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga385afe1bdc7987d31b716bd117aec241">&#9670;&nbsp;</a></span>copy_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::copy_range </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a range of elements to the output.</p>
<p>This class accomplishes the abstract equivalent of </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> i = begin; i &lt; end; i += step</div><div class="line">   write row i in input to to output</div></div><!-- fragment --><p>The input object must be a descendent of <a class="el" href="classturi_1_1siterable.html">siterable</a>, and the output object must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a>. <a class="el" href="classturi_1_1sarray.html">sarray</a> and swriter are two common instances of either.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to read from. Must be a descendent of siterable </td></tr>
    <tr><td class="paramname">output</td><td>The output writer to write to. Must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a> </td></tr>
    <tr><td class="paramname">start</td><td>The start row to begin reading </td></tr>
    <tr><td class="paramname">step</td><td>The row step </td></tr>
    <tr><td class="paramname">end</td><td>One past the last row to read </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_2build_2src_2core_2storage_2sframe_interface_2unity_sframe_8hpp-example.html#a7">/build/src/core/storage/sframe_interface/unity_sframe.hpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html#l00599">599</a> of file <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="ga4d178d3bf3b12b8bfcae1b24e2e56e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d178d3bf3b12b8bfcae1b24e2e56e0a">&#9670;&nbsp;</a></span>copy_transform_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename FilterFn , typename TransformFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::copy_transform_if </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilterFn&#160;</td>
          <td class="paramname"><em>filterfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransformFn&#160;</td>
          <td class="paramname"><em>transformfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>constraint_segments</em> = <code>std::set&lt;size_t&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>random_seed</em> = <code>size_t(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters input to output calling the filterfn on each input and emitting the transformed input to output only if the filter function evaluates to true.</p>
<p>This class accomplishes the abstract equivalent of </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> x in input:</div><div class="line">   <span class="keywordflow">if</span> (filterfn(x)) write <a class="code" href="group__eager__algorithms.html#gaa10744bd79ea1690d46f800c003c2a94">transform</a>(x) to output</div></div><!-- fragment --><p>The input object must be a descendent of <a class="el" href="classturi_1_1siterable.html">siterable</a>, and the output object must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a>. <a class="el" href="classturi_1_1sarray.html">sarray</a> and swriter are two common instances of either.</p>
<p>The output object should be of the same number of segments as the input object. If they are of different number of segments, this function will attempt to change the number of segments of the output object. Changing the number of segments is generally a successful operation unless writes have already occured on the output. If the number of segments do not match, and if the number of output segments cannot be set, this function will throw a string exception and fail.</p>
<p>The output object should be ready for write and the schema must match the output schema of the transform function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to read from. Must be a descendent of siterable </td></tr>
    <tr><td class="paramname">output</td><td>The output writer to write to. Must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a> </td></tr>
    <tr><td class="paramname">filterfn</td><td>The filter operation to perform on the input. If the filterfn evaluates to true, the input is copied to the output. </td></tr>
    <tr><td class="paramname">transformfn</td><td>The transform operation to perform on the input. </td></tr>
    <tr><td class="paramname">constraint_segments</td><td>The set of segments to operate on. If empty (default) will operate on all segments. Only valid segment numbers will be operated on. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html#l00211">211</a> of file <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="gad73eec4b557bb91e92b781c26df159a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad73eec4b557bb91e92b781c26df159a6">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType , typename S , typename FunctionType , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;ResultType&gt; turi::reduce </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType&#160;</td>
          <td class="paramname"><em>init</em> = <code>ResultType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a reduction on each segment of an Sarray returning the result of the reduction on each segment.</p>
<p>This class accomplishes the abstract equivalent of: </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> segment in sarray</div><div class="line">    res = init</div><div class="line">    <span class="keywordflow">for each</span> x in segment:</div><div class="line">       <span class="keywordflow">if</span> (f(x, res) == <span class="keyword">false</span>) <span class="keywordflow">break</span>;</div><div class="line">    returnval[segment] = res</div><div class="line"><span class="keywordflow">return</span> returnval</div></div><!-- fragment --><p>The input object must be a descendent of <a class="el" href="classturi_1_1siterable.html">siterable</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The SArray to read from </td></tr>
    <tr><td class="paramname">function</td><td>The reduction function to use. This must be of the form bool f(const array_value_type&amp;, reduction_type&amp;). </td></tr>
    <tr><td class="paramname">init</td><td>The initial value to use in the reduction</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultType</td><td>The result type of each reduction. </td></tr>
    <tr><td class="paramname">S</td><td>The type of the input array. Must be a descendent of siterable </td></tr>
    <tr><td class="paramname">FunctionType</td><td>The type of the function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that writes to std::vector&lt;T&gt; can be made in parallel. i.e. ResultType of bool should not be used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html#l00491">491</a> of file <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="gad750d10d75a759cde25e098d0105271b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad750d10d75a759cde25e098d0105271b">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename FilterFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::split </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>output1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>output2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilterFn&#160;</td>
          <td class="paramname"><em>filterfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>random_seed</em> = <code>std::time(NULL)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split input to output1 and output2 calling the filterfn on each input and emitting the input to output1 if the filter function evaluates to true, output2 otherwise.</p>
<p>This class accomplishes the abstract equivalent of </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> x in input:</div><div class="line">   <span class="keywordflow">if</span> (filterfn(x)) write x to output1</div><div class="line">   <span class="keywordflow">else</span> write x to output2</div></div><!-- fragment --><p>The input object must be a descendent of <a class="el" href="classturi_1_1siterable.html">siterable</a>, and the output object must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a>. <a class="el" href="classturi_1_1sarray.html">sarray</a> and swriter are two common instances of either.</p>
<p>The output object should be of the same number of segments as the input object. If they are of different number of segments, this function will attempt to change the number of segments of the output object. Changing the number of segments is generally a successful operation unless writes have already occured on the output. If the number of segments do not match, and if the number of output segments cannot be set, this function will throw a string exception and fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to read from. Must be a descendent of siterable </td></tr>
    <tr><td class="paramname">output1</td><td>The output writer to write to. Must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a> </td></tr>
    <tr><td class="paramname">output2</td><td>The output writer to write to. Must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a> </td></tr>
    <tr><td class="paramname">filterfn</td><td>The filter operation to perform on the input. If the filterfn evaluates to true, the input is copied to the output1, else output2. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_2build_2src_2core_2storage_2sframe_interface_2unity_sframe_8hpp-example.html#a8">/build/src/core/storage/sframe_interface/unity_sframe.hpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html#l00293">293</a> of file <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="gaa10744bd79ea1690d46f800c003c2a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa10744bd79ea1690d46f800c003c2a94">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename TransformFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::transform </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransformFn&#160;</td>
          <td class="paramname"><em>transformfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>constraint_segments</em> = <code>std::set&lt;size_t&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes input to output calling the transformfn on each input emitting the result to output.</p>
<p>This class accomplishes the abstract equivalent of </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> x in input:</div><div class="line">   write transformfn(x) to output</div></div><!-- fragment --><p>The input object must be a descendent of <a class="el" href="classturi_1_1siterable.html">siterable</a>, and the output object must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a>. <a class="el" href="classturi_1_1sarray.html">sarray</a> and swriter are two common instances of either.</p>
<p>The output object should be of the same number of segments as the input object. If they are of different number of segments, this function will attempt to change the number of segments of the output object. Changing the number of segments is generally a successful operation unless writes have already occured on the output. If the number of segments do not match, and if the number of output segments cannot be set, this function will throw a string exception and fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to read from. Must be a descendent of siterable </td></tr>
    <tr><td class="paramname">output</td><td>The output writer to write to. Must be a descendent of <a class="el" href="classturi_1_1swriter__base.html">swriter_base</a> </td></tr>
    <tr><td class="paramname">transformfn</td><td>The transform operation to perform on the input to generate the output </td></tr>
    <tr><td class="paramname">constraint_segments</td><td>The set of segments to operate on. If empty (default) will operate on all segments. Only valid segment numbers will be operated on. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_2build_2src_2core_2storage_2sframe_interface_2unity_sframe_8hpp-example.html#a2">/build/src/core/storage/sframe_interface/unity_sframe.hpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html#l00064">64</a> of file <a class="el" href="storage_2sframe__data_2algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
