<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Turi Create: turi::sframe Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1sframe.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classturi_1_1sframe-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::sframe Class Reference<div class="ingroups"><a class="el" href="group__sframe__physical.html">SFrame : Physical</a> &raquo; <a class="el" href="group__sframe__main.html">Main SFrame Objects</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sframe_8hpp_source.html">core/storage/sframe_data/sframe.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a16aa215d59181b6dada3f9107b329674"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16aa215d59181b6dada3f9107b329674"></a>
typedef <a class="el" href="classturi_1_1sframe__reader.html">sframe_reader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a16aa215d59181b6dada3f9107b329674">reader_type</a></td></tr>
<tr class="memdesc:a16aa215d59181b6dada3f9107b329674"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reader type. <br /></td></tr>
<tr class="separator:a16aa215d59181b6dada3f9107b329674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f76b08340fc62df9333bb7c64ff07e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f76b08340fc62df9333bb7c64ff07e0"></a>
typedef <a class="el" href="classturi_1_1sframe__function__output__iterator.html">sframe_output_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a0f76b08340fc62df9333bb7c64ff07e0">iterator</a></td></tr>
<tr class="memdesc:a0f76b08340fc62df9333bb7c64ff07e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator type which <a class="el" href="classturi_1_1sframe.html#ac69503f6f197906bf584990118033ee5">get_output_iterator</a> returns. <br /></td></tr>
<tr class="separator:a0f76b08340fc62df9333bb7c64ff07e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add491107626a72b7e3bd1e7b951c6b83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add491107626a72b7e3bd1e7b951c6b83"></a>
typedef std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#add491107626a72b7e3bd1e7b951c6b83">value_type</a></td></tr>
<tr class="memdesc:add491107626a72b7e3bd1e7b951c6b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type contained in the sframe. <br /></td></tr>
<tr class="separator:add491107626a72b7e3bd1e7b951c6b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa2301ed7b71971af8d30913b9d4dfefb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#aa2301ed7b71971af8d30913b9d4dfefb">sframe</a> ()</td></tr>
<tr class="separator:aa2301ed7b71971af8d30913b9d4dfefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e8898c08843348b57c69f78a4ed549"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a62e8898c08843348b57c69f78a4ed549">sframe</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;other)</td></tr>
<tr class="separator:a62e8898c08843348b57c69f78a4ed549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3931b0e62de68cbb8a1d1e6d5377e748"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a3931b0e62de68cbb8a1d1e6d5377e748">sframe</a> (<a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&amp;other)</td></tr>
<tr class="separator:a3931b0e62de68cbb8a1d1e6d5377e748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcf8b9ad3084023429d6c05cdd7df26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a2dcf8b9ad3084023429d6c05cdd7df26">operator=</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;other)</td></tr>
<tr class="separator:a2dcf8b9ad3084023429d6c05cdd7df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed46f42c0f791a2a49159eefde2a705"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a1ed46f42c0f791a2a49159eefde2a705">operator=</a> (<a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&amp;other)</td></tr>
<tr class="separator:a1ed46f42c0f791a2a49159eefde2a705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69889616c7767e41595ef05b55e1c011"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a69889616c7767e41595ef05b55e1c011">sframe</a> (std::string frame_idx_file)</td></tr>
<tr class="separator:a69889616c7767e41595ef05b55e1c011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46393d4d6bcd598510c6b13b208534b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#ae46393d4d6bcd598510c6b13b208534b">sframe</a> (<a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a> frame_index_info)</td></tr>
<tr class="separator:ae46393d4d6bcd598510c6b13b208534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9435077bc8df2a558d762731f4144b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#af9435077bc8df2a558d762731f4144b4">sframe</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt; &amp;new_columns, const std::vector&lt; std::string &gt; &amp;<a class="el" href="classturi_1_1sframe.html#a8c59d3fe72be771526584fb4f8c57291">column_names</a>={}, bool fail_on_column_names=true)</td></tr>
<tr class="separator:af9435077bc8df2a558d762731f4144b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a668c3d64d91ad561a5fb01b44087c5"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a4a668c3d64d91ad561a5fb01b44087c5">init_from_csvs</a> (const std::string &amp;path, <a class="el" href="structturi_1_1csv__line__tokenizer.html">csv_line_tokenizer</a> &amp;tokenizer, bool use_header, bool continue_on_failure, bool store_errors, std::map&lt; std::string, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; column_type_hints, std::vector&lt; std::string &gt; output_columns=std::vector&lt; std::string &gt;(), size_t row_limit=0, size_t skip_rows=0)</td></tr>
<tr class="separator:a4a668c3d64d91ad561a5fb01b44087c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bb1f5fc9bf12e165a5e0f26df0b2e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a52bb1f5fc9bf12e165a5e0f26df0b2e0">sframe</a> (const <a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a> &amp;data)</td></tr>
<tr class="separator:a52bb1f5fc9bf12e165a5e0f26df0b2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2198a7cd710ee7447e5f40f32e936da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a2198a7cd710ee7447e5f40f32e936da4">open_for_read</a> (<a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a> frame_index_info)</td></tr>
<tr class="separator:a2198a7cd710ee7447e5f40f32e936da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ea0ed7a4f5fc96614a606d2c16dde0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#ad7ea0ed7a4f5fc96614a606d2c16dde0">open_for_read</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt; &amp;new_columns, const std::vector&lt; std::string &gt; &amp;<a class="el" href="classturi_1_1sframe.html#a8c59d3fe72be771526584fb4f8c57291">column_names</a>={}, bool fail_on_column_names=true)</td></tr>
<tr class="separator:ad7ea0ed7a4f5fc96614a606d2c16dde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fdd0cca31cb1c4b44e60b554db28ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#af6fdd0cca31cb1c4b44e60b554db28ad">open_for_write</a> (const std::vector&lt; std::string &gt; &amp;<a class="el" href="classturi_1_1sframe.html#a8c59d3fe72be771526584fb4f8c57291">column_names</a>, const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;<a class="el" href="classturi_1_1sframe.html#aaf977faf06367575b7258e3b2dd0c638">column_types</a>, const std::string &amp;frame_sidx_file=&quot;&quot;, size_t nsegments=<a class="el" href="group__sframe__main.html#ga0a14c814ad647a718e7ff20ef2999653">SFRAME_DEFAULT_NUM_SEGMENTS</a>, bool fail_on_column_names=true)</td></tr>
<tr class="separator:af6fdd0cca31cb1c4b44e60b554db28ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97da4af9a76b174dca431a49e6170e85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a97da4af9a76b174dca431a49e6170e85">is_opened_for_read</a> () const </td></tr>
<tr class="separator:a97da4af9a76b174dca431a49e6170e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dd5af96ff258bf5eb59b7ab87e2ebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a61dd5af96ff258bf5eb59b7ab87e2ebb">is_opened_for_write</a> () const </td></tr>
<tr class="separator:a61dd5af96ff258bf5eb59b7ab87e2ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e13a526f55d5a3f7a574d4baa9c970"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a00e13a526f55d5a3f7a574d4baa9c970">get_index_file</a> () const </td></tr>
<tr class="separator:a00e13a526f55d5a3f7a574d4baa9c970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec969c283ce5cb16b02ccb9c0c2abc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a7ec969c283ce5cb16b02ccb9c0c2abc3">get_metadata</a> (const std::string &amp;key, std::string &amp;val) const </td></tr>
<tr class="separator:a7ec969c283ce5cb16b02ccb9c0c2abc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402e330a7269b93bd0a388c5b58875c2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a402e330a7269b93bd0a388c5b58875c2">get_metadata</a> (const std::string &amp;key) const </td></tr>
<tr class="separator:a402e330a7269b93bd0a388c5b58875c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a82d274ca129ed79ac487b43548392e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a82d274ca129ed79ac487b43548392e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a8a82d274ca129ed79ac487b43548392e">num_columns</a> () const </td></tr>
<tr class="memdesc:a8a82d274ca129ed79ac487b43548392e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the SFrame. Does not throw. <br /></td></tr>
<tr class="separator:a8a82d274ca129ed79ac487b43548392e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e81bffd3e782ed2a560b9b46929d39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2e81bffd3e782ed2a560b9b46929d39"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#ad2e81bffd3e782ed2a560b9b46929d39">num_rows</a> () const </td></tr>
<tr class="memdesc:ad2e81bffd3e782ed2a560b9b46929d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of each sarray. <br /></td></tr>
<tr class="separator:ad2e81bffd3e782ed2a560b9b46929d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fda4767861565784f7f9a2f964b5142"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a8fda4767861565784f7f9a2f964b5142">size</a> () const </td></tr>
<tr class="separator:a8fda4767861565784f7f9a2f964b5142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76e42efe25be8b36bd768a77163c1bb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#ae76e42efe25be8b36bd768a77163c1bb">column_name</a> (size_t i) const </td></tr>
<tr class="separator:ae76e42efe25be8b36bd768a77163c1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f1301c5f4280e5b53f5b9b22f9bab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a99f1301c5f4280e5b53f5b9b22f9bab7">column_type</a> (size_t i) const </td></tr>
<tr class="separator:a99f1301c5f4280e5b53f5b9b22f9bab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b815611fd3e8d96710b948d4a925e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#aa4b815611fd3e8d96710b948d4a925e3">column_type</a> (const std::string &amp;<a class="el" href="classturi_1_1sframe.html#ae76e42efe25be8b36bd768a77163c1bb">column_name</a>) const </td></tr>
<tr class="separator:aa4b815611fd3e8d96710b948d4a925e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c59d3fe72be771526584fb4f8c57291"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a8c59d3fe72be771526584fb4f8c57291">column_names</a> () const </td></tr>
<tr class="separator:a8c59d3fe72be771526584fb4f8c57291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf977faf06367575b7258e3b2dd0c638"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#aaf977faf06367575b7258e3b2dd0c638">column_types</a> () const </td></tr>
<tr class="separator:aaf977faf06367575b7258e3b2dd0c638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609776165bc5f107fd808559487e8cca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a609776165bc5f107fd808559487e8cca">contains_column</a> (const std::string &amp;<a class="el" href="classturi_1_1sframe.html#ae76e42efe25be8b36bd768a77163c1bb">column_name</a>) const </td></tr>
<tr class="separator:a609776165bc5f107fd808559487e8cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f72cf7934d9564ba590657360fb0c0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#ae0f72cf7934d9564ba590657360fb0c0">num_segments</a> () const </td></tr>
<tr class="separator:ae0f72cf7934d9564ba590657360fb0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f835b427c09feb33ff8bbfc021ab7e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a37f835b427c09feb33ff8bbfc021ab7e">segment_length</a> (size_t i) const </td></tr>
<tr class="separator:a37f835b427c09feb33ff8bbfc021ab7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cdabcf1bb49c7b7037d387f6884676"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a74cdabcf1bb49c7b7037d387f6884676">column_index</a> (const std::string &amp;<a class="el" href="classturi_1_1sframe.html#ae76e42efe25be8b36bd768a77163c1bb">column_name</a>) const </td></tr>
<tr class="separator:a74cdabcf1bb49c7b7037d387f6884676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e448d1f15627b3cb7d6860d1003fc4d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a5e448d1f15627b3cb7d6860d1003fc4d">get_index_info</a> () const </td></tr>
<tr class="separator:a5e448d1f15627b3cb7d6860d1003fc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899c746a8d5f1556ae4265cacc2ac25b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a899c746a8d5f1556ae4265cacc2ac25b">append</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;other) const </td></tr>
<tr class="separator:a899c746a8d5f1556ae4265cacc2ac25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee01e7a95370639b3335dc04086b6b5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classturi_1_1sframe.html#a16aa215d59181b6dada3f9107b329674">reader_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a1ee01e7a95370639b3335dc04086b6b5">get_reader</a> () const </td></tr>
<tr class="separator:a1ee01e7a95370639b3335dc04086b6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014dd810ca6750900f52f3989e27a7c3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classturi_1_1sframe.html#a16aa215d59181b6dada3f9107b329674">reader_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a014dd810ca6750900f52f3989e27a7c3">get_reader</a> (size_t <a class="el" href="classturi_1_1sframe.html#ae0f72cf7934d9564ba590657360fb0c0">num_segments</a>) const </td></tr>
<tr class="separator:a014dd810ca6750900f52f3989e27a7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840459486571a6e401fcaa7aa36d40ba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classturi_1_1sframe.html#a16aa215d59181b6dada3f9107b329674">reader_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a840459486571a6e401fcaa7aa36d40ba">get_reader</a> (const std::vector&lt; size_t &gt; &amp;segment_lengths) const </td></tr>
<tr class="separator:a840459486571a6e401fcaa7aa36d40ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15be075f1438b14c3779a6e43d13e4cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a15be075f1438b14c3779a6e43d13e4cf">to_dataframe</a> ()</td></tr>
<tr class="separator:a15be075f1438b14c3779a6e43d13e4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c569f40f1749ecdc9f15ddee3849db"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#af2c569f40f1749ecdc9f15ddee3849db">select_column</a> (size_t column_id) const </td></tr>
<tr class="separator:af2c569f40f1749ecdc9f15ddee3849db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f4eae26003fac1ecd5026550b7181b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#ad8f4eae26003fac1ecd5026550b7181b">select_column</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:ad8f4eae26003fac1ecd5026550b7181b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428a6288c3453b69b01e2bf73051dcc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a428a6288c3453b69b01e2bf73051dcc2">select_columns</a> (const std::vector&lt; std::string &gt; &amp;names) const </td></tr>
<tr class="separator:a428a6288c3453b69b01e2bf73051dcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f870da8bdb1328a358007321540836c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a7f870da8bdb1328a358007321540836c">add_column</a> (std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; sarr_ptr, const std::string &amp;<a class="el" href="classturi_1_1sframe.html#ae76e42efe25be8b36bd768a77163c1bb">column_name</a>=std::string(&quot;&quot;)) const </td></tr>
<tr class="separator:a7f870da8bdb1328a358007321540836c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4a7a265587909bffb1f56c988384f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#add4a7a265587909bffb1f56c988384f0">set_column_name</a> (size_t column_id, const std::string &amp;name)</td></tr>
<tr class="separator:add4a7a265587909bffb1f56c988384f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1873c144320bd0852f1cea46ef275955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a1873c144320bd0852f1cea46ef275955">remove_column</a> (size_t column_id) const </td></tr>
<tr class="separator:a1873c144320bd0852f1cea46ef275955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f67a5df23a70bb324a16ef000af380b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a6f67a5df23a70bb324a16ef000af380b">swap_columns</a> (size_t column_1, size_t column_2) const </td></tr>
<tr class="separator:a6f67a5df23a70bb324a16ef000af380b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944c425b1c643cbcb888c1fb1013b4ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a944c425b1c643cbcb888c1fb1013b4ba">replace_column</a> (std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&gt; sarr_ptr, const std::string &amp;<a class="el" href="classturi_1_1sframe.html#ae76e42efe25be8b36bd768a77163c1bb">column_name</a>) const </td></tr>
<tr class="separator:a944c425b1c643cbcb888c1fb1013b4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f17baba403d32740659b0cbfae5e78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a67f17baba403d32740659b0cbfae5e78">set_num_segments</a> (size_t numseg)</td></tr>
<tr class="separator:a67f17baba403d32740659b0cbfae5e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69503f6f197906bf584990118033ee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html#a0f76b08340fc62df9333bb7c64ff07e0">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#ac69503f6f197906bf584990118033ee5">get_output_iterator</a> (size_t segmentid)</td></tr>
<tr class="separator:ac69503f6f197906bf584990118033ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65e732bf021824f072f76f4fa0dc518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#af65e732bf021824f072f76f4fa0dc518">close</a> ()</td></tr>
<tr class="separator:af65e732bf021824f072f76f4fa0dc518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1788686c4dcd0833329e573652c151ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a1788686c4dcd0833329e573652c151ff">flush_write_to_segment</a> (size_t segment)</td></tr>
<tr class="separator:a1788686c4dcd0833329e573652c151ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a512052797644925a85e798e66033f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a02a512052797644925a85e798e66033f">save_as_csv</a> (std::string csv_file, <a class="el" href="classturi_1_1csv__writer.html">csv_writer</a> &amp;writer)</td></tr>
<tr class="separator:a02a512052797644925a85e798e66033f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0326f469ce7d2d8d65e271e165ded75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#ac0326f469ce7d2d8d65e271e165ded75">set_metadata</a> (const std::string &amp;key, std::string val)</td></tr>
<tr class="separator:ac0326f469ce7d2d8d65e271e165ded75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1356d51aac6d61138777ae0313c115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#afd1356d51aac6d61138777ae0313c115">save</a> (std::string index_file) const </td></tr>
<tr class="separator:afd1356d51aac6d61138777ae0313c115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f81fcf909be27db8a79dcad6ab8696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#af0f81fcf909be27db8a79dcad6ab8696">save</a> (<a class="el" href="classturi_1_1oarchive.html">oarchive</a> &amp;oarc) const </td></tr>
<tr class="separator:af0f81fcf909be27db8a79dcad6ab8696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf73cd84feb34eb5e8c92161c0892be4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#acf73cd84feb34eb5e8c92161c0892be4">try_compact</a> ()</td></tr>
<tr class="separator:acf73cd84feb34eb5e8c92161c0892be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b19605d355ff2abc919e100798c674"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#ae6b19605d355ff2abc919e100798c674">load</a> (<a class="el" href="classturi_1_1iarchive.html">iarchive</a> &amp;iarc)</td></tr>
<tr class="separator:ae6b19605d355ff2abc919e100798c674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d6149fdf153436ff0d8de65beb3104"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray__group__format__writer.html">sarray_group_format_writer</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#a18d6149fdf153436ff0d8de65beb3104">get_internal_writer</a> ()</td></tr>
<tr class="separator:a18d6149fdf153436ff0d8de65beb3104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fd151b3faf36fbb61bb26a82876e6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html#ab8fd151b3faf36fbb61bb26a82876e6e">debug_print</a> ()</td></tr>
<tr class="separator:ab8fd151b3faf36fbb61bb26a82876e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The SFrame is an immutable object that represents a table with rows and columns. Each column is an sarray&lt;flexible_type&gt;, which is a sequence of an object T split into segments. The sframe writes an sarray for each column of data it is given to disk, each with a prefix that extends the prefix given to open. The SFrame is referenced on disk by a single ".frame_idx" file which then has a list of file names, one file for each column.</p>
<p>The SFrame is <b>write-once</b>, <b>read-many</b>. The SFrame can be opened for writing <b>once</b>, after which it is read-only.</p>
<p>Since each column of the SFrame is an independent sarray, as an independent shared_ptr&lt;sarray&lt;flexible_type&gt; &gt; object, columns can be added / removed to form new sframes without problems. As such, certain operations (such as the object returned by add_column) recan be "ephemeral" in that there is no .frame_idx file on disk backing it. An "ephemeral" frame can be identified by checking the result of <a class="el" href="classturi_1_1sframe.html#a00e13a526f55d5a3f7a574d4baa9c970">get_index_file()</a>. If this is empty, it is an ephemeral frame.</p>
<p>The interface for the SFrame pretty much matches that of the <a class="el" href="classturi_1_1sarray.html">sarray</a> as in the SArray's stored type is std::vector&lt;flexible_type&gt;. The SFrame however, also provides a large number of other capabilities such as csv parsing, construction from sarrays, etc. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00067">67</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa2301ed7b71971af8d30913b9d4dfefb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">turi::sframe::sframe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>default constructor; does nothing; use <a class="el" href="classturi_1_1sframe.html#a2198a7cd710ee7447e5f40f32e936da4">open_for_read</a> or <a class="el" href="classturi_1_1sframe.html#af6fdd0cca31cb1c4b44e60b554db28ad">open_for_write</a> after construction to read/create an sarray. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00088">88</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a62e8898c08843348b57c69f78a4ed549"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">turi::sframe::sframe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. If the source frame is opened for writing, this will throw an exception. Otherwise, this will create a frame opened for reading, which shares column arrays with the source frame. </p>

</div>
</div>
<a class="anchor" id="a3931b0e62de68cbb8a1d1e6d5377e748"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">turi::sframe::sframe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00102">102</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69889616c7767e41595ef05b55e1c011"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">turi::sframe::sframe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>frame_idx_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to construct an sframe which reads from the given frame index file. This should be a .frame_idx file. If the index cannot be opened, an exception is thrown. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00128">128</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae46393d4d6bcd598510c6b13b208534b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">turi::sframe::sframe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a>&#160;</td>
          <td class="paramname"><em>frame_index_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct an sframe from sframe index information. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00136">136</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9435077bc8df2a558d762731f4144b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">turi::sframe::sframe </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_names</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fail_on_column_names</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an SFrame from a vector of Sarrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columns</td><td>List of sarrays to form as columns </td></tr>
    <tr><td class="paramname">column_names</td><td>List of the name for each column, with the indices corresponding with the list of columns. If the length of the column_names vector does not match columns, the column gets a default name. For example, if four columns are given and column_names = {id, num}, the columns will be named {"id, "num", "X3", "X4"}. Entries that are zero-length strings will also be given a default name. </td></tr>
    <tr><td class="paramname">fail_on_column_names</td><td>If true, will throw an exception if any column names are unique. If false, will automatically adjust column names so they are unique.</td></tr>
  </table>
  </dd>
</dl>
<p>Throws an exception if any column names are not unique (if fail_on_column_names is true), or if the number of segments, segment sizes, or total sizes of each sarray is not equal. The constructed SFrame is ephemeral, and is not backed by a disk index. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00159">159</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52bb1f5fc9bf12e165a5e0f26df0b2e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">turi::sframe::sframe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an SFrame from <a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Throw an exception if the dataframe contains undefined values (e.g. in sparse rows), </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7f870da8bdb1328a358007321540836c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a> turi::sframe::add_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>sarr_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em> = <code>std::string(&quot;&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new ephemeral SFrame with the new column added to the end. The new sframe is "ephemeral" in that it is not backed by an index on disk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sarr_ptr</td><td>Shared pointer to the SArray </td></tr>
    <tr><td class="paramname">column_name</td><td>The name to give this column. If empty it will be given a default name (X&lt;column index&gt;) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a899c746a8d5f1556ae4265cacc2ac25b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a> turi::sframe::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merges another SFrame with the same schema with the current SFrame returning a new SFrame. Both SFrames can be empty, but cannot be opened for writing. </p>

</div>
</div>
<a class="anchor" id="af65e732bf021824f072f76f4fa0dc518"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closes the sframe. <a class="el" href="classturi_1_1sframe.html#af65e732bf021824f072f76f4fa0dc518">close()</a> also implicitly closes all segments. After the writer is closed, no segments can be written. After the sframe is closed, it becomes read only and can be read with the <a class="el" href="classturi_1_1sframe.html#a1ee01e7a95370639b3335dc04086b6b5">get_reader()</a> function. </p>

<p>Implements <a class="el" href="classturi_1_1swriter__base.html#aa5fd6c371b5acf5218b019181560e489">turi::swriter_base&lt; sframe_output_iterator &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a74cdabcf1bb49c7b7037d387f6884676"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::sframe::column_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the column index of column_name.</p>
<p>Throws an exception of the column_ does not exist. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00457">457</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae76e42efe25be8b36bd768a77163c1bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::sframe::column_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the name of the given column. Throws an exception if the column id is out of range. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00362">362</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c59d3fe72be771526584fb4f8c57291"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; turi::sframe::column_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the column names as a single vector. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00401">401</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99f1301c5f4280e5b53f5b9b22f9bab7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> turi::sframe::column_type </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of the given column. Throws an exception if the column id is out of range. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00374">374</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4b815611fd3e8d96710b948d4a925e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> turi::sframe::column_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of the given column. Throws an exception if the column id is out of range. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00394">394</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf977faf06367575b7258e3b2dd0c638"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&gt; turi::sframe::column_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the column types as a single vector. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00407">407</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a609776165bc5f107fd808559487e8cca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::sframe::contains_column </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the sframe contains the given column. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00418">418</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8fd151b3faf36fbb61bb26a82876e6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::debug_print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For debug purpose, print the information about the sframe. </p>

</div>
</div>
<a class="anchor" id="a1788686c4dcd0833329e573652c151ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::flush_write_to_segment </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush writes for a particular segment </p>

</div>
</div>
<a class="anchor" id="a00e13a526f55d5a3f7a574d4baa9c970"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; turi::sframe::get_index_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the index file of the sframe </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00308">308</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e448d1f15627b3cb7d6860d1003fc4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a> turi::sframe::get_index_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current index info of the array. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00472">472</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a18d6149fdf153436ff0d8de65beb3104"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray__group__format__writer.html">sarray_group_format_writer</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; turi::sframe::get_internal_writer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal API. Used to obtain the internal writer object. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00691">691</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ec969c283ce5cb16b02ccb9c0c2abc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::sframe::get_metadata </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the value of a key associated with the sframe Returns true on success, false on failure. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00318">318</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a402e330a7269b93bd0a388c5b58875c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, std::string&gt; turi::sframe::get_metadata </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the value of a key associated with the sframe Returns a pair of (true, value) on success, and (false, empty_string) on failure. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00330">330</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac69503f6f197906bf584990118033ee5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html#a0f76b08340fc62df9333bb7c64ff07e0">iterator</a> turi::sframe::get_output_iterator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>segmentid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets an output iterator for the given segment. This can be used to write data to the segment, and is currently the only supported way to do so.</p>
<p>The iterator is invalid once the segment is closed (See <a class="el" href="classturi_1_1sframe.html#af65e732bf021824f072f76f4fa0dc518">close</a>). Accessing the iterator after the writer is destroyed is undefined behavior.</p>
<p>Cannot be called until the sframe is open.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// example to write the same vector to 7 rows of segment 1</span></div><div class="line"><span class="comment">// let&#39;s say the sframe has 5 columns of type FLEX_TYPE_ENUM::INTEGER</span></div><div class="line"><span class="comment">// and sfw is the sframe.</span></div><div class="line"><span class="keyword">auto</span> iter = sfw.get_output_iterator(1);</div><div class="line">std::vector&lt;flexible_type&gt; vals{1,2,3,4,5}</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; ++i) {</div><div class="line">  *iter = vals;</div><div class="line">  ++iter;</div><div class="line">}</div></div><!-- fragment --> 
<p>Implements <a class="el" href="classturi_1_1swriter__base.html#a297f3dac3892b800eb37e366afab2bf1">turi::swriter_base&lt; sframe_output_iterator &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1ee01e7a95370639b3335dc04086b6b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classturi_1_1sframe.html#a16aa215d59181b6dada3f9107b329674">reader_type</a>&gt; turi::sframe::get_reader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets an sframe reader object with the segment layout of the first column. </p>

</div>
</div>
<a class="anchor" id="a014dd810ca6750900f52f3989e27a7c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classturi_1_1sframe.html#a16aa215d59181b6dada3f9107b329674">reader_type</a>&gt; turi::sframe::get_reader </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_segments</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets an sframe reader object with num_segments number of logical segments. </p>

</div>
</div>
<a class="anchor" id="a840459486571a6e401fcaa7aa36d40ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classturi_1_1sframe.html#a16aa215d59181b6dada3f9107b329674">reader_type</a>&gt; turi::sframe::get_reader </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>segment_lengths</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets an sframe reader object with a custom segment layout. segment_lengths must sum up to the same length as the original array. </p>

</div>
</div>
<a class="anchor" id="a4a668c3d64d91ad561a5fb01b44087c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; &gt; turi::sframe::init_from_csvs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structturi_1_1csv__line__tokenizer.html">csv_line_tokenizer</a> &amp;&#160;</td>
          <td class="paramname"><em>tokenizer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>continue_on_failure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>store_errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt;&#160;</td>
          <td class="paramname"><em>column_type_hints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>output_columns</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_limit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>skip_rows</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an SFrame from a csv file.</p>
<p>All columns will be parsed into flex_string unless the column type is specified in the column_type_hints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The url to the csv file. The url can points to local filesystem, hdfs, or s3. </td></tr>
    <tr><td class="paramname">tokenizer</td><td>The tokenization rules to use </td></tr>
    <tr><td class="paramname">use_header</td><td>If true, the first line will be parsed as column headers. Otherwise, R-style column names, i.e. X1, X2, X3... will be used. </td></tr>
    <tr><td class="paramname">continue_on_failure</td><td>If true, lines with parsing errors will be skipped. </td></tr>
    <tr><td class="paramname">column_type_hints</td><td>A map from column name to the column type. </td></tr>
    <tr><td class="paramname">output_columns</td><td>The subset of column names to output </td></tr>
    <tr><td class="paramname">row_limit</td><td>If non-zero, the maximum number of rows to read </td></tr>
    <tr><td class="paramname">skip_rows</td><td>If non-zero, the number of lines to skip at the start of each file</td></tr>
  </table>
  </dd>
</dl>
<p>Throws an exception if IO error or csv parse failed. </p>

</div>
</div>
<a class="anchor" id="a97da4af9a76b174dca431a49e6170e85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::sframe::is_opened_for_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the Array is opened for reading. i.e. <a class="el" href="classturi_1_1sframe.html#a1ee01e7a95370639b3335dc04086b6b5">get_reader()</a> will succeed </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00291">291</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a61dd5af96ff258bf5eb59b7ab87e2ebb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::sframe::is_opened_for_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the Array is opened for writing. i.e. <a class="el" href="classturi_1_1sframe.html#ac69503f6f197906bf584990118033ee5">get_output_iterator()</a> will succeed </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00300">300</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae6b19605d355ff2abc919e100798c674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1iarchive.html">iarchive</a> &amp;&#160;</td>
          <td class="paramname"><em>iarc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SFrame deserializer. iarc must be associated with a directory. Loads from the next prefix inside the directory. </p>

</div>
</div>
<a class="anchor" id="ae0f72cf7934d9564ba590657360fb0c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::sframe::num_segments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of segments that this SFrame will be written with. Never fails. </p>

<p>Implements <a class="el" href="classturi_1_1swriter__base.html#a629a0a8e84794d537b764a5e544f809f">turi::swriter_base&lt; sframe_output_iterator &gt;</a>.</p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00430">430</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2198a7cd710ee7447e5f40f32e936da4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::open_for_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a>&#160;</td>
          <td class="paramname"><em>frame_index_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the SFrame with an index_information. If the SFrame is already inited, this will throw an exception </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00215">215</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7ea0ed7a4f5fc96614a606d2c16dde0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::open_for_read </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_names</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fail_on_column_names</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the SFrame with a collection of columns. If the SFrame is already inited, this will throw an exception. Will throw an exception if column_names are not unique and fail_on_column_names is true. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00228">228</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6fdd0cca31cb1c4b44e60b554db28ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::open_for_write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>frame_sidx_file</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nsegments</em> = <code><a class="el" href="group__sframe__main.html#ga0a14c814ad647a718e7ff20ef2999653">SFRAME_DEFAULT_NUM_SEGMENTS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fail_on_column_names</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens the SFrame with an arbitrary temporary file. The array must not already been inited.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_names</td><td>The name for each column. If the vector is shorter than column_types, or empty values are given, names are handled with default names of "X&lt;column id+1&gt;". Each column name must be unique. This will let you write non-unique column names, but if you do that, the sframe will throw an exception while constructing the output of this class. </td></tr>
    <tr><td class="paramname">column_types</td><td>The type of each column expressed as a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>. Currently this is required to tell how many columns are a part of the sframe. Throws an exception if this is an empty vector. </td></tr>
    <tr><td class="paramname">nsegments</td><td>The number of parallel output segments on each sarray. Throws an exception if this is 0. </td></tr>
    <tr><td class="paramname">frame_sidx_file</td><td>If not specified, an argitrary temporary file will be created. Otherwise, all frame files will be written to the same location as the frame_sidx_file. Must end in ".frame_idx" </td></tr>
    <tr><td class="paramname">fail_on_column_names</td><td>If true, will throw an exception if any column names are unique. If false, will automatically adjust column names so they are unique. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00265">265</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2dcf8b9ad3084023429d6c05cdd7df26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a>&amp; turi::sframe::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator. If the source frame is opened for writing, this will throw an exception. Otherwise, this will create a frame opened for reading, which shares column arrays with the source frame. </p>

</div>
</div>
<a class="anchor" id="a1ed46f42c0f791a2a49159eefde2a705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a>&amp; turi::sframe::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move Assignment operator. Moves other into this. Other will be cleared as if it is a newly constructed sframe object. </p>

</div>
</div>
<a class="anchor" id="a1873c144320bd0852f1cea46ef275955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a> turi::sframe::remove_column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>column_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new ephemeral SFrame with the column removed. The new sframe is "ephemeral" in that it is not backed by an index on disk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_id</td><td>The index of the column to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a944c425b1c643cbcb888c1fb1013b4ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a> turi::sframe::replace_column </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>sarr_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace the column of the given column name with a new sarray. Return the new sframe with old column_name sarray replaced by the new sarray. </p>

</div>
</div>
<a class="anchor" id="afd1356d51aac6d61138777ae0313c115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::save </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>index_file</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves a copy of the current sframe into a different location. Does not modify the current sframe. </p>

</div>
</div>
<a class="anchor" id="af0f81fcf909be27db8a79dcad6ab8696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1oarchive.html">oarchive</a> &amp;&#160;</td>
          <td class="paramname"><em>oarc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SFrame serializer. oarc must be associated with a directory. Saves into a prefix inside the directory. </p>

</div>
</div>
<a class="anchor" id="a02a512052797644925a85e798e66033f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::save_as_csv </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>csv_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1csv__writer.html">csv_writer</a> &amp;&#160;</td>
          <td class="paramname"><em>writer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves a copy of the current sframe as a CSV file. Does not modify the current sframe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csv_file</td><td>target CSV file to save into </td></tr>
    <tr><td class="paramname">writer</td><td>The CSV writer configuration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37f835b427c09feb33ff8bbfc021ab7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::sframe::segment_length </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of segments in the collection. Will throw an exception if the writer is invalid (there is an error opening/writing files) </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00445">445</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2c569f40f1749ecdc9f15ddee3849db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; turi::sframe::select_column </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>column_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an sarray of the specific column.</p>
<p>Throws an exception if the column does not exist. </p>

</div>
</div>
<a class="anchor" id="ad8f4eae26003fac1ecd5026550b7181b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; turi::sframe::select_column </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an sarray of the specific column by name.</p>
<p>Throws an exception if the column does not exist. </p>

</div>
</div>
<a class="anchor" id="a428a6288c3453b69b01e2bf73051dcc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a> turi::sframe::select_columns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns new sframe containing only the chosen columns in the same order. The new sframe is "ephemeral" in that it is not backed by an index on disk.</p>
<p>Throws an exception if the column name does not exist. </p>

</div>
</div>
<a class="anchor" id="add4a7a265587909bffb1f56c988384f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::set_column_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>column_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the ith column name to name. This can be done when the frame is open in either reading or writing mode. Changes are ephemeral, and do not affect what is stored on disk. </p>

</div>
</div>
<a class="anchor" id="ac0326f469ce7d2d8d65e271e165ded75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::sframe::set_metadata </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds meta data to the frame. Frame must be first opened for writing. </p>

</div>
</div>
<a class="anchor" id="a67f17baba403d32740659b0cbfae5e78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::sframe::set_num_segments </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numseg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the number of segments in the output. Frame must be first opened for writing. Once an output iterator has been obtained, the number of segments can no longer be changed. Returns true on sucess, false on failure. </p>

<p>Implements <a class="el" href="classturi_1_1swriter__base.html#a25e1d07938d770deb9835dd817ef5068">turi::swriter_base&lt; sframe_output_iterator &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8fda4767861565784f7f9a2f964b5142"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::sframe::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the sframe. If the sframe was not initialized, returns 0. </p>

<p>Definition at line <a class="el" href="sframe_8hpp_source.html#l00354">354</a> of file <a class="el" href="sframe_8hpp_source.html">sframe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f67a5df23a70bb324a16ef000af380b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a> turi::sframe::swap_columns </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>column_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>column_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new ephemeral SFrame with two columns swapped. The new sframe is "ephemeral" in that it is not backed by an index on disk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_1</td><td>The index of the first column. </td></tr>
    <tr><td class="paramname">column_2</td><td>The index of the second column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15be075f1438b14c3779a6e43d13e4cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a> turi::sframe::to_dataframe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the sframe into a <a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a>. Will reset iterators before and after the operation. </p>

</div>
</div>
<a class="anchor" id="acf73cd84feb34eb5e8c92161c0892be4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe::try_compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to compact if the number of segments in the SArray exceeds SFRAME_COMPACTION_THRESHOLD. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/storage/sframe_data/<a class="el" href="sframe_8hpp_source.html">sframe.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="classturi_1_1sframe.html">sframe</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
