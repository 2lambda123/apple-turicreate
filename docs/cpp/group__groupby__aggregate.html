<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: Groupby Aggregation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__groupby__aggregate.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Groupby Aggregation<div class="ingroups"><a class="el" href="group__sframe__physical.html">SFrame : Physical</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceturi_1_1groupby__aggregate__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1groupby__aggregate__impl.html">turi::groupby_aggregate_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1groupby__operators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1groupby__operators.html">turi::groupby_operators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1rolling__aggregate"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1rolling__aggregate.html">turi::rolling_aggregate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1group__aggregate__value.html">turi::group_aggregate_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1hash__bucket.html">turi::hash_bucket&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1hash__bucket__container.html">turi::hash_bucket_container&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa75ddff4dad3bde4e20c01bb4f038464"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__groupby__aggregate.html#gaa75ddff4dad3bde4e20c01bb4f038464">turi::get_builtin_group_aggregator</a> (const std::string &amp;)</td></tr>
<tr class="separator:gaa75ddff4dad3bde4e20c01bb4f038464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f524221cf7cf02af960b90b93f120a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__groupby__aggregate.html#ga77f524221cf7cf02af960b90b93f120a">turi::group</a> (<a class="el" href="classturi_1_1sframe.html">sframe</a> sframe_in, std::string key_column)</td></tr>
<tr class="separator:ga77f524221cf7cf02af960b90b93f120a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c719d63eb3444a673e8899c33c8496e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__groupby__aggregate.html#ga8c719d63eb3444a673e8899c33c8496e">turi::groupby_aggregate</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;source, const std::vector&lt; std::string &gt; &amp;<a class="el" href="group__set__and__map.html#ga918b8235a3af13f02053fdf76c17ae83">keys</a>, const std::vector&lt; std::string &gt; &amp;group_output_columns, const std::vector&lt; std::pair&lt; std::vector&lt; std::string &gt;, std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt;&gt;&gt; &amp;groups, size_t max_buffer_size=<a class="el" href="group__sframe__main.html#gaff6a4d5002d4a34ebd125418f019ef9f">SFRAME_GROUPBY_BUFFER_NUM_ROWS</a>)</td></tr>
<tr class="separator:ga8c719d63eb3444a673e8899c33c8496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae15bb70a0154553ab4e21064a074d4fc"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__groupby__aggregate.html#gae15bb70a0154553ab4e21064a074d4fc">turi::rolling_aggregate::rolling_apply</a> (const <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;input, std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt; agg_op, ssize_t window_start, ssize_t window_end, size_t min_observations)</td></tr>
<tr class="separator:gae15bb70a0154553ab4e21064a074d4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c173928d91efdea1dfe4f626c1556f"><td class="memTemplParams" colspan="2"><a id="ga22c173928d91efdea1dfe4f626c1556f"></a>
template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ga22c173928d91efdea1dfe4f626c1556f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__groupby__aggregate.html#ga22c173928d91efdea1dfe4f626c1556f">turi::rolling_aggregate::full_window_aggregate</a> (std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt; agg_op, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ga22c173928d91efdea1dfe4f626c1556f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregate functions. <br /></td></tr>
<tr class="separator:ga22c173928d91efdea1dfe4f626c1556f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d6df0f3e1a0af92200c2d4ceb59dfc5"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ga2d6df0f3e1a0af92200c2d4ceb59dfc5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__groupby__aggregate.html#ga2d6df0f3e1a0af92200c2d4ceb59dfc5">turi::rolling_aggregate::has_min_observations</a> (size_t min_observations, Iterator first, Iterator last)</td></tr>
<tr class="separator:ga2d6df0f3e1a0af92200c2d4ceb59dfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Hash function.</p>
<p>This allows us to add groupby_element to an std::unordered_set </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa75ddff4dad3bde4e20c01bb4f038464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa75ddff4dad3bde4e20c01bb4f038464">&#9670;&nbsp;</a></span>get_builtin_group_aggregator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a>&gt; turi::get_builtin_group_aggregator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to convert string aggregator name into builtin aggregator value.</p>
<p>Implementation is in groupby_operators.hpp </p>

</div>
</div>
<a id="ga77f524221cf7cf02af960b90b93f120a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77f524221cf7cf02af960b90b93f120a">&#9670;&nbsp;</a></span>group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a> turi::group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td>
          <td class="paramname"><em>sframe_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>key_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Group the sframe rows by the key_column.</p>
<p>Like a sort, but not. </p>

</div>
</div>
<a id="ga8c719d63eb3444a673e8899c33c8496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c719d63eb3444a673e8899c33c8496e">&#9670;&nbsp;</a></span>groupby_aggregate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a> turi::groupby_aggregate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>group_output_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::vector&lt; std::string &gt;, std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_buffer_size</em> = <code><a class="el" href="group__sframe__main.html#gaff6a4d5002d4a34ebd125418f019ef9f">SFRAME_GROUPBY_BUFFER_NUM_ROWS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Groupby Aggregate function for an SFrame. Given the source SFrame this function performs a group-by aggregate of the SFrame, using one or more columns to define the group key, and a descriptor for how to aggregate other non-key columns.</p>
<p>For instance given an SFrame: </p><pre class="fragment">* user_id  movie_id  rating  time
*      5        10       1    4pm
*      5        15       2    1pm
*      6        12       1    2pm
*      7        13       1    3am
* </pre> <div class="fragment"><div class="line">sframe output = <a class="code" href="group__groupby__aggregate.html#ga8c719d63eb3444a673e8899c33c8496e">turi::groupby_aggregate</a>(input,</div><div class="line">                   {<span class="stringliteral">&quot;user_id&quot;</span>},</div><div class="line">                   {<span class="stringliteral">&quot;movie_count&quot;</span>, <span class="stringliteral">&quot;rating_sum&quot;</span>},</div><div class="line">                   {{<span class="stringliteral">&quot;movie_id&quot;</span>, std::make_shared&lt;groupby_operators::count&gt;()},</div><div class="line">                   {<span class="stringliteral">&quot;rating&quot;</span>, std::make_shared&lt;groupby_operators::sum&gt;()}});</div></div><!-- fragment --><p>will generate groups based on the user_id column, and within each group, count the movie_id, and sum the ratings. </p><pre class="fragment">* user_id  "Count of movie_id"  "Sum of rating"
*      5                    2               3
*      6                    1               1
*      7                    1               1
* </pre><p>See groupby_aggregate_operators for operators that have been implemented.</p>
<h2>Describing a Group </h2>
<p>A group is basically a pair of column-name and the operator. The column name can be any existing column in the table (there is no restriction. You can group on user_id and aggregate on user_id, though the result is typically not very meaningful). A special column name with the empty string "" is also defined in which case, the aggregator will be sent a flexible type of type FLEX_UNDEFINED for every row (this is useful for COUNT).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The input SFrame to group </td></tr>
    <tr><td class="paramname">keys</td><td>An array of column names to generate the group on </td></tr>
    <tr><td class="paramname">group_output_columns</td><td>The output column names for each aggregate. This must be the same length as the 'groups' parameter. Output column names must be unique and must not share similar column names as keys. If there are any empty entries, their values will be automatically assigned. </td></tr>
    <tr><td class="paramname">groups</td><td>A collection of {column_names, group operator} pairs describing the aggregates to generate. You can have multiple aggregators for each set of columns. You do not need every column in the source to be represented. This must be the same length as the 'group_output_columns' parameter. </td></tr>
    <tr><td class="paramname">max_buffer_size</td><td>The maximum size of intermediate aggregation buffers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new aggregated SFrame. throws a string exception on failures. </dd></dl>

</div>
</div>
<a id="ga2d6df0f3e1a0af92200c2d4ceb59dfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d6df0f3e1a0af92200c2d4ceb59dfc5">&#9670;&nbsp;</a></span>has_min_observations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool turi::rolling_aggregate::has_min_observations </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_observations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scans the current window to check for the number of non-NULL values.</p>
<p>Returns true if the number of non-NULL values is &gt;= min_observations, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="rolling__aggregate_8hpp_source.html#l00084">84</a> of file <a class="el" href="rolling__aggregate_8hpp_source.html">rolling_aggregate.hpp</a>.</p>

</div>
</div>
<a id="gae15bb70a0154553ab4e21064a074d4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae15bb70a0154553ab4e21064a074d4fc">&#9670;&nbsp;</a></span>rolling_apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; turi::rolling_aggregate::rolling_apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt;&#160;</td>
          <td class="paramname"><em>agg_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>window_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>window_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_observations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply an aggregate function over a moving window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input SArray (expects to be materialized) </td></tr>
    <tr><td class="paramname">agg_op</td><td>The aggregator. These classes are the same as used by groupby. </td></tr>
    <tr><td class="paramname">window_start</td><td>The start of the moving window relative to the current value being calculated, inclusive. For example, 2 values behind the current would be -2, and 0 indicates that the start of the window is the current value. </td></tr>
    <tr><td class="paramname">window_end</td><td>The end of the moving window relative to the current value being calculated, inclusive. Must be greater than <code>window_start</code>. For example, 0 would indicate that the current value is the end of the window, and 2 would indicate that the window ends at 2 data values after the current. </td></tr>
    <tr><td class="paramname">min_observations</td><td>The minimum allowed number of non-NULL values in the moving window for the emitted value to be non-NULL. size_t(-1) indicates that all values must be non-NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns an SArray of the same length as the input, with a type that matches the type output by the aggregation function.</p>
<p>Throws an exception if:</p><ul>
<li>window_end &lt; window_start</li>
<li>The window size is excessively large (currently hardcoded to UINT_MAX).</li>
<li>The given function name corresponds to a function that will not operate on the data type of the input SArray.</li>
<li>The aggregation function returns more than one non-NULL types. </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
