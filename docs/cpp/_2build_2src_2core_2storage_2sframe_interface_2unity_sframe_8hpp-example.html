<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: /build/src/core/storage/sframe_interface/unity_sframe.hpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_2build_2src_2core_2storage_2sframe_interface_2unity_sframe_8hpp-example.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/build/src/core/storage/sframe_interface/unity_sframe.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>Generate a new column name</p>
<p>New column name is in the form of X1, X2, X3 .... In case of conflict, add .1, .2 until conflict is resolved.</p>
<p>Given current sframe column names: a, b, c Next 3 generated names are: X4, X5, X6</p>
<p>Given current sframe column names: X4, X5.1, X6.2 Next 3 generated names are: X4.1, X5, X6.1</p>
<div class="fragment"><div class="line"><span class="comment">/* Copyright Â© 2017 Apple Inc. All rights reserved.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Use of this source code is governed by a BSD-3-clause license that can</span></div><div class="line"><span class="comment"> * be found in the LICENSE.txt file or at https://opensource.org/licenses/BSD-3-Clause</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="preprocessor">#ifndef TURI_UNITY_SFRAME_HPP</span></div><div class="line"><span class="preprocessor">#define TURI_UNITY_SFRAME_HPP</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;model_server/lib/api/unity_sframe_interface.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;core/storage/sframe_interface/unity_sarray.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;core/storage/sframe_data/group_aggregate_value.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;core/storage/sframe_data/sframe_rows.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;visualization/server/plot.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceturi.html">turi</a> {</div><div class="line"></div><div class="line"><span class="comment">// forward declarations</span></div><div class="line"><span class="keyword">class </span>sframe;</div><div class="line"><span class="keyword">class </span>dataframe;</div><div class="line"><span class="keyword">class </span>sframe_reader;</div><div class="line"><span class="keyword">class </span>sframe_iterator;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>query_eval {</div><div class="line"><span class="keyword">struct </span>planner_node;</div><div class="line">} <span class="comment">// query_eval</span></div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * This is the SFrame object exposed to Python. It stores internally an</span></div><div class="line"><span class="comment"> * \ref sframe object which is a collection of named columns, each of flexible</span></div><div class="line"><span class="comment"> * type. The SFrame represents a complete immutable collection of columns.</span></div><div class="line"><span class="comment"> * Once created, it cannot be modified. However, shallow copies or sub-selection</span></div><div class="line"><span class="comment"> * of columns can be created cheaply.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Internally it is simply a single shared_ptr to a \ref sframe object. The</span></div><div class="line"><span class="comment"> * sframe construction is delayed until one of the construct calls are made.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * \code</span></div><div class="line"><span class="comment"> * unity_sframe frame;</span></div><div class="line"><span class="comment"> * // construct</span></div><div class="line"><span class="comment"> * frame.construct(...)</span></div><div class="line"><span class="comment"> * // frame is now immutable.</span></div><div class="line"><span class="comment"> * \endcode</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The SFrame may require temporary on disk storage which will be deleted</span></div><div class="line"><span class="comment"> * on program termination. Temporary file names are obtained from</span></div><div class="line"><span class="comment"> * \ref turi::get_temp_name</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">class </span>unity_sframe : <span class="keyword">public</span> unity_sframe_base {</div><div class="line"> <span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Default constructor. Does nothing</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  unity_sframe();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Destructor. Calls clear().</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  ~unity_sframe();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Constructs an Sframe using a dataframe as input.</span></div><div class="line"><span class="comment">   * Dataframe must not contain NaN values.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> construct_from_dataframe(<span class="keyword">const</span> dataframe_t&amp; df) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Constructs an Sframe using a sframe as input.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> construct_from_sframe(<span class="keyword">const</span> sframe&amp; sf);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Constructs an SFrame from an existing directory on disk saved with</span></div><div class="line"><span class="comment">   * save_frame() or a on disk sarray prefix (saved with</span></div><div class="line"><span class="comment">   * save_frame_by_index_file()). This function will automatically detect if</span></div><div class="line"><span class="comment">   * the location is a directory, or a file. The files will not be deleted on</span></div><div class="line"><span class="comment">   * destruction.  If the current object is already storing an frame, it is</span></div><div class="line"><span class="comment">   * cleared (\ref clear()). May throw an exception on failure. If an exception</span></div><div class="line"><span class="comment">   * occurs, the contents of SArray is empty.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> construct_from_sframe_index(std::string index_file) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Constructs an SFrame from one or more csv files.</span></div><div class="line"><span class="comment">   * To keep the interface stable, the CSV parsing configuration read from a</span></div><div class="line"><span class="comment">   * map of string-&gt;flexible_type called parsing_config. The URL can be a single</span></div><div class="line"><span class="comment">   * filename or a directory name. When passing in a directory and the pattern</span></div><div class="line"><span class="comment">   * is non-empty, we will attempt to treat it as a glob pattern.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * The default parsing configuration is the following:</span></div><div class="line"><span class="comment">   * \code</span></div><div class="line"><span class="comment">   * bool use_header = true;</span></div><div class="line"><span class="comment">   * tokenizer.delimiter = &quot;,&quot;;</span></div><div class="line"><span class="comment">   * tokenizer.comment_char = &#39;\0&#39;;</span></div><div class="line"><span class="comment">   * tokenizer.escape_char = &#39;\\&#39;;</span></div><div class="line"><span class="comment">   * tokenizer.double_quote = true;</span></div><div class="line"><span class="comment">   * tokenizer.quote_char = &#39;\&quot;&#39;;</span></div><div class="line"><span class="comment">   * tokenizer.skip_initial_space = true;</span></div><div class="line"><span class="comment">   * \endcode</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * The fields in parsing config are:</span></div><div class="line"><span class="comment">   *  - use_header : True if not is_zero()</span></div><div class="line"><span class="comment">   *  - delimiter : The entire delimiter string</span></div><div class="line"><span class="comment">   *  - comment_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - escape_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - double_quote : True if not is zero()</span></div><div class="line"><span class="comment">   *  - quote_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - skip_initial_space : True if not is zero()</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::map&lt;std::string, std::shared_ptr&lt;unity_sarray_base&gt;&gt; construct_from_csvs(</div><div class="line">      std::string url,</div><div class="line">      std::map&lt;std::string, flexible_type&gt; parsing_config,</div><div class="line">      std::map&lt;std::string, flex_type_enum&gt; column_type_hints) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> construct_from_planner_node(std::shared_ptr&lt;query_eval::planner_node&gt; node,</div><div class="line">                                   <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; column_names);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Saves a copy of the current sframe into a directory.</span></div><div class="line"><span class="comment">   * Does not modify the current sframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> save_frame(std::string target_directory) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Performs an incomplete save of an existing SFrame into a directory.</span></div><div class="line"><span class="comment">   * This saved SFrame may reference SFrames in other locations *in the same</span></div><div class="line"><span class="comment">   * filesystem* for certain columns/segments/etc.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Does not modify the current sframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> save_frame_reference(std::string target_directory) <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Saves a copy of the current sframe into a target location defined by</span></div><div class="line"><span class="comment">   * an index file. DOes not modify the current sframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> save_frame_by_index_file(std::string index_file);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Clears the contents of the SFrame.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns the number of rows in the SFrame. Returns 0 if the SFrame is empty.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">size_t</span> size() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns the number of columns in the SFrame.</span></div><div class="line"><span class="comment">   * Returns 0 if the sframe is empty.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">size_t</span> num_columns() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns an array containing the datatype of each column. The length</span></div><div class="line"><span class="comment">   * of the return array is equal to num_columns(). If the sframe is empty,</span></div><div class="line"><span class="comment">   * this returns an empty array.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::vector&lt;flex_type_enum&gt; dtype() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns the dtype of a particular column.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <a name="a0"></a><a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> dtype(<span class="keywordtype">size_t</span> column_index);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns the dtype of a particular column.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> dtype(<span class="keyword">const</span> std::string&amp; column_name);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns an array containing the name of each column. The length</span></div><div class="line"><span class="comment">   * of the return array is equal to num_columns(). If the sframe is empty,</span></div><div class="line"><span class="comment">   * this returns an empty array.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::vector&lt;std::string&gt; column_names() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns some number of rows of the SFrame in a dataframe representation.</span></div><div class="line"><span class="comment">   * if nrows exceeds the number of rows in the SFrame ( \ref size() ), this</span></div><div class="line"><span class="comment">   * returns only \ref size() rows.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; head(<span class="keywordtype">size_t</span> nrows) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   *  Returns the index of the column `name`</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">size_t</span> column_index(<span class="keyword">const</span> std::string&amp; name) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   *  Returns the name of the column in position `index.`</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">const</span> std::string&amp; column_name(<span class="keywordtype">size_t</span> index);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns true if the column is present in the sframe, and false</span></div><div class="line"><span class="comment">   * otherwise.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">bool</span> contains_column(<span class="keyword">const</span> std::string &amp;name);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Same as head, returning dataframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  dataframe_t _head(<span class="keywordtype">size_t</span> nrows) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns some number of rows from the end of the SFrame in a dataframe</span></div><div class="line"><span class="comment">   * representation. If nrows exceeds the number of rows in the SFrame</span></div><div class="line"><span class="comment">   * ( \ref size() ), this returns only \ref size() rows.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; tail(<span class="keywordtype">size_t</span> nrows) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Same as head, returning dataframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  dataframe_t _tail(<span class="keywordtype">size_t</span> nrows) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns an SArray with the column that corresponds to &#39;name&#39;.  Throws an</span></div><div class="line"><span class="comment">   * exception if the name is not in the current SFrame.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sarray_base&gt; select_column(<span class="keyword">const</span> std::string &amp;name) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns an SArray with the column that corresponds to index idx.  Throws an</span></div><div class="line"><span class="comment">   * exception if the name is not in the current SFrame.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sarray_base&gt; select_column(<span class="keywordtype">size_t</span> idx);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new SFrame which is filtered by a given logical column.</span></div><div class="line"><span class="comment">   * The index array must be the same length as the current array. An output</span></div><div class="line"><span class="comment">   * array is returned containing only the elements in the current where are the</span></div><div class="line"><span class="comment">   * corresponding element in the index array evaluates to true.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; logical_filter(std::shared_ptr&lt;unity_sarray_base&gt; index) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns an lazy sframe with the columns that have the given names. Throws an</span></div><div class="line"><span class="comment">   * exception if ANY of the names given are not in the current SFrame.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; select_columns(<span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;names) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns an lazy sframe with the columns given by the indices.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; select_columns(<span class="keyword">const</span> std::vector&lt;size_t&gt;&amp; indices);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns an lazy sframe which a the copy of the current one</span></div><div class="line"><span class="comment">  */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a1"></a><a class="code" href="group__eager__algorithms.html#ga085e14fe4c4747d6be6088737cec74e8">copy</a>();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Mutates the current SFrame by adding the given column.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Throws an exception if:</span></div><div class="line"><span class="comment">   *  - The given column has a different number of rows than the SFrame.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> add_column(std::shared_ptr&lt;unity_sarray_base &gt;data, <span class="keyword">const</span> std::string &amp;name) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Mutates the current SFrame by adding the given columns.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Throws an exception if ANY given column cannot be added</span></div><div class="line"><span class="comment">   * (for one of the reasons that add_column can fail).</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \note Currently leaves the SFrame in an unfinished state if one of the</span></div><div class="line"><span class="comment">   * columns fails...the columns before that were added successfully will</span></div><div class="line"><span class="comment">   * be there. This needs to be changed.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> add_columns(std::list&lt;std::shared_ptr&lt;unity_sarray_base&gt;&gt; data_list,</div><div class="line">                   std::vector&lt;std::string&gt; name_vec) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new sarray which is a transform of each row in the sframe</span></div><div class="line"><span class="comment">   * using a Python lambda function pickled into a string.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sarray_base&gt; <a name="a2"></a><a class="code" href="group__eager__algorithms.html#gaa10744bd79ea1690d46f800c003c2a94">transform</a>(<span class="keyword">const</span> std::string&amp; lambda,</div><div class="line">                                               <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type,</div><div class="line">                                               <span class="keywordtype">bool</span> skip_undefined,</div><div class="line">                                               uint64_t <a name="a3"></a><a class="code" href="group__random.html#ga2a9e1d70141f65d9de3a2f2fe45a0d88">seed</a>) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new sarray which is a transform of each row in the sframe</span></div><div class="line"><span class="comment">   * using a Python lambda function pickled into a string.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sarray_base&gt; transform_native(<span class="keyword">const</span> function_closure_info&amp; lambda,</div><div class="line">                                                      <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type,</div><div class="line">                                                      <span class="keywordtype">bool</span> skip_undefined,</div><div class="line">                                                      uint64_t seed) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new sarray which is a transform of each row in the sframe</span></div><div class="line"><span class="comment">   * using a Python lambda function pickled into a string.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sarray_base&gt; transform_lambda(</div><div class="line">      std::function&lt;flexible_type(<span class="keyword">const</span> sframe_rows::row&amp;)&gt; lambda,</div><div class="line">      <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type,</div><div class="line">      uint64_t seed);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new sarray which is a transform of each row in the sframe</span></div><div class="line"><span class="comment">   * using a Python lambda function pickled into a string.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; flat_map(<span class="keyword">const</span> std::string&amp; lambda,</div><div class="line">                                              std::vector&lt;std::string&gt; output_column_names,</div><div class="line">                                              std::vector&lt;flex_type_enum&gt; output_column_types,</div><div class="line">                                              <span class="keywordtype">bool</span> skip_undefined,</div><div class="line">                                              uint64_t seed) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Set the ith column name.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Throws an exception if index out of bound or name already exists.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> set_column_name(<span class="keywordtype">size_t</span> i, std::string name) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Remove the ith column.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> remove_column(<span class="keywordtype">size_t</span> i) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Swap the ith and jth columns.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> swap_columns(<span class="keywordtype">size_t</span> i, <span class="keywordtype">size_t</span> j) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns the underlying shared_ptr to the sframe object.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;sframe&gt; get_underlying_sframe();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns the underlying planner pointer</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;query_eval::planner_node&gt; get_planner_node();</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Sets the private shared pointer to an sframe.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> set_sframe(<span class="keyword">const</span> std::shared_ptr&lt;sframe&gt;&amp; sf_ptr);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Begin iteration through the SFrame.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Works together with \ref iterator_get_next(). The usage pattern</span></div><div class="line"><span class="comment">   * is as follows:</span></div><div class="line"><span class="comment">   * \code</span></div><div class="line"><span class="comment">   * sframe.begin_iterator();</span></div><div class="line"><span class="comment">   * while(1) {</span></div><div class="line"><span class="comment">   *   auto ret = sframe.iterator_get_next(64);</span></div><div class="line"><span class="comment">   *   // do stuff</span></div><div class="line"><span class="comment">   *   if (ret.size() &lt; 64) {</span></div><div class="line"><span class="comment">   *     // we are done</span></div><div class="line"><span class="comment">   *     break;</span></div><div class="line"><span class="comment">   *   }</span></div><div class="line"><span class="comment">   * }</span></div><div class="line"><span class="comment">   * \endcode</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Note that use of pretty much any of the other data-dependent SArray</span></div><div class="line"><span class="comment">   * functions will invalidate the iterator.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> begin_iterator() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Obtains the next block of elements of size len from the SFrame.</span></div><div class="line"><span class="comment">   * Works together with \ref begin_iterator(). See the code example</span></div><div class="line"><span class="comment">   * in \ref begin_iterator() for details.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * This function will always return a vector of length &#39;len&#39; unless</span></div><div class="line"><span class="comment">   * at the end of the array, or if an error has occured.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \param len The number of elements to return</span></div><div class="line"><span class="comment">   * \returns The next collection of elements in the array. Returns less then</span></div><div class="line"><span class="comment">   * len elements on end of file or failure.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::vector&lt; std::vector&lt;flexible_type&gt; &gt; iterator_get_next(<span class="keywordtype">size_t</span> len) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Save the sframe to url in csv format.</span></div><div class="line"><span class="comment">   * To keep the interface stable, the CSV parsing configuration read from a</span></div><div class="line"><span class="comment">   * map of string-&gt;flexible_type called writing_config.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * The default writing configuration is the following:</span></div><div class="line"><span class="comment">   * \code</span></div><div class="line"><span class="comment">   * writer.delimiter = &quot;,&quot;;</span></div><div class="line"><span class="comment">   * writer.escape_char = &#39;\\&#39;;</span></div><div class="line"><span class="comment">   * writer.double_quote = true;</span></div><div class="line"><span class="comment">   * writer.quote_char = &#39;\&quot;&#39;;</span></div><div class="line"><span class="comment">   * writer.use_quote_char = true;</span></div><div class="line"><span class="comment">   * \endcode</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * For details on the meaning of each config see \ref csv_writer</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * The fields in parsing config are:</span></div><div class="line"><span class="comment">   *  - delimiter : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - escape_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - double_quote : True if not is zero()</span></div><div class="line"><span class="comment">   *  - quote_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   *  - use_quote_char : First character if flexible_type is a string</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">void</span> save_as_csv(<span class="keyword">const</span> std::string&amp; url,</div><div class="line">                   std::map&lt;std::string, flexible_type&gt; writing_config) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Randomly split the sframe into two parts, with ratio = percent, and  seed = random_seed.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Returns a list of size 2 of the unity_sframes resulting from the split.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::list&lt;std::shared_ptr&lt;unity_sframe_base&gt;&gt; random_split(<span class="keywordtype">float</span> percent, uint64_t random_seed, <span class="keywordtype">bool</span> exact=<span class="keyword">false</span>) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Randomly shuffles the sframe.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Returns a list of size 2 of the unity_sframes resulting from the split.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a4"></a><a class="code" href="group__sframe__main.html#ga6274ff53e5e6cdee836ea44e9524003a">shuffle</a>() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Sample the rows of sframe uniformly with ratio = percent, and seed = random_seed.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Returns unity_sframe* containing the sampled rows.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; sample(<span class="keywordtype">float</span> percent, uint64_t random_seed, <span class="keywordtype">bool</span> exact=<span class="keyword">false</span>) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * materialize the sframe, this is different from save() as this is a temporary persist of</span></div><div class="line"><span class="comment">   * all sarrays underneath the sframe to speed up some computation (for example, lambda)</span></div><div class="line"><span class="comment">   * this will NOT create a new uity_sframe.</span></div><div class="line"><span class="comment">  **/</span></div><div class="line">  <span class="keywordtype">void</span> materialize() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns whether or not this sframe is materialized</span></div><div class="line"><span class="comment">   **/</span></div><div class="line">  <span class="keywordtype">bool</span> is_materialized() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Return the query plan as a string representation of a dot graph.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::string query_plan_string() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Return true if the sframe size is known.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">bool</span> has_size() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns unity_sframe* where there is one row for each unique value of the</span></div><div class="line"><span class="comment">   * key_column.</span></div><div class="line"><span class="comment">   * group_operations is a collection of pairs of {column_name, operation_name}</span></div><div class="line"><span class="comment">   * where operation_name is a builtin operator.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a5"></a><a class="code" href="group__Algorithms.html#ga2be2c0cf706409ad52264ae255698e37">groupby_aggregate</a>(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; key_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; group_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; group_output_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; group_operations) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * \overload</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a class="code" href="group__Algorithms.html#ga2be2c0cf706409ad52264ae255698e37">groupby_aggregate</a>(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; key_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; group_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; group_output_columns,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;group_aggregate_value&gt;&gt;&amp; group_operations);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new SFrame which contains all rows combined from current SFrame and &quot;other&quot;</span></div><div class="line"><span class="comment">   * The &quot;other&quot; SFrame has to have the same number of columns with the same column names</span></div><div class="line"><span class="comment">   * and same column types as &quot;this&quot; SFrame</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; append(std::shared_ptr&lt;unity_sframe_base&gt; other) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">inline</span> std::shared_ptr&lt;unity_sframe_base&gt; join(std::shared_ptr&lt;unity_sframe_base &gt;right,</div><div class="line">                          <span class="keyword">const</span> std::string join_type,</div><div class="line">                          <span class="keyword">const</span> std::map&lt;std::string,std::string&gt;&amp; join_keys)<span class="keyword"> override</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> join_with_custom_name(right, join_type, join_keys, {}); }</div><div class="line"></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; join_with_custom_name(std::shared_ptr&lt;unity_sframe_base &gt;right,</div><div class="line">                          <span class="keyword">const</span> std::string join_type,</div><div class="line">                          <span class="keyword">const</span> std::map&lt;std::string,std::string&gt;&amp; join_keys,</div><div class="line">                          <span class="keyword">const</span> std::map&lt;std::string,std::string&gt;&amp; alternative_names) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a6"></a><a class="code" href="group__Algorithms.html#gabd5108f8e913f72a22cf8dedf9879e70">sort</a>(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; sort_keys,</div><div class="line">                          <span class="keyword">const</span> std::vector&lt;int&gt;&amp; sort_ascending) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">    * Pack a subset columns of current SFrame into one dictionary column, using</span></div><div class="line"><span class="comment">    * column name as key in the dictionary, and value of the column as value</span></div><div class="line"><span class="comment">    * in the dictionary, returns a new SFrame that includes other non-packed</span></div><div class="line"><span class="comment">    * columns plus the newly generated dict column.</span></div><div class="line"><span class="comment">    * Missing value in the original column will not show up in the packed</span></div><div class="line"><span class="comment">    * dictionary value.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    * \param pack_column_names : list of column names to pack</span></div><div class="line"><span class="comment">    * \param dict_key_names : dictionary key name to give to the packed dictionary</span></div><div class="line"><span class="comment">    * \param dtype: the result SArray type</span></div><div class="line"><span class="comment">      missing value is maintained, it could be filled with fill_na value is specified.</span></div><div class="line"><span class="comment">    * \param fill_na: the value to fill when missing value is encountered</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    * Returns a new SArray that contains the newly packed column</span></div><div class="line"><span class="comment">  **/</span></div><div class="line">  std::shared_ptr&lt;unity_sarray_base&gt; pack_columns(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; pack_column_names,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; dict_key_names,</div><div class="line">      <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> dtype,</div><div class="line">      <span class="keyword">const</span> flexible_type&amp; fill_na) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Convert a dictionary column of the SFrame to two columns with first column</span></div><div class="line"><span class="comment">   * as the key for the dictionary and second column as the value for the</span></div><div class="line"><span class="comment">   * dictionary. Returns a new SFrame with the two newly created columns, plus</span></div><div class="line"><span class="comment">   * all columns other than the stacked column. The values from those columns</span></div><div class="line"><span class="comment">   * are duplicated for all rows created from the same original row.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   * \param column_name: string</span></div><div class="line"><span class="comment">      The column to stack. The name must come from current SFrame and must be of dict type</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   * \param new_column_names: a list of str, optional</span></div><div class="line"><span class="comment">      Must be length of two. The two column names to stack the dict value to.</span></div><div class="line"><span class="comment">      If not given, the name is automatically generated.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   * \param new_column_types: a list of types, optional</span></div><div class="line"><span class="comment">      Must be length of two. The type for the newly created column. If not</span></div><div class="line"><span class="comment">      given, the default to [str, int].</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   * \param drop_na if true, missing values from dictionary will be ignored. If false,</span></div><div class="line"><span class="comment">      for missing dict value, one row will be created with the two new columns&#39; value</span></div><div class="line"><span class="comment">      being missing value</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   * Retruns a new unity_sframe with stacked columns</span></div><div class="line"><span class="comment">  **/</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; stack(</div><div class="line">      <span class="keyword">const</span> std::string&amp; column_name,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; new_column_names,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;flex_type_enum&gt;&amp; new_column_types,</div><div class="line">      <span class="keywordtype">bool</span> drop_na) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   /**</span></div><div class="line"><span class="comment">    * Extracts a range of rows from an SFrame as a new SFrame.</span></div><div class="line"><span class="comment">    * This will extract rows beginning at start (inclusive) and ending at</span></div><div class="line"><span class="comment">    * end(exclusive) in steps of &quot;step&quot;.</span></div><div class="line"><span class="comment">    * step must be at least 1.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">  std::shared_ptr&lt;unity_sframe_base&gt; <a name="a7"></a><a class="code" href="group__eager__algorithms.html#ga385afe1bdc7987d31b716bd117aec241">copy_range</a>(<span class="keywordtype">size_t</span> start, <span class="keywordtype">size_t</span> step, <span class="keywordtype">size_t</span> end) <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Returns a new SFrame with missing values dropped.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Missing values are only searched for in the columns specified in the</span></div><div class="line"><span class="comment">   * &#39;column_names&#39;.  If this vector is empty, all columns will be considered.</span></div><div class="line"><span class="comment">   * If &#39;all&#39; is true, a row is only dropped if all specified columns contain a</span></div><div class="line"><span class="comment">   * missing value.  If false, the row is dropped if any of the specified</span></div><div class="line"><span class="comment">   * columns contain a missing value.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * If &#39;split&#39; is true, this function returns two SFrames, the first being the</span></div><div class="line"><span class="comment">   * SFrame with missing values dropped, and the second consisting of all the</span></div><div class="line"><span class="comment">   * rows removed.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * If &#39;recursive&#39; is true, the `nan`element check will be perfromed in</span></div><div class="line"><span class="comment">   * a recursive manner to check each unit in a container-like flexible-typed</span></div><div class="line"><span class="comment">   * cell in SFrame.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Throws if the column names are not in this SFrame, or if too many are given.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::list&lt;std::shared_ptr&lt;unity_sframe_base&gt;&gt; drop_missing_values(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; column_names, <span class="keywordtype">bool</span> all, <span class="keywordtype">bool</span> <a name="a8"></a><a class="code" href="group__eager__algorithms.html#gad750d10d75a759cde25e098d0105271b">split</a>,</div><div class="line">      <span class="keywordtype">bool</span> recursive) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  dataframe_t to_dataframe() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> save(oarchive&amp; oarc) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> load(iarchive&amp; iarc) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> delete_on_close() <span class="keyword">override</span>;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Similar to logical filter, but return both positive and negative rows.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \param logical_filter_array is an sarray of the same size, and has only</span></div><div class="line"><span class="comment">   * zeros and ones as value.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Return a list of two sframes with all positive examples goes to the first</span></div><div class="line"><span class="comment">   * one and negative rows goes to the second one.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::list&lt;std::shared_ptr&lt;unity_sframe_base&gt;&gt; logical_filter_split(</div><div class="line">    std::shared_ptr&lt;unity_sarray_base&gt; logical_filter_array);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> explore(<span class="keyword">const</span> std::string&amp; path_to_client, <span class="keyword">const</span> std::string&amp; title) <span class="keyword">override</span>;</div><div class="line">  <span class="keywordtype">void</span> show(<span class="keyword">const</span> std::string&amp; path_to_client) <span class="keyword">override</span>;</div><div class="line">  std::shared_ptr&lt;model_base&gt; plot() <span class="keyword">override</span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:<span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Pointer to the lazy evaluator logical operator node.</span></div><div class="line"><span class="comment">   * Should never be NULL.  Must be set with the set_planner_node() function above.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::shared_ptr&lt;query_eval::planner_node&gt; m_planner_node;</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; m_column_names;</div><div class="line"></div><div class="line">  std::shared_ptr&lt;sframe&gt; m_cached_sframe;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Supports \ref begin_iterator() and \ref iterator_get_next().</span></div><div class="line"><span class="comment">   * The next segment I will read. (i.e. the current segment I am reading</span></div><div class="line"><span class="comment">   * is iterator_next_segment_id - 1)</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordtype">size_t</span> iterator_next_segment_id = 0;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * A copy of the current SFrame. This allows iteration, and other</span></div><div class="line"><span class="comment">   * SAarray operations to operate together safely in harmony without collisions.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::unique_ptr&lt;sframe_reader&gt; iterator_sframe_ptr;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Supports \ref begin_iterator() and \ref iterator_get_next().</span></div><div class="line"><span class="comment">   * The begin iterator of the current segment I am reading.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::unique_ptr&lt;sframe_iterator&gt; iterator_current_segment_iter;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Supports \ref begin_iterator() and \ref iterator_get_next().</span></div><div class="line"><span class="comment">   * The end iterator of the current segment I am reading.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::unique_ptr&lt;sframe_iterator&gt; iterator_current_segment_enditer;</div><div class="line"></div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Helper functions</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Convert column names to column indices.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * If input column_names is empty, return 0,1,2,...num_columns-1</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Throw if column_names has duplication, or some column name does not exist.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::vector&lt;size_t&gt; _convert_column_names_to_indices(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; column_names);</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /**</span></div><div class="line"><span class="comment">   * Generate a new column name</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * New column name is in the form of X1, X2, X3 ....</span></div><div class="line"><span class="comment">   * In case of conflict, add .1, .2 until conflict is resolved.</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * \example</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Given current sframe column names: a, b, c</span></div><div class="line"><span class="comment">   * Next 3 generated names are: X4, X5, X6</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * Given current sframe column names: X4, X5.1, X6.2</span></div><div class="line"><span class="comment">   * Next 3 generated names are: X4.1, X5, X6.1</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  std::string generate_next_column_name();</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
