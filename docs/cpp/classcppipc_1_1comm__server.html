<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: cppipc::comm_server Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcppipc_1_1comm__server.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcppipc_1_1comm__server-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cppipc::comm_server Class Reference<div class="ingroups"><a class="el" href="group__cppipc.html">C++ Interprocess Communication Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="comm__server_8hpp_source.html">core/system/cppipc/server/comm_server.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2ba5223e8d8f2c244ff720663f405b96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#a2ba5223e8d8f2c244ff720663f405b96">comm_server</a> (std::vector&lt; std::string &gt; zkhosts, std::string name, std::string alternate_bind_address=&quot;&quot;, std::string alternate_control_address=&quot;&quot;, std::string alternate_publish_address=&quot;&quot;, std::string secret_key=&quot;&quot;)</td></tr>
<tr class="separator:a2ba5223e8d8f2c244ff720663f405b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ae51b068359bd6159e58e1838f3677"><td class="memItemLeft" align="right" valign="top"><a id="ac3ae51b068359bd6159e58e1838f3677"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#ac3ae51b068359bd6159e58e1838f3677">~comm_server</a> ()</td></tr>
<tr class="memdesc:ac3ae51b068359bd6159e58e1838f3677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Stops receiving messages, and closes all communication. <br /></td></tr>
<tr class="separator:ac3ae51b068359bd6159e58e1838f3677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac985c8331158322cc392571623d24920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#ac985c8331158322cc392571623d24920">start</a> ()</td></tr>
<tr class="separator:ac985c8331158322cc392571623d24920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7dfed4c8d9804a0736335f45dbdcb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#a5a7dfed4c8d9804a0736335f45dbdcb5">stop</a> ()</td></tr>
<tr class="separator:a5a7dfed4c8d9804a0736335f45dbdcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9edee8fb957d999f246ea4774be776"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#afb9edee8fb957d999f246ea4774be776">get_bound_address</a> ()</td></tr>
<tr class="separator:afb9edee8fb957d999f246ea4774be776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab24ad302962b8f758a71072c83f08e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#a0ab24ad302962b8f758a71072c83f08e">get_control_address</a> ()</td></tr>
<tr class="separator:a0ab24ad302962b8f758a71072c83f08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77aae74d9c23307d0a8a2177d679166"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#ab77aae74d9c23307d0a8a2177d679166">get_status_address</a> ()</td></tr>
<tr class="separator:ab77aae74d9c23307d0a8a2177d679166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d81054b6270d535c2505b00fe769a1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#a24d81054b6270d535c2505b00fe769a1">get_zmq_context</a> ()</td></tr>
<tr class="separator:a24d81054b6270d535c2505b00fe769a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54310206d8969978a4598bed6f358a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#ae54310206d8969978a4598bed6f358a2">report_status</a> (std::string status_type, std::string message)</td></tr>
<tr class="separator:ae54310206d8969978a4598bed6f358a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164a742903cf58605d0de878d65fac6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#a164a742903cf58605d0de878d65fac6a">delete_object</a> (size_t objectid)</td></tr>
<tr class="separator:a164a742903cf58605d0de878d65fac6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a4b406f8b0061a14e00634228ee8bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1a4b406f8b0061a14e00634228ee8bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#ae1a4b406f8b0061a14e00634228ee8bd">register_type</a> (std::function&lt; T *()&gt; constructor_call)</td></tr>
<tr class="separator:ae1a4b406f8b0061a14e00634228ee8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d01a043ac85e55ffe9258c81c515134"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d01a043ac85e55ffe9258c81c515134"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#a1d01a043ac85e55ffe9258c81c515134">register_type</a> (std::function&lt; std::shared_ptr&lt; T &gt;()&gt; constructor_call)</td></tr>
<tr class="separator:a1d01a043ac85e55ffe9258c81c515134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2839149d3b5e4dfd5c97d5057e0bca55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2839149d3b5e4dfd5c97d5057e0bca55"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#a2839149d3b5e4dfd5c97d5057e0bca55">register_object</a> (std::shared_ptr&lt; T &gt; object)</td></tr>
<tr class="separator:a2839149d3b5e4dfd5c97d5057e0bca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155636be73e300baf6b7504a1abdcd9c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#a155636be73e300baf6b7504a1abdcd9c">find_object</a> (void *object)</td></tr>
<tr class="separator:a155636be73e300baf6b7504a1abdcd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbfe68a6cbd463be3503c00d40e68d2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#acbbfe68a6cbd463be3503c00d40e68d2">get_object</a> (size_t objectid)</td></tr>
<tr class="separator:acbbfe68a6cbd463be3503c00d40e68d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e36787f5bad085ec55f58d8a482998b"><td class="memTemplParams" colspan="2">template&lt;typename MemFn &gt; </td></tr>
<tr class="memitem:a7e36787f5bad085ec55f58d8a482998b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__server.html#a7e36787f5bad085ec55f58d8a482998b">register_function</a> (MemFn fn, std::string function_name)</td></tr>
<tr class="separator:a7e36787f5bad085ec55f58d8a482998b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a> manages the server side of the communication interface.</p>
<p>The <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a> manages the serving of objects. It listens on a bind address (defaults to an arbitrary TCP port, but an alternate_bind_address can be provided), and registers its existance in zookeeper. Clients can reach the server by associating with the same keys in zookeeper.</p>
<p>The <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a> manages a list of member function pointers and strings they map to, as well as a complete list of all served objects.</p>
<h2>Basic Utilization </h2>
<p>To create a object which can be served by remote machines, first create a base interface class which describes the functions to be exported using the registration macros <a class="el" href="group__cppipc.html#gab991ba71aa82c1aa330ae2054ea41baf">REGISTRATION_BEGIN</a> REGISTRATION_END REGISTER, or the magic macros <a class="el" href="group__cppipc.html#ga50d62f9a4f9340aa882c1a9a941796c9">GENERATE_INTERFACE</a> and <a class="el" href="group__cppipc.html#ga838dae619459dce33202c1e28ecc2966">GENERATE_INTERFACE_AND_PROXY</a>. The actual server side implementation of the object then inherits from this interface, implementing all the functions.</p>
<p>For instance, I may have a base interface class called "file_write_base", and an implementation called "file_write_impl".</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>file_write_base {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">int</span> open(std::string s) = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(std::string s) = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> close() = 0;</div><div class="line">  <span class="keyword">virtual</span> ~file_write_base() {}</div><div class="line"></div><div class="line">  <a class="code" href="group__cppipc.html#gab991ba71aa82c1aa330ae2054ea41baf">REGISTRATION_BEGIN</a>(file_write_base)</div><div class="line">  REGISTER(file_write_base::open)</div><div class="line">  REGISTER(file_write_base::write)</div><div class="line">  REGISTER(file_write_base::close)</div><div class="line">  REGISTRATION_END</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>file_write_impl: <span class="keyword">public</span> file_write_base {</div><div class="line">  file_write_impl(); <span class="comment">// regular constructor</span></div><div class="line"></div><div class="line">  <span class="keyword">explicit</span> file_write_impl(std::string f) {  <span class="comment">// open a file on construction</span></div><div class="line">    open(f);</div><div class="line">  }</div><div class="line">  <span class="comment">// ... other implementation details omitted ...</span></div><div class="line">};</div></div><!-- fragment --><p>To make this class available on the server side, we must tell the server how to construct an instance of this object by registering a type with the server, and providing a lambda function returning a pointer to an implementation. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  ...</div><div class="line">  <a class="code" href="classcppipc_1_1comm__server.html#a2ba5223e8d8f2c244ff720663f405b96">comm_server</a> server(...);</div><div class="line">  server.register_type&lt;file_write_base&gt;([](){ <span class="keywordflow">return</span> <span class="keyword">new</span> file_write_impl;});</div><div class="line">  ...</div><div class="line">  server.start();</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> Here we use the trivial constructor, but more generally we can provide arbitrarily interesting constructors in the lambda. For instance, here we use the alternate constructor in file_write_impl. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  ...</div><div class="line">  <a class="code" href="classcppipc_1_1comm__server.html#a2ba5223e8d8f2c244ff720663f405b96">comm_server</a> server(...);</div><div class="line">  server.register_type&lt;file_write_base&gt;([](){ <span class="keywordflow">return</span> <span class="keyword">new</span> file_write_impl(<span class="stringliteral">&quot;log.txt&quot;</span>);});</div><div class="line">  ...</div><div class="line">  server.start();</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>Once the server is started, the client will have the ability to create proxy objects which in turn create matching objects on the server.</p>
<p>It is important that each base class only describes exactly one implementation. i.e. register_type&lt;T&gt; should be used only once for any T.</p>
<p>To see how this code is used, see the <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a> documentation.</p>
<h2>Implementation Details </h2>
<p>There is a special "root object" which manages all "special" tasks that operate on the <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a> itself. This root object always has object ID 0 and is the <a class="el" href="classcppipc_1_1object__factory__base.html">object_factory_base</a>. This is implemented on the server side by <a class="el" href="classcppipc_1_1object__factory__impl.html">object_factory_impl</a>, and on the client side as <a class="el" href="classcppipc_1_1object__factory__proxy.html">object_factory_proxy</a>.</p>
<p>The <a class="el" href="classcppipc_1_1object__factory__impl.html">object_factory_impl</a> manages the construction of new object types.</p>
<h2>Interface Modification Safety </h2>
<p>The internal protocol is designed to be robust against changes in interfaces. i.e. if new functions are added, and the server is recompiled, all previous client builds will still work. Similarly, if new functions are added and the client is recompiled, the new client will still work with old servers as long as the new functions are not called. </p>

<p class="definition">Definition at line <a class="el" href="comm__server_8hpp_source.html#l00144">144</a> of file <a class="el" href="comm__server_8hpp_source.html">comm_server.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2ba5223e8d8f2c244ff720663f405b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba5223e8d8f2c244ff720663f405b96">&#9670;&nbsp;</a></span>comm_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cppipc::comm_server::comm_server </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>zkhosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>alternate_bind_address</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>alternate_control_address</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>alternate_publish_address</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>secret_key</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a comm server which uses remote communication via zookeeper/zeromq. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zkhosts</td><td>The zookeeper hosts to connect to. May be empty. If empty, the "alternate_bind_address" parameter must be a zeromq endpoint address to bind to. </td></tr>
    <tr><td class="paramname">name</td><td>The key name to wait for connections on. All remotes connect to this server on this name. If zkhosts is empty, this is ignored. </td></tr>
    <tr><td class="paramname">alternate_bind_address</td><td>The communication defaults to using an arbitrary TCP port. This can be changed to any URI format supported by zeroMQ. </td></tr>
    <tr><td class="paramname">alternate_publish_address</td><td>Only valid if zkhosts is empty. The address to publish server statuses on. If zookeeper is not used, all remotes should connect to this address to get server status. If not provided, one is generated automatically. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a164a742903cf58605d0de878d65fac6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164a742903cf58605d0de878d65fac6a">&#9670;&nbsp;</a></span>delete_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_server::delete_object </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>objectid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes an object of object ID objectid. </p>

<p class="definition">Definition at line <a class="el" href="comm__server_8hpp_source.html#l00293">293</a> of file <a class="el" href="comm__server_8hpp_source.html">comm_server.hpp</a>.</p>

</div>
</div>
<a id="a155636be73e300baf6b7504a1abdcd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155636be73e300baf6b7504a1abdcd9c">&#9670;&nbsp;</a></span>find_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cppipc::comm_server::find_object </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an object ID of the object has been previously registere.d Returns (size_t)(-1) otherwise. </p>

<p class="definition">Definition at line <a class="el" href="comm__server_8hpp_source.html#l00362">362</a> of file <a class="el" href="comm__server_8hpp_source.html">comm_server.hpp</a>.</p>

</div>
</div>
<a id="afb9edee8fb957d999f246ea4774be776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9edee8fb957d999f246ea4774be776">&#9670;&nbsp;</a></span>get_bound_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cppipc::comm_server::get_bound_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the address we are bound on </p>

</div>
</div>
<a id="a0ab24ad302962b8f758a71072c83f08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab24ad302962b8f758a71072c83f08e">&#9670;&nbsp;</a></span>get_control_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cppipc::comm_server::get_control_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the address where we receive control messages </p>

</div>
</div>
<a id="acbbfe68a6cbd463be3503c00d40e68d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbfe68a6cbd463be3503c00d40e68d2">&#9670;&nbsp;</a></span>get_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;void&gt; cppipc::comm_server::get_object </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>objectid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the object with a given object ID. Returns NULL on failure. </p>

<p class="definition">Definition at line <a class="el" href="comm__server_8hpp_source.html#l00375">375</a> of file <a class="el" href="comm__server_8hpp_source.html">comm_server.hpp</a>.</p>

</div>
</div>
<a id="ab77aae74d9c23307d0a8a2177d679166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77aae74d9c23307d0a8a2177d679166">&#9670;&nbsp;</a></span>get_status_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cppipc::comm_server::get_status_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the address on which you can subscribe to for status updates. </p>

</div>
</div>
<a id="a24d81054b6270d535c2505b00fe769a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d81054b6270d535c2505b00fe769a1">&#9670;&nbsp;</a></span>get_zmq_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* cppipc::comm_server::get_zmq_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the zeromq context.. Deprecated. Returns NULL. </p>

</div>
</div>
<a id="a7e36787f5bad085ec55f58d8a482998b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e36787f5bad085ec55f58d8a482998b">&#9670;&nbsp;</a></span>register_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_server::register_function </td>
          <td>(</td>
          <td class="paramtype">MemFn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>function_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a member function pointer. Do not use directly. Used by the REGISTER macros to allow the <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a> to maintain the mapping of member function pointers to names. </p>

<p class="definition">Definition at line <a class="el" href="comm__server_8hpp_source.html#l00408">408</a> of file <a class="el" href="comm__server_8hpp_source.html">comm_server.hpp</a>.</p>

</div>
</div>
<a id="a2839149d3b5e4dfd5c97d5057e0bca55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2839149d3b5e4dfd5c97d5057e0bca55">&#9670;&nbsp;</a></span>register_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cppipc::comm_server::register_object </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers an object to be managed by the comm server, returning the new object ID. If the object already exists, the existing ID is returned. </p>

<p class="definition">Definition at line <a class="el" href="comm__server_8hpp_source.html#l00346">346</a> of file <a class="el" href="comm__server_8hpp_source.html">comm_server.hpp</a>.</p>

</div>
</div>
<a id="ae1a4b406f8b0061a14e00634228ee8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a4b406f8b0061a14e00634228ee8bd">&#9670;&nbsp;</a></span>register_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_server::register_type </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; T *()&gt;&#160;</td>
          <td class="paramname"><em>constructor_call</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers a type to be managed by the <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a>. After registration of this type, remote machines will be able to create instances of this object via the <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a>'s make_object function call. </p>

<p class="definition">Definition at line <a class="el" href="comm__server_8hpp_source.html#l00314">314</a> of file <a class="el" href="comm__server_8hpp_source.html">comm_server.hpp</a>.</p>

</div>
</div>
<a id="a1d01a043ac85e55ffe9258c81c515134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d01a043ac85e55ffe9258c81c515134">&#9670;&nbsp;</a></span>register_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_server::register_type </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; std::shared_ptr&lt; T &gt;()&gt;&#160;</td>
          <td class="paramname"><em>constructor_call</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers a type to be managed by the <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a>. After registration of this type, remote machines will be able to create instances of this object via the <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a>'s make_object function call. </p>

<p class="definition">Definition at line <a class="el" href="comm__server_8hpp_source.html#l00330">330</a> of file <a class="el" href="comm__server_8hpp_source.html">comm_server.hpp</a>.</p>

</div>
</div>
<a id="ae54310206d8969978a4598bed6f358a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54310206d8969978a4598bed6f358a2">&#9670;&nbsp;</a></span>report_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_server::report_status </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>status_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Publishes a message of the form "[status_type]: [message]". Since the client can filter messages, it is important to have a small set of possible status_type strings. For the purposes of the <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a>, we define the following:</p>
<ul>
<li><b>COMM_SERVER_INFO</b> Used for Comm Server informational messages. </li>
<li><b>COMM_SERVER_ERROR</b> Used for Comm Server error messages.</li>
</ul>
<p>These status strings are defined in <a class="el" href="status__types_8hpp_source.html">core/system/cppipc/common/status_types.hpp</a> </p>

</div>
</div>
<a id="ac985c8331158322cc392571623d24920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac985c8331158322cc392571623d24920">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_server::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start receiving messages. Message processing occurs on a seperate thread, so this function returns immediately.. </p>

</div>
</div>
<a id="a5a7dfed4c8d9804a0736335f45dbdcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7dfed4c8d9804a0736335f45dbdcb5">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_server::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops receiving messages. Has no effect if <a class="el" href="classcppipc_1_1comm__server.html#ac985c8331158322cc392571623d24920">start()</a> was not called before this. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/system/cppipc/server/<a class="el" href="comm__server_8hpp_source.html">comm_server.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecppipc.html">cppipc</a></li><li class="navelem"><a class="el" href="classcppipc_1_1comm__server.html">comm_server</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
