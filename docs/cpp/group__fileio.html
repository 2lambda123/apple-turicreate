<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: File IO Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__fileio.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">File IO Library</div>  </div>
</div><!--header-->
<div class="contents">

<p>The fileio library provides a collection of generic libraries to unify access to HDFS, S3, local filesystem and in-memory filesystem.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html">turi::block_cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1buffered__writer.html">turi::buffered_writer&lt; ValueType, OutIterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1file__download__cache.html">turi::file_download_cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fileio_1_1file__handle__pool.html">turi::fileio::file_handle_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1fileio_1_1file__ownership__handle.html">turi::fileio::file_ownership_handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1fileio_1_1cache__block.html">turi::fileio::cache_block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fileio_1_1fixed__size__cache__manager.html">turi::fileio::fixed_size_cache_manager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1general__ifstream.html">turi::general_ifstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1general__ofstream.html">turi::general_ofstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fileio__impl_1_1general__fstream__sink.html">turi::fileio_impl::general_fstream_sink</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fileio__impl_1_1general__fstream__source.html">turi::fileio_impl::general_fstream_source</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1read__caching__device.html">turi::read_caching_device&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1s3url.html">turi::s3url</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1list__objects__response.html">turi::list_objects_response</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1s3__device.html">turi::s3_device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1union__fstream.html">turi::union_fstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae07098a1b91a5cf1f1d4bf72a410f96a"><td class="memItemLeft" align="right" valign="top">typedef boost::iostreams::stream&lt; <a class="el" href="classturi_1_1fileio__impl_1_1cache__stream__source.html">turi::fileio_impl::cache_stream_source</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gae07098a1b91a5cf1f1d4bf72a410f96a">turi::fileio::icache_stream</a></td></tr>
<tr class="separator:gae07098a1b91a5cf1f1d4bf72a410f96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2414a84c32d256d687301887af1cec"><td class="memItemLeft" align="right" valign="top">typedef boost::iostreams::stream&lt; <a class="el" href="classturi_1_1fileio__impl_1_1cache__stream__sink.html">turi::fileio_impl::cache_stream_sink</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gafb2414a84c32d256d687301887af1cec">turi::fileio::ocache_stream</a></td></tr>
<tr class="separator:gafb2414a84c32d256d687301887af1cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga76f0038f6e87bbd52aea670fbd88b2ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">turi::fileio::file_status</a> </td></tr>
<tr class="separator:ga76f0038f6e87bbd52aea670fbd88b2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga50858708e6b493a8725bbb40d992bff4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga50858708e6b493a8725bbb40d992bff4">turi::download_url</a> (std::string url, std::string output_file)</td></tr>
<tr class="separator:ga50858708e6b493a8725bbb40d992bff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae775e307f6819797b5508a362f3a7853"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; int, bool, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gae775e307f6819797b5508a362f3a7853">turi::download_url</a> (std::string url)</td></tr>
<tr class="separator:gae775e307f6819797b5508a362f3a7853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca7c12d648fa93188a1a70aed114425"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga2ca7c12d648fa93188a1a70aed114425">turi::fileio::get_system_temp_directory</a> ()</td></tr>
<tr class="separator:ga2ca7c12d648fa93188a1a70aed114425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373df97b4d1e0d066770c95270ce979f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga373df97b4d1e0d066770c95270ce979f">turi::fileio::get_cache_prefix</a> ()</td></tr>
<tr class="separator:ga373df97b4d1e0d066770c95270ce979f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c2ea815f13df6e379bf8c5d11cbfe5d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga6c2ea815f13df6e379bf8c5d11cbfe5d">turi::fileio::get_temp_cache_prefix</a> ()</td></tr>
<tr class="separator:ga6c2ea815f13df6e379bf8c5d11cbfe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8629e24be29411f7996b62096606e0c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gad8629e24be29411f7996b62096606e0c">turi::fileio::get_cache_file_locations</a> ()</td></tr>
<tr class="separator:gad8629e24be29411f7996b62096606e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050cea055c4ab69186ada70d0ec37d3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga050cea055c4ab69186ada70d0ec37d3a">turi::fileio::set_cache_file_locations</a> (std::string)</td></tr>
<tr class="separator:ga050cea055c4ab69186ada70d0ec37d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65f0985583f3050646e0d96370c69115"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga65f0985583f3050646e0d96370c69115">turi::fileio::get_cache_file_hdfs_location</a> ()</td></tr>
<tr class="separator:ga65f0985583f3050646e0d96370c69115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad985e22fd77cbb6089449feab9c6582d"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gad985e22fd77cbb6089449feab9c6582d">turi::fileio::get_alternative_ssl_cert_dir</a> ()</td></tr>
<tr class="separator:gad985e22fd77cbb6089449feab9c6582d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0acaf4bacb1703c8c2064132a9588258"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga0acaf4bacb1703c8c2064132a9588258">turi::fileio::get_alternative_ssl_cert_file</a> ()</td></tr>
<tr class="separator:ga0acaf4bacb1703c8c2064132a9588258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd816d0bb628e05ad9e3387a29bf5809"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gacd816d0bb628e05ad9e3387a29bf5809">turi::fileio::insecure_ssl_cert_checks</a> ()</td></tr>
<tr class="separator:gacd816d0bb628e05ad9e3387a29bf5809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2df6422a38ad7fdcb6e8949ecb00b17"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">file_status</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gaf2df6422a38ad7fdcb6e8949ecb00b17">turi::fileio::get_file_status</a> (const std::string &amp;path)</td></tr>
<tr class="separator:gaf2df6422a38ad7fdcb6e8949ecb00b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125e90d8c636d5c4e70d25437f97682c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, <a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">file_status</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga125e90d8c636d5c4e70d25437f97682c">turi::fileio::get_directory_listing</a> (const std::string &amp;path)</td></tr>
<tr class="separator:ga125e90d8c636d5c4e70d25437f97682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cf2e34ad8bc7b04c7de6bd884723a9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga6cf2e34ad8bc7b04c7de6bd884723a9a">turi::fileio::create_directory</a> (const std::string &amp;path)</td></tr>
<tr class="separator:ga6cf2e34ad8bc7b04c7de6bd884723a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7139bfea7da07df0f809b884054a24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga2e7139bfea7da07df0f809b884054a24">turi::fileio::create_directory_or_throw</a> (const std::string &amp;path)</td></tr>
<tr class="separator:ga2e7139bfea7da07df0f809b884054a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4bb5cc16050dc9ffc8079c3a9a98719"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gac4bb5cc16050dc9ffc8079c3a9a98719">turi::fileio::delete_path</a> (const std::string &amp;path, <a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">file_status</a> status=file_status::FS_UNAVAILABLE)</td></tr>
<tr class="separator:gac4bb5cc16050dc9ffc8079c3a9a98719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4d89c81cc33ca602ae95fa9e10988c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga3c4d89c81cc33ca602ae95fa9e10988c">turi::fileio::delete_path_impl</a> (const std::string &amp;path, <a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">file_status</a> status=file_status::FS_UNAVAILABLE)</td></tr>
<tr class="separator:ga3c4d89c81cc33ca602ae95fa9e10988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038d2ab164bdef44757594936b867cfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga038d2ab164bdef44757594936b867cfa">turi::fileio::delete_path_recursive</a> (const std::string &amp;path)</td></tr>
<tr class="separator:ga038d2ab164bdef44757594936b867cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5960b295c95ba0e4db8ddecf2438f924"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::string, std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga5960b295c95ba0e4db8ddecf2438f924">turi::fileio::parse_hdfs_url</a> (std::string url)</td></tr>
<tr class="separator:ga5960b295c95ba0e4db8ddecf2438f924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7d84a46df11a91b15a027e88bc8f8e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga9a7d84a46df11a91b15a027e88bc8f8e">turi::fileio::remove_protocol</a> (std::string path)</td></tr>
<tr class="separator:ga9a7d84a46df11a91b15a027e88bc8f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e80ce4936ba924ae5893d278ef8160"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga08e80ce4936ba924ae5893d278ef8160">turi::fileio::get_filename</a> (std::string path)</td></tr>
<tr class="separator:ga08e80ce4936ba924ae5893d278ef8160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73216d9bc71edc25956b166fa488e930"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga73216d9bc71edc25956b166fa488e930">turi::fileio::get_dirname</a> (std::string path)</td></tr>
<tr class="separator:ga73216d9bc71edc25956b166fa488e930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d6d5ac854435c9148befb7b47d7d32a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga6d6d5ac854435c9148befb7b47d7d32a">turi::fileio::convert_to_generic</a> (const std::string &amp;path)</td></tr>
<tr class="separator:ga6d6d5ac854435c9148befb7b47d7d32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga369eff0d3577d8e5fdfc30e5b32b0593"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga369eff0d3577d8e5fdfc30e5b32b0593">turi::fileio::make_relative_path</a> (std::string root_directory, std::string path)</td></tr>
<tr class="separator:ga369eff0d3577d8e5fdfc30e5b32b0593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71342aad2af5ea34fa8570899f610963"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga71342aad2af5ea34fa8570899f610963">turi::fileio::make_absolute_path</a> (std::string root_directory, std::string path)</td></tr>
<tr class="separator:ga71342aad2af5ea34fa8570899f610963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a81f87a433cf558ae08b02914327fa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, <a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">file_status</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga20a81f87a433cf558ae08b02914327fa">turi::fileio::get_glob_files</a> (const std::string &amp;url)</td></tr>
<tr class="separator:ga20a81f87a433cf558ae08b02914327fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace35fc0e0221b6c2b2c3bc20556a9579"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gace35fc0e0221b6c2b2c3bc20556a9579">turi::fileio::get_io_parallelism_id</a> (const std::string url)</td></tr>
<tr class="separator:gace35fc0e0221b6c2b2c3bc20556a9579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2502bb41442f0982b097b9f77e46c2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gab2502bb41442f0982b097b9f77e46c2a">turi::fileio::try_to_open_file</a> (const std::string url)</td></tr>
<tr class="separator:gab2502bb41442f0982b097b9f77e46c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0613ccc198cd71f5616fb61cdaa1ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gad0613ccc198cd71f5616fb61cdaa1ce6">turi::fileio::copy</a> (const std::string src, const std::string dest)</td></tr>
<tr class="separator:gad0613ccc198cd71f5616fb61cdaa1ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc23eb5f702006ea84508c4501e99c18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gadc23eb5f702006ea84508c4501e99c18">turi::fileio::change_file_mode</a> (const std::string path, short mode)</td></tr>
<tr class="separator:gadc23eb5f702006ea84508c4501e99c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad57c9c33c024ee5b4a5c4a4626db4138"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gad57c9c33c024ee5b4a5c4a4626db4138">turi::fileio::make_canonical_path</a> (const std::string &amp;path)</td></tr>
<tr class="separator:gad57c9c33c024ee5b4a5c4a4626db4138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa81576e130480bf0ef09e20896a1ab7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gafa81576e130480bf0ef09e20896a1ab7">turi::fileio::get_s3_endpoints</a> ()</td></tr>
<tr class="separator:gafa81576e130480bf0ef09e20896a1ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea68b924ea1ef006293970e563861c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga0ea68b924ea1ef006293970e563861c0">turi::fileio::get_region_name_from_endpoint</a> (std::string endpoint)</td></tr>
<tr class="separator:ga0ea68b924ea1ef006293970e563861c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec38e6c51a583c14f6f1a3fa93afda9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga3ec38e6c51a583c14f6f1a3fa93afda9">turi::fileio::get_bucket_path</a> (const std::string &amp;bucket)</td></tr>
<tr class="separator:ga3ec38e6c51a583c14f6f1a3fa93afda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff7eac62175d5e5bac69a32ba1fee75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga5ff7eac62175d5e5bac69a32ba1fee75">turi::get_s3_file_last_modified</a> (const std::string &amp;url)</td></tr>
<tr class="separator:ga5ff7eac62175d5e5bac69a32ba1fee75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d061c799a90c5c6a03728ef3de03d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1list__objects__response.html">list_objects_response</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga5d061c799a90c5c6a03728ef3de03d07">turi::list_objects</a> (std::string s3_url, std::string proxy=&quot;&quot;)</td></tr>
<tr class="separator:ga5d061c799a90c5c6a03728ef3de03d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga234867c61a56b4fa2622e0f672084360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1list__objects__response.html">list_objects_response</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga234867c61a56b4fa2622e0f672084360">turi::list_directory</a> (std::string s3_url, std::string proxy=&quot;&quot;)</td></tr>
<tr class="separator:ga234867c61a56b4fa2622e0f672084360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b22e913c89f6de93fbbd479c4dbbe9c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga4b22e913c89f6de93fbbd479c4dbbe9c">turi::delete_object</a> (std::string s3_url, std::string proxy=&quot;&quot;)</td></tr>
<tr class="separator:ga4b22e913c89f6de93fbbd479c4dbbe9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga717b2264a5a6bb05f6c2435b9cb4e7cc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga717b2264a5a6bb05f6c2435b9cb4e7cc">turi::delete_prefix</a> (std::string s3_url, std::string proxy=&quot;&quot;)</td></tr>
<tr class="separator:ga717b2264a5a6bb05f6c2435b9cb4e7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814071ebbbb49a2ba27bace0540a09db"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga814071ebbbb49a2ba27bace0540a09db">turi::sanitize_s3_url</a> (const std::string &amp;url)</td></tr>
<tr class="separator:ga814071ebbbb49a2ba27bace0540a09db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f462276b68dd6b4dfec9a8a0e5213c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gaf1f462276b68dd6b4dfec9a8a0e5213c">turi::parse_s3url</a> (std::string url, <a class="el" href="structturi_1_1s3url.html">s3url</a> &amp;ret, std::string &amp;err_msg)</td></tr>
<tr class="separator:gaf1f462276b68dd6b4dfec9a8a0e5213c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a3799347c103129ae70805e0161a6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga5a3799347c103129ae70805e0161a6ff">turi::set_upload_timeout</a> (long timeout)</td></tr>
<tr class="separator:ga5a3799347c103129ae70805e0161a6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c38590a0ad13fa63e4d25a366b653a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga2c38590a0ad13fa63e4d25a366b653a3">turi::set_download_timeout</a> (long timeout)</td></tr>
<tr class="separator:ga2c38590a0ad13fa63e4d25a366b653a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabade0bf49f31a40150a079328ebc507b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gabade0bf49f31a40150a079328ebc507b">turi::get_s3_error_code</a> (const std::string &amp;msg)</td></tr>
<tr class="separator:gabade0bf49f31a40150a079328ebc507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77744d8898a95679d4f8c399767728b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga77744d8898a95679d4f8c399767728b0">turi::sanitize_url</a> (std::string url)</td></tr>
<tr class="separator:ga77744d8898a95679d4f8c399767728b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65434d49942dcd935311a42566321853"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga65434d49942dcd935311a42566321853">turi::fileio::set_curl_options</a> (void *ecurl)</td></tr>
<tr class="separator:ga65434d49942dcd935311a42566321853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a39d09df58879b880f0ba2102ec047f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga6a39d09df58879b880f0ba2102ec047f">turi::get_system_user_name</a> ()</td></tr>
<tr class="separator:ga6a39d09df58879b880f0ba2102ec047f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a7014c73f094ce56bb700d684fd08d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga49a7014c73f094ce56bb700d684fd08d">turi::get_temp_name</a> (const std::string &amp;prefix=&quot;&quot;, bool _prefer_hdfs=false)</td></tr>
<tr class="separator:ga49a7014c73f094ce56bb700d684fd08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bea12507112de131eebd578bccfcb89"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga8bea12507112de131eebd578bccfcb89">turi::get_temp_name_prefer_hdfs</a> (const std::string &amp;prefix=&quot;&quot;)</td></tr>
<tr class="separator:ga8bea12507112de131eebd578bccfcb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga843b3c39ee4383fdbe606debcf5273c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga843b3c39ee4383fdbe606debcf5273c7">turi::delete_temp_file</a> (std::string s)</td></tr>
<tr class="separator:ga843b3c39ee4383fdbe606debcf5273c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a38eeb40011aa24012d90a46e53689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga97a38eeb40011aa24012d90a46e53689">turi::delete_temp_files</a> (std::vector&lt; std::string &gt; files)</td></tr>
<tr class="separator:ga97a38eeb40011aa24012d90a46e53689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc7f2e18c38aae6132d2da2b50a08d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gaadc7f2e18c38aae6132d2da2b50a08d8">turi::reap_unused_temp_files</a> ()</td></tr>
<tr class="separator:gaadc7f2e18c38aae6132d2da2b50a08d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9148e7456c812a233d184699e377c959"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga9148e7456c812a233d184699e377c959">turi::reap_current_process_temp_files</a> ()</td></tr>
<tr class="separator:ga9148e7456c812a233d184699e377c959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga904c193b58d4fefe5737c11a8bd2f961"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga904c193b58d4fefe5737c11a8bd2f961">turi::get_temp_directories</a> ()</td></tr>
<tr class="separator:ga904c193b58d4fefe5737c11a8bd2f961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938d93ca534d16a0946cba20516890f7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga938d93ca534d16a0946cba20516890f7">turi::num_temp_directories</a> ()</td></tr>
<tr class="separator:ga938d93ca534d16a0946cba20516890f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gafc09f445f1d03adfe77768722a423730"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gafc09f445f1d03adfe77768722a423730">turi::fileio::FILEIO_INITIAL_CAPACITY_PER_FILE</a></td></tr>
<tr class="separator:gafc09f445f1d03adfe77768722a423730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7788837045c8685fea964bfb62565d37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga7788837045c8685fea964bfb62565d37">turi::fileio::FILEIO_MAXIMUM_CACHE_CAPACITY_PER_FILE</a></td></tr>
<tr class="separator:ga7788837045c8685fea964bfb62565d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e2b97f180c904aca56ed113b5cee9a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga72e2b97f180c904aca56ed113b5cee9a">turi::fileio::FILEIO_MAXIMUM_CACHE_CAPACITY</a></td></tr>
<tr class="separator:ga72e2b97f180c904aca56ed113b5cee9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0389579b7266afb2e8026ebec9d018e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gaa0389579b7266afb2e8026ebec9d018e">turi::fileio::FILEIO_READER_BUFFER_SIZE</a></td></tr>
<tr class="separator:gaa0389579b7266afb2e8026ebec9d018e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb2701d37c920ce6c02cc1d186e4818"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga7bb2701d37c920ce6c02cc1d186e4818">turi::fileio::FILEIO_WRITER_BUFFER_SIZE</a></td></tr>
<tr class="separator:ga7bb2701d37c920ce6c02cc1d186e4818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112295e21cd70e9787d31753c40e6c53"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga112295e21cd70e9787d31753c40e6c53">turi::fileio::S3_ENDPOINT</a></td></tr>
<tr class="separator:ga112295e21cd70e9787d31753c40e6c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f5fd91811967243ce77a229ccb7c944"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga6f5fd91811967243ce77a229ccb7c944">turi::fileio::S3_REGION</a></td></tr>
<tr class="separator:ga6f5fd91811967243ce77a229ccb7c944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30c6f7618937944a323b6a79c39bb207"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga30c6f7618937944a323b6a79c39bb207">turi::fileio::NUM_GPUS</a></td></tr>
<tr class="separator:ga30c6f7618937944a323b6a79c39bb207"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The fileio library provides a collection of generic libraries to unify access to HDFS, S3, local filesystem and in-memory filesystem. </p>
<p>The two key objects everybody should care about is <a class="el" href="classturi_1_1general__ifstream.html">turi::general_ifstream</a> and <a class="el" href="classturi_1_1general__ofstream.html">turi::general_ofstream</a>. Almost everything else is implementation detail. boost::stream is used liberally to provide compatibility.</p>
<p>Generally, </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gae07098a1b91a5cf1f1d4bf72a410f96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae07098a1b91a5cf1f1d4bf72a410f96a">&#9670;&nbsp;</a></span>icache_stream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::iostreams::stream&lt;<a class="el" href="classturi_1_1fileio__impl_1_1cache__stream__source.html">turi::fileio_impl::cache_stream_source</a>&gt; <a class="el" href="group__fileio.html#gae07098a1b91a5cf1f1d4bf72a410f96a">turi::fileio::icache_stream</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>icache_stream provides an input stream to a cache object; this should not be used directly. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1general__ifstream.html">general_ifstream</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="cache__stream_8hpp_source.html#l00022">22</a> of file <a class="el" href="cache__stream_8hpp_source.html">cache_stream.hpp</a>.</p>

</div>
</div>
<a id="gafb2414a84c32d256d687301887af1cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb2414a84c32d256d687301887af1cec">&#9670;&nbsp;</a></span>ocache_stream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::iostreams::stream&lt;<a class="el" href="classturi_1_1fileio__impl_1_1cache__stream__sink.html">turi::fileio_impl::cache_stream_sink</a>&gt; <a class="el" href="group__fileio.html#gafb2414a84c32d256d687301887af1cec">turi::fileio::ocache_stream</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ocache_stream provides an output stream to a cache object; this should not be used directly. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1general__ofstream.html">general_ofstream</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="cache__stream_8hpp_source.html#l00032">32</a> of file <a class="el" href="cache__stream_8hpp_source.html">cache_stream.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga76f0038f6e87bbd52aea670fbd88b2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76f0038f6e87bbd52aea670fbd88b2ce">&#9670;&nbsp;</a></span>file_status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">turi::fileio::file_status</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return values of get_file_status </p>

<p class="definition">Definition at line <a class="el" href="fs__utils_8hpp_source.html#l00024">24</a> of file <a class="el" href="fs__utils_8hpp_source.html">fs_utils.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadc23eb5f702006ea84508c4501e99c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc23eb5f702006ea84508c4501e99c18">&#9670;&nbsp;</a></span>change_file_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::fileio::change_file_mode </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the file mode bits of the given file or directory in the url </p>

</div>
</div>
<a id="ga6d6d5ac854435c9148befb7b47d7d32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d6d5ac854435c9148befb7b47d7d32a">&#9670;&nbsp;</a></span>convert_to_generic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::convert_to_generic </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the path to a generic format for operation.</p>
<p>Currently, all this means is that backslashes are converted to forward slashes. </p>

</div>
</div>
<a id="gad0613ccc198cd71f5616fb61cdaa1ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0613ccc198cd71f5616fb61cdaa1ce6">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::fileio::copy </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a file from src to dest </p>

</div>
</div>
<a id="ga6cf2e34ad8bc7b04c7de6bd884723a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cf2e34ad8bc7b04c7de6bd884723a9a">&#9670;&nbsp;</a></span>create_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::fileio::create_directory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a directory and all parent required directories (like mkdir -p). Path can be hdfs, s3, or regular filesystem. Returns true on creation, false on failure or if the directory already exists. To get meaningful error messages thrown on failure, use create_directory_or_throw. </p>

</div>
</div>
<a id="ga2e7139bfea7da07df0f809b884054a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e7139bfea7da07df0f809b884054a24">&#9670;&nbsp;</a></span>create_directory_or_throw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::fileio::create_directory_or_throw </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a directory and all parent required directories (like mkdir -p). Path can be hdfs, s3, or regular filesystem. Returns true on creation, false if the directory already exists. Throws std::ios_base::failure on failure. </p>

</div>
</div>
<a id="ga4b22e913c89f6de93fbbd479c4dbbe9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b22e913c89f6de93fbbd479c4dbbe9c">&#9670;&nbsp;</a></span>delete_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::delete_object </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>proxy</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Where url points to a single object, this deletes the object. Returns an empty string on success, and an error string on failure. </p>

</div>
</div>
<a id="gac4bb5cc16050dc9ffc8079c3a9a98719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4bb5cc16050dc9ffc8079c3a9a98719">&#9670;&nbsp;</a></span>delete_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::fileio::delete_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">file_status</a>&#160;</td>
          <td class="paramname"><em>status</em> = <code>file_status::FS_UNAVAILABLE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try delete a given path. Path can be hdfs, s3, or regular filesystem. If the path is a directory, then try remove all files under directory If the path is a file, then file will be deleted immediately if the file is not currently in use, otherwise the files are to be removed later when the files are not used by anyone If path doesn't exist, this returns true. Returns true on success, false on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to delete </td></tr>
    <tr><td class="paramname">status</td><td>The file status if known. (Optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c4d89c81cc33ca602ae95fa9e10988c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4d89c81cc33ca602ae95fa9e10988c">&#9670;&nbsp;</a></span>delete_path_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::fileio::delete_path_impl </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">file_status</a>&#160;</td>
          <td class="paramname"><em>status</em> = <code>file_status::FS_UNAVAILABLE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a path. Internal function not meant to be called by external components</p>
<p>If the path is a directory, then try remove all files under directory If the path is a file, then file will be removed If path doesn't exist, this returns true. Returns true on success, false on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to delete </td></tr>
    <tr><td class="paramname">status</td><td>The file status if known. (Optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga038d2ab164bdef44757594936b867cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga038d2ab164bdef44757594936b867cfa">&#9670;&nbsp;</a></span>delete_path_recursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::fileio::delete_path_recursive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a path. if path is a directory, deletion will delete all files and directories it contains. Path can be hdfs, s3, or regular filesystem. If path doesn't exist, this returns true. Returns true on success, false on failure. </p>

</div>
</div>
<a id="ga717b2264a5a6bb05f6c2435b9cb4e7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga717b2264a5a6bb05f6c2435b9cb4e7cc">&#9670;&nbsp;</a></span>delete_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::delete_prefix </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>proxy</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Where url points to a prefix, this deletes all objects with the specified prefix. Returns an empty string on success, and an error string on failure. </p>

</div>
</div>
<a id="ga843b3c39ee4383fdbe606debcf5273c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga843b3c39ee4383fdbe606debcf5273c7">&#9670;&nbsp;</a></span>delete_temp_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::delete_temp_file </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the temporary file with the name s. Returns true on success, false on failure (file does not exist, or cannot be deleted). The file will only be deleted if a prefix of s was previously returned by <a class="el" href="group__fileio.html#ga49a7014c73f094ce56bb700d684fd08d">get_temp_name()</a>. This is done for safety to prevent this function from being used to delete arbitrary files.</p>
<p>For instance, if <a class="el" href="group__fileio.html#ga49a7014c73f094ce56bb700d684fd08d">get_temp_name()</a> previously returned /tmp/file51apTO , delete_temp_file will succeed on /tmp/file51apTO.csv . delete_temp_file will fail on stuff like /usr/bin/bash </p>

</div>
</div>
<a id="ga97a38eeb40011aa24012d90a46e53689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97a38eeb40011aa24012d90a46e53689">&#9670;&nbsp;</a></span>delete_temp_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::delete_temp_files </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>files</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a collection of temporary files. The files will only be deleted if a prefix of s was previously returned by <a class="el" href="group__fileio.html#ga49a7014c73f094ce56bb700d684fd08d">get_temp_name()</a>. This is done for safety to prevent this function from being used to delete arbitrary files.</p>
<p>For instance, if <a class="el" href="group__fileio.html#ga49a7014c73f094ce56bb700d684fd08d">get_temp_name()</a> previously returned /tmp/file51apTO , delete_temp_files will succeed on a collection of files {/tmp/file51apTO.csv, /tmp/file51apTO.txt}. delete_temp_file will fail on stuff like /usr/bin/bash </p>

</div>
</div>
<a id="ga50858708e6b493a8725bbb40d992bff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50858708e6b493a8725bbb40d992bff4">&#9670;&nbsp;</a></span>download_url() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int turi::download_url </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>output_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Downloads a given URL into a given output file </p><div class="fragment"><div class="line">retcode = <a class="code" href="group__fileio.html#ga50858708e6b493a8725bbb40d992bff4">download_url</a>(<span class="stringliteral">&quot;http://google.com&quot;</span>, <span class="stringliteral">&quot;google.html&quot;</span>);</div></div><!-- fragment --><p> Returns 0 on success, non-zero (a curl error code) on failure. </p>

</div>
</div>
<a id="gae775e307f6819797b5508a362f3a7853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae775e307f6819797b5508a362f3a7853">&#9670;&nbsp;</a></span>download_url() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;int, bool, std::string&gt; turi::download_url </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Downlaods a given URL returning the local filename it has been downloaded to. If the url is a remote URL, the URL will be downloaded to a temporary local file (created using tmpnam), and the local file name returned. If the url is a local file, the local filename will be returned directly.</p>
<dl class="section return"><dt>Returns</dt><dd>A tuple of (error_code, is_temporary, local_file_name) Error_code is non-zero on failure, in which case the other arguments should be ignored. is_temporary is true if the URL is a remote URL. local_file_name contains the local file name in which the data can be accessed.</dd></dl>
<div class="fragment"><div class="line">std::tie(status, is_temporary, filename) = <a class="code" href="group__fileio.html#ga50858708e6b493a8725bbb40d992bff4">download_url</a>(<span class="stringliteral">&quot;http://google.com&quot;</span>);</div></div><!-- fragment --><p> Returns 0 on success, non-zero (a curl error code) on failure. </p>

</div>
</div>
<a id="gad985e22fd77cbb6089449feab9c6582d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad985e22fd77cbb6089449feab9c6582d">&#9670;&nbsp;</a></span>get_alternative_ssl_cert_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; turi::fileio::get_alternative_ssl_cert_dir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the alternative ssl certificate file and directory. </p>

</div>
</div>
<a id="ga0acaf4bacb1703c8c2064132a9588258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0acaf4bacb1703c8c2064132a9588258">&#9670;&nbsp;</a></span>get_alternative_ssl_cert_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; turi::fileio::get_alternative_ssl_cert_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the alternative ssl certificate file and directory. </p>

</div>
</div>
<a id="ga3ec38e6c51a583c14f6f1a3fa93afda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ec38e6c51a583c14f6f1a3fa93afda9">&#9670;&nbsp;</a></span>get_bucket_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::get_bucket_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bucket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a S3 bucket specific path. On regular S3 this returns the virtualhosting style bucket. On other explicitly specified endpoints, this returns $S3_ENDPOINT/[bucket]/</p>
<p>For consistency, the returned bucket path will <em>always</em> end with a "/" </p>

</div>
</div>
<a id="ga65f0985583f3050646e0d96370c69115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65f0985583f3050646e0d96370c69115">&#9670;&nbsp;</a></span>get_cache_file_hdfs_location()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::get_cache_file_hdfs_location </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Additional HDFS location for storing large temp files. </p>

</div>
</div>
<a id="gad8629e24be29411f7996b62096606e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8629e24be29411f7996b62096606e0c">&#9670;&nbsp;</a></span>get_cache_file_locations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::get_cache_file_locations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the physical directory (/var/tmp) which all cached files are located in . colon seperated. </p>

</div>
</div>
<a id="ga373df97b4d1e0d066770c95270ce979f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373df97b4d1e0d066770c95270ce979f">&#9670;&nbsp;</a></span>get_cache_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::get_cache_prefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The protocol prefix cache:// to identify a cached file. </p>

</div>
</div>
<a id="ga125e90d8c636d5c4e70d25437f97682c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga125e90d8c636d5c4e70d25437f97682c">&#9670;&nbsp;</a></span>get_directory_listing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, <a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">file_status</a>&gt; &gt; turi::fileio::get_directory_listing </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerates the contents of a directory, listing all the files as well as the file type. Path can be hdfs, s3, or regular filesystem. </p>

</div>
</div>
<a id="ga73216d9bc71edc25956b166fa488e930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73216d9bc71edc25956b166fa488e930">&#9670;&nbsp;</a></span>get_dirname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::get_dirname </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the directory name from a fully qualified path. So given: s3://bucket/data/123 This will return "s3://bucket/data"</p>
<p>In short, this will return everything to the left of the last trailing "/". </p>

</div>
</div>
<a id="gaf2df6422a38ad7fdcb6e8949ecb00b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2df6422a38ad7fdcb6e8949ecb00b17">&#9670;&nbsp;</a></span>get_file_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">file_status</a>, std::string&gt; turi::fileio::get_file_status </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks a path (can be hdfs, s3, or regular) to see if it is a local path, or a remote path.</p>
<p>if file is missing, err_msg will be the second value if provided </p>

</div>
</div>
<a id="ga08e80ce4936ba924ae5893d278ef8160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08e80ce4936ba924ae5893d278ef8160">&#9670;&nbsp;</a></span>get_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::get_filename </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts the file name from a fully qualified path. So given: s3://bucket/data/123 This will return "123".</p>
<p>In short, this will return everything to the right of the last trailing "/". </p>

</div>
</div>
<a id="ga20a81f87a433cf558ae08b02914327fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20a81f87a433cf558ae08b02914327fa">&#9670;&nbsp;</a></span>get_glob_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, <a class="el" href="group__fileio.html#ga76f0038f6e87bbd52aea670fbd88b2ce">file_status</a>&gt; &gt; turi::fileio::get_glob_files </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Where URL is a glob of the form directory1/directory2/[glob] (glob must only be on the file portion), returns a list of files matching the glob pattern. </p>

</div>
</div>
<a id="gace35fc0e0221b6c2b2c3bc20556a9579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace35fc0e0221b6c2b2c3bc20556a9579">&#9670;&nbsp;</a></span>get_io_parallelism_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::fileio::get_io_parallelism_id </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a URL, returns an ID value where URLs which return different ID values are ok to be read in parallel, and URLs which return the same ID value are probably sub-optimal if read in parallel; An ID of (size_t)(-1) indicates that it can be read in parallel with everything. </p>

</div>
</div>
<a id="ga0ea68b924ea1ef006293970e563861c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ea68b924ea1ef006293970e563861c0">&#9670;&nbsp;</a></span>get_region_name_from_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::get_region_name_from_endpoint </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an region name from the endpoint url. </p>

</div>
</div>
<a id="gafa81576e130480bf0ef09e20896a1ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa81576e130480bf0ef09e20896a1ab7">&#9670;&nbsp;</a></span>get_s3_endpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; turi::fileio::get_s3_endpoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a complete list of all available S3 region-specific endpoints. </p>

</div>
</div>
<a id="gabade0bf49f31a40150a079328ebc507b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabade0bf49f31a40150a079328ebc507b">&#9670;&nbsp;</a></span>get_s3_error_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::get_s3_error_code </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the S3 error code contains in the message. If the message does not contain error code, return the message itself. </p>

</div>
</div>
<a id="ga5ff7eac62175d5e5bac69a32ba1fee75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ff7eac62175d5e5bac69a32ba1fee75">&#9670;&nbsp;</a></span>get_s3_file_last_modified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::get_s3_file_last_modified </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the last modified time stamp of file.</p>
<p>Throw exception if the url cannot be fetched.</p>
<p>Return empty string if last modified is not available, e.g. the url is a directory path or file does not exist. </p>

</div>
</div>
<a id="ga2ca7c12d648fa93188a1a70aed114425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ca7c12d648fa93188a1a70aed114425">&#9670;&nbsp;</a></span>get_system_temp_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::get_system_temp_directory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the system temporary directory </p>

</div>
</div>
<a id="ga6a39d09df58879b880f0ba2102ec047f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a39d09df58879b880f0ba2102ec047f">&#9670;&nbsp;</a></span>get_system_user_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::get_system_user_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current system user name. </p>

</div>
</div>
<a id="ga6c2ea815f13df6e379bf8c5d11cbfe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c2ea815f13df6e379bf8c5d11cbfe5d">&#9670;&nbsp;</a></span>get_temp_cache_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::get_temp_cache_prefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The "directory" (cache://tmp/) which all cached files are located in </p>

</div>
</div>
<a id="ga904c193b58d4fefe5737c11a8bd2f961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga904c193b58d4fefe5737c11a8bd2f961">&#9670;&nbsp;</a></span>get_temp_directories()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; turi::get_temp_directories </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set of temp directories </p>

</div>
</div>
<a id="ga49a7014c73f094ce56bb700d684fd08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49a7014c73f094ce56bb700d684fd08d">&#9670;&nbsp;</a></span>get_temp_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::get_temp_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_prefer_hdfs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a file name which can be used for a temp file. Returns an empty string on failure, a temporary file name on success. The file name returned is allowed to be a "prefix". i.e. arbitrary extensions can be attached to be tail of the file. For instance, if <a class="el" href="group__fileio.html#ga49a7014c73f094ce56bb700d684fd08d">get_temp_name()</a> returns /tmp/file51apTO, you can use /tmp/file51apTO.csv</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Optional. If specified, this exact prefix will be returned in the temporary path. ex: /var/tmp/turicreate-user/12345/[prefix]. If an empty string or not specified, a random unique prefix will be generated.</td></tr>
    <tr><td class="paramname">_prefer_hdfs</td><td>Optional, defaults to false. If true, prefers to use HDFS if available.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that if you specify your own prefix it is up to you to manage collisions, i.e. multiple parts of the program using the same prefix for instance. </p>

</div>
</div>
<a id="ga8bea12507112de131eebd578bccfcb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bea12507112de131eebd578bccfcb89">&#9670;&nbsp;</a></span>get_temp_name_prefer_hdfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::get_temp_name_prefer_hdfs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as get_temp_name but return the temp file on hdfs if avaiable. The hdfs temp file location is a runtime configurable variable TURI_CACHE_FILE_HDFS_LOCATION defined in fileio_constant.hpp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Optional. If specified, this exact prefix will be returned in the temporary path. ex: /var/tmp/turicreate-user/12345/[prefix]. If an empty string or not specified, a random unique prefix will be generated.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that if you specify your own prefix it is up to you to manage collisions, i.e. multiple parts of the program using the same prefix for instance. </p>

</div>
</div>
<a id="gacd816d0bb628e05ad9e3387a29bf5809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd816d0bb628e05ad9e3387a29bf5809">&#9670;&nbsp;</a></span>insecure_ssl_cert_checks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool turi::fileio::insecure_ssl_cert_checks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, ssl certificate checks are disabled. </p>

</div>
</div>
<a id="ga234867c61a56b4fa2622e0f672084360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga234867c61a56b4fa2622e0f672084360">&#9670;&nbsp;</a></span>list_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structturi_1_1list__objects__response.html">list_objects_response</a> turi::list_directory </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>proxy</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lists all objects prefixed by a give s3 url.</p>
<p>if s3_url points to a valid prefix, it will return the prefix's contents like a directory.</p>
<p>foo/hello.txt</p>
<p>list_objects("s3://foo") will return "foo/hello.txt"</p>
<p>If s3_url points to an object it will just return the object.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structturi_1_1list__objects__response.html">list_objects_response</a> object. If <a class="el" href="structturi_1_1list__objects__response.html#af577365458322fb05e09b782bcc257c6" title="Non-empty if there was an error. ">list_objects_response.error</a> is an empty string, it indicates success. Otherwise, it contains an error code. <a class="el" href="structturi_1_1list__objects__response.html#a76ffe7439c8f537e75bbad6f7e561356" title="A list of all the &quot;sub-directories&quot; found. ">list_objects_response.directories</a> indicate all "directories" stored with the requested prefix. And <a class="el" href="structturi_1_1list__objects__response.html#a5f2adce2ab92d07e7920daacabe97d8f" title="A list of all the objects found. ">list_objects_response.objects</a> indicates all regular objects stored with the requested prefix. </dd></dl>

</div>
</div>
<a id="ga5d061c799a90c5c6a03728ef3de03d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d061c799a90c5c6a03728ef3de03d07">&#9670;&nbsp;</a></span>list_objects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structturi_1_1list__objects__response.html">list_objects_response</a> turi::list_objects </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s3_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>proxy</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lists objects or prefixes prefixed by a give s3 url.</p>
<p>This is a thin wrapper around the S3 API <a href="http://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGET.html">http://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGET.html</a> and may not quite do what you think it does.</p>
<p>if s3_url points to a valid prefix, it will return only the prefix as a directory. For instance if I have an S3 bucket containing</p>
<p>foo/hello.txt</p>
<p>list_objects("s3://foo") will return simply "foo/" as a directory.</p>
<p>See <a class="el" href="group__fileio.html#ga234867c61a56b4fa2622e0f672084360">list_directory()</a> and is_directory() for a more sensible implementation which behaves somewhat more file system like.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structturi_1_1list__objects__response.html">list_objects_response</a> object. If <a class="el" href="structturi_1_1list__objects__response.html#af577365458322fb05e09b782bcc257c6" title="Non-empty if there was an error. ">list_objects_response.error</a> is an empty string, it indicates success. Otherwise, it contains an error code. <a class="el" href="structturi_1_1list__objects__response.html#a76ffe7439c8f537e75bbad6f7e561356" title="A list of all the &quot;sub-directories&quot; found. ">list_objects_response.directories</a> indicate all "directories" stored with the requested prefix. And <a class="el" href="structturi_1_1list__objects__response.html#a5f2adce2ab92d07e7920daacabe97d8f" title="A list of all the objects found. ">list_objects_response.objects</a> indicates all regular objects stored with the requested prefix. </dd></dl>

</div>
</div>
<a id="ga71342aad2af5ea34fa8570899f610963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71342aad2af5ea34fa8570899f610963">&#9670;&nbsp;</a></span>make_absolute_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::make_absolute_path </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>root_directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a root directory and a relative path, tries to convert the relative path to an absolute path. If the path is already an absolute path, returns the original path with no changes.</p>
<p>This function is absolutely limited. It will not handle "../" structures to the returned relative path. In other words, the output path path must point to a file/folder inside of the root directory.</p>
<p>Example: make_absolute_path("s3://bucket/data", "123") returns "s3://bucket/data/123".</p>
<p>make_absolute_path("s3://bucket/data", "s3://foo/123") returns "s3://foo/123". </p>

</div>
</div>
<a id="gad57c9c33c024ee5b4a5c4a4626db4138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad57c9c33c024ee5b4a5c4a4626db4138">&#9670;&nbsp;</a></span>make_canonical_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::make_canonical_path </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return canonical absolute path, eliminating dots, and symlinks </p>

</div>
</div>
<a id="ga369eff0d3577d8e5fdfc30e5b32b0593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga369eff0d3577d8e5fdfc30e5b32b0593">&#9670;&nbsp;</a></span>make_relative_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::make_relative_path </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>root_directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a root directory and an absolute path, tries to create a relative path address between root_directory and the path; if not possible, returns the the original path with no changes.</p>
<p>This function is relatively limited. It will not add "../" structures to the returned relative path. In other words, the path must point to a file/folder inside of the root directory for this to return a relative path.</p>
<p>Example: make_relative_path("s3://bucket/data", "s3://bucket/data/123") returns "123".</p>
<p>make_relative_path("s3://bucket/data", "s3://foo/123") returns "s3://foo/123". </p>

</div>
</div>
<a id="ga938d93ca534d16a0946cba20516890f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga938d93ca534d16a0946cba20516890f7">&#9670;&nbsp;</a></span>num_temp_directories()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::num_temp_directories </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of temp directories </p>

</div>
</div>
<a id="ga5960b295c95ba0e4db8ddecf2438f924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5960b295c95ba0e4db8ddecf2438f924">&#9670;&nbsp;</a></span>parse_hdfs_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::string, std::string, std::string&gt; turi::fileio::parse_hdfs_url </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A helper function to parse the hdfs url. Return a tuple of host, port, and path. </p>

</div>
</div>
<a id="gaf1f462276b68dd6b4dfec9a8a0e5213c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1f462276b68dd6b4dfec9a8a0e5213c">&#9670;&nbsp;</a></span>parse_s3url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::parse_s3url </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structturi_1_1s3url.html">s3url</a> &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>err_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This splits a URL of the form s3://[access_key_id]:[secret_key]:[endpoint][/bucket]/[object_name] into several pieces.</p>
<p>endpoint and object_name are optional.</p>
<p>Returns true on success, false on failure. </p>

</div>
</div>
<a id="ga9148e7456c812a233d184699e377c959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9148e7456c812a233d184699e377c959">&#9670;&nbsp;</a></span>reap_current_process_temp_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::reap_current_process_temp_files </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all temp files created by the current process </p>

</div>
</div>
<a id="gaadc7f2e18c38aae6132d2da2b50a08d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadc7f2e18c38aae6132d2da2b50a08d8">&#9670;&nbsp;</a></span>reap_unused_temp_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::reap_unused_temp_files </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all temporary directories in the temporary turicreate/ directory (/var/tmp/turicreate) which are no longer used. i.e. was created by a process which no longer exists. </p>

</div>
</div>
<a id="ga9a7d84a46df11a91b15a027e88bc8f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7d84a46df11a91b15a027e88bc8f8e">&#9670;&nbsp;</a></span>remove_protocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::remove_protocol </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the path removing the protocol header if there is one. .</p>
<p>remove_protocol("http://www.google.com") == "www.google.com" remove_protocol("s3://www.google.com") == "www.google.com" remove_protocol("/root/test") == "/root/test" remove_protocol("file:///root/test") == "/root/test" </p>

</div>
</div>
<a id="ga814071ebbbb49a2ba27bace0540a09db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814071ebbbb49a2ba27bace0540a09db">&#9670;&nbsp;</a></span>sanitize_s3_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::sanitize_s3_url </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an S3 URL of the form expected by parse_s3url, this function drops the access_key_id and the secret_key from the string returning s3://[bucket]/[object_name]</p>
<p>If the url cannot be parsed, we try the best to remove information associated with ':'.</p>
<p>If the url does not begin with s3://, return as is. </p>

</div>
</div>
<a id="ga77744d8898a95679d4f8c399767728b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77744d8898a95679d4f8c399767728b0">&#9670;&nbsp;</a></span>sanitize_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::sanitize_url </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sanitizes a general_fstream URL so that it is suitable for printing; right now, all it does is to drop all credential information when the protocol is s3. </p>

</div>
</div>
<a id="ga050cea055c4ab69186ada70d0ec37d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga050cea055c4ab69186ada70d0ec37d3a">&#9670;&nbsp;</a></span>set_cache_file_locations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::fileio::set_cache_file_locations </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the physical directory (/var/tmp) which all cached files are located in . colon seperated. </p>

</div>
</div>
<a id="ga65434d49942dcd935311a42566321853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65434d49942dcd935311a42566321853">&#9670;&nbsp;</a></span>set_curl_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::fileio::set_curl_options </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ecurl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets curl options for everywhere curl is used. </p>

</div>
</div>
<a id="ga2c38590a0ad13fa63e4d25a366b653a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c38590a0ad13fa63e4d25a366b653a3">&#9670;&nbsp;</a></span>set_download_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::set_download_timeout </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the timeout for S3 download. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout value in secs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a3799347c103129ae70805e0161a6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a3799347c103129ae70805e0161a6ff">&#9670;&nbsp;</a></span>set_upload_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::set_upload_timeout </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the timeout for S3 upload. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout value in secs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab2502bb41442f0982b097b9f77e46c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2502bb41442f0982b097b9f77e46c2a">&#9670;&nbsp;</a></span>try_to_open_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::fileio::try_to_open_file </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the file can be opened. False otherwise. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gafc09f445f1d03adfe77768722a423730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc09f445f1d03adfe77768722a423730">&#9670;&nbsp;</a></span>FILEIO_INITIAL_CAPACITY_PER_FILE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t turi::fileio::FILEIO_INITIAL_CAPACITY_PER_FILE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The initial memory capacity assigned to caches </p>

</div>
</div>
<a id="ga72e2b97f180c904aca56ed113b5cee9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72e2b97f180c904aca56ed113b5cee9a">&#9670;&nbsp;</a></span>FILEIO_MAXIMUM_CACHE_CAPACITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::fileio::FILEIO_MAXIMUM_CACHE_CAPACITY</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum memory capacity used by all cached files be flushed. </p>

</div>
</div>
<a id="ga7788837045c8685fea964bfb62565d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7788837045c8685fea964bfb62565d37">&#9670;&nbsp;</a></span>FILEIO_MAXIMUM_CACHE_CAPACITY_PER_FILE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::fileio::FILEIO_MAXIMUM_CACHE_CAPACITY_PER_FILE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum memory capacity assigned to a cached file until it has to be flushed. </p>

</div>
</div>
<a id="gaa0389579b7266afb2e8026ebec9d018e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0389579b7266afb2e8026ebec9d018e">&#9670;&nbsp;</a></span>FILEIO_READER_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::fileio::FILEIO_READER_BUFFER_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default fileio reader buffer size </p>

</div>
</div>
<a id="ga7bb2701d37c920ce6c02cc1d186e4818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bb2701d37c920ce6c02cc1d186e4818">&#9670;&nbsp;</a></span>FILEIO_WRITER_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::fileio::FILEIO_WRITER_BUFFER_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default fileio writer buffer size </p>

</div>
</div>
<a id="ga30c6f7618937944a323b6a79c39bb207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30c6f7618937944a323b6a79c39bb207">&#9670;&nbsp;</a></span>NUM_GPUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t turi::fileio::NUM_GPUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of GPUs. </p>

</div>
</div>
<a id="ga112295e21cd70e9787d31753c40e6c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga112295e21cd70e9787d31753c40e6c53">&#9670;&nbsp;</a></span>S3_ENDPOINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::S3_ENDPOINT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The S3 connection endpoint; if empty string, S3 is assumed. </p>

</div>
</div>
<a id="ga6f5fd91811967243ce77a229ccb7c944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f5fd91811967243ce77a229ccb7c944">&#9670;&nbsp;</a></span>S3_REGION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::fileio::S3_REGION</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The S3 connection region; if empty string, region will be guessed by:</p><ol type="1">
<li>TURI_S3_REGION environment variable</li>
<li>AWS_DEFAULT_REGION environment variable</li>
<li>known region to endpoint mappings if none of above works, empty region string will be set and AWS will guess bucket region from endpoint. </li>
</ol>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
