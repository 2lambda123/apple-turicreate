<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Turi Create: CPPIPC Basic Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('using_cppipc_basics.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CPPIPC Basic Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>CPPIPC is a client-server architecture, where</p>
<ol type="1">
<li>Server offers a list of types that can be instantiated</li>
<li>Client connects to the server</li>
<li>Client asks for an object of a particular type to be created.</li>
<li>Server creates the object and client creates a "proxy" for the object.</li>
<li>Client uses the proxy object as if it is a local object, except that all calls are evaluated on the server</li>
<li>When client destroys the object, the object on the server is destroyed.</li>
</ol>
<p>The basic idea of CPPIPC is the triple split of</p><ul>
<li>Base Class</li>
<li>Implementation Class</li>
<li>Proxy Class</li>
</ul>
<h1><a class="anchor" id="using_cppipc_basics_separation"></a>
Base, Implementation and Proxy Separation</h1>
<p>To communicate reliably, it is crucial that both client and server have a common view of an object. To achieve this, we go with the common base class model: a base class is used to define an interface, and an implementation of the interface is provided on the server side. On the client side, a proxy class (which also implements the interface) is provided, except that this proxy class simply forwards all calls to the server.</p>
<p>For instance (this code will not actually work): </p><div class="fragment"><div class="line"><span class="comment">// known by both client and server</span></div><div class="line"><span class="keyword">class </span>print_something_base {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> print(std::string message);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// known only by client</span></div><div class="line"><span class="keyword">class </span>print_something_proxy: <span class="keyword">public</span> print_something_base {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> print(std::string message) {</div><div class="line">    <span class="comment">// forward &#39;message&#39; to server</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// known only by server</span></div><div class="line"><span class="keyword">class </span>print_something: <span class="keyword">public</span> print_something_base {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> print(std::string message) {</div><div class="line">    std::cout &lt;&lt; message;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="using_cppipc_base_and_proxy"></a>
Base and Proxy classes</h1>
<p>However, implementing a proxy class is hugely annoying (you have to implement the class all over again), easy to get wrong (since there will be a decent amount of copy and pasting), and there are several rules and stuff (registration must be called, etc). We therefore provide a collection of magic macros that make the implementation effort easier, though at the cost of some of the most annoying looking compiler messages at minor syntax errors.</p>
<p>Here, we are going to implement a basic "counter" service. i.e. the server is going to maintain an integer counter which we can read, and add to.</p>
<p>Begin by #including the appropriate headers </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;core/system/cppipc/cppipc.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;core/system/cppipc/magic_macros.hpp&gt;</span></div></div><!-- fragment --><p>We can then generate the interface and proxy objects using the <a class="el" href="group__cppipc.html#ga838dae619459dce33202c1e28ecc2966">GENERATE_INTERFACE_AND_PROXY</a> macro.</p>
<div class="fragment"><div class="line"><a class="code" href="group__cppipc.html#ga838dae619459dce33202c1e28ecc2966">GENERATE_INTERFACE_AND_PROXY</a>(basic_counter_base,  basic_counter_proxy,</div><div class="line">                              (<span class="keywordtype">int</span>, add, (<span class="keywordtype">int</span>))</div><div class="line">                              (<span class="keywordtype">int</span>, add_multiple, (<span class="keywordtype">int</span>)(<span class="keywordtype">int</span>))</div><div class="line">                              (<span class="keywordtype">int</span>, get_val, )</div><div class="line">                            )</div></div><!-- fragment --><p>For instance, here, we created an interface class called "basic_counter_base", and a proxy class called "basic_counter_proxy" which extends the base class. The base class defines 3 functions,</p><ul>
<li>a function called "add" which takes one integer and returns an integer. This function will add the integer to the counter, and return the new counter value.</li>
<li>a function called "add_multiple" which takes two integers and returns an integer. This function will add the product of the input integers to the counter, and return the new counter value.</li>
<li>a function called "get_val" which takes no arguments and returns an integer. This function will return the current counter value.</li>
</ul>
<p>A few observations.</p><ul>
<li>Each "function definition" is not separated by commas, but is just consecutive parenthesis blocks.</li>
<li>Each input argument type of the function is in its own parentheses block.</li>
<li>Even if a function takes no arguments, a final "comma" is necessary in the function definition</li>
<li>There must be no variable names in the arguments.</li>
</ul>
<p>The calls are serialized using Turi Create's serialization interface. i.e. all arguments and return types must be serializable. See serialization for details.</p>
<p>Known Limitations:</p><ul>
<li>No function overloads permitted</li>
<li>This is a limitation of the C++ preprocessor. type names cannot have commas in them. If you have a comma in a type, for instance <code>"std::map&lt;std::string, size_t&gt;"</code> you will need to typedef it to a type name with no commas before using it in the macro. For instance:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// BAD!</span></div><div class="line"><a class="code" href="group__cppipc.html#ga838dae619459dce33202c1e28ecc2966">GENERATE_INTERFACE_AND_PROXY</a>(basic_counter_base,  basic_counter_proxy,</div><div class="line">                              (std::map&lt;std::string, size_t&gt;, thingee, )</div><div class="line">                            )</div><div class="line"><span class="comment">// GOOD!</span></div><div class="line">typedef <a class="code" href="namespacestd.html">std</a>::map&lt;<a class="code" href="namespacestd.html">std</a>::<span class="keywordtype">string</span>, <span class="keywordtype">size_t</span>&gt; str_int_map_type;</div><div class="line"><a class="code" href="group__cppipc.html#ga838dae619459dce33202c1e28ecc2966">GENERATE_INTERFACE_AND_PROXY</a>(basic_counter_base,  basic_counter_proxy,</div><div class="line">                              (str_int_map_type, thingee, )</div><div class="line">                            )</div></div><!-- fragment --><p>To see why you should always use the magic macros and not write your own proxy/base object, see the documentation for GENERATE_INTERFACE_AND_PROXY</p>
<h1><a class="anchor" id="using_cppipc_implementation"></a>
Implementation Classes</h1>
<p>Now, the macro defines the base and proxy objects, but you have to define your own implementation object. There are no rules for the implementation object besides that you must inherit from the base, and implement all the functions defined in the base.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>basic_counter: <span class="keyword">public</span> basic_counter_base {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">   <span class="keywordtype">int</span> value;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   basic_counter():value(0) {}</div><div class="line"></div><div class="line">   <span class="keywordtype">int</span> add(<span class="keywordtype">int</span> a) {</div><div class="line">     value += a;</div><div class="line">     <span class="keywordflow">return</span> value;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordtype">int</span> add_multiple(<span class="keywordtype">int</span> val, <span class="keywordtype">int</span> count) {</div><div class="line">     value += val * count;</div><div class="line">     <span class="keywordflow">return</span> value;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keywordtype">int</span> get_val() {</div><div class="line">     <span class="keywordflow">return</span> value;</div><div class="line">   }</div><div class="line">};</div></div><!-- fragment --><p>And you are done!</p>
<h1><a class="anchor" id="using_cppipc_client_and_server"></a>
Implementing a Server and a Client Program</h1>
<p>Put it all in a header (for simplicity). In a real system the implementation will be placed separately from the proxy so the client compilation does not inherit all the server's dependencies.</p>
<p>Next create 2 cpp files, one server, and one client. </p><div class="fragment"><div class="line"><span class="comment">// Server Example</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;core/system/cppipc/cppipc.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;basic_counter.hpp&quot;</span></div><div class="line"></div><div class="line">basic_counter_base* basic_counter_factory() {</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">new</span> basic_counter;</div><div class="line">}</div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">  <a class="code" href="classcppipc_1_1comm__server.html">cppipc::comm_server</a> server({}, <span class="stringliteral">&quot;ipc:///tmp/cppipc_server_test&quot;</span>);</div><div class="line">  server.<a class="code" href="classcppipc_1_1comm__server.html#ae1a4b406f8b0061a14e00634228ee8bd">register_type</a>&lt;basic_counter_base&gt;(basic_counter_factory);</div><div class="line">  server.start();</div><div class="line">  getchar();</div><div class="line">}</div></div><!-- fragment --><p>The "ipc:///tmp/cppipc_server_test" is a ZeroMQ endpoint address and is the address the server will listen and wait on for connections. <code>ipc://</code> is an "interprocess socket" endpoint and should point to a filename (preferably non-existent, and unused). It can also be <code>tcp://</code>[ip address]:[portnumber] to have the server wait on a TCP/IP connection. Note that it must be an IP address in this case. ZeroMQ does not do hostname resolution.</p>
<p>The <a class="el" href="classcppipc_1_1comm__server.html#ae1a4b406f8b0061a14e00634228ee8bd">register_type</a> call is used to register the "basic_counter_base" type with the server, and also inform the server how to construct an instance of the object when asked by a client. (As an alternative to defining a factory function, a lambda can be used as well).</p>
<div class="fragment"><div class="line"><span class="comment">// Client Example</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;core/system/cppipc/cppipc.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;basic_counter.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">  <span class="comment">// Connects to the server</span></div><div class="line">  <a class="code" href="classcppipc_1_1comm__client.html">cppipc::comm_client</a> client({}, <span class="stringliteral">&quot;ipc:///tmp/cppipc_server_test&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Creates a proxy object. This calls the factory on the server to create</span></div><div class="line">  <span class="comment">// a basic_counter on the server. The proxy object on the client only</span></div><div class="line">  <span class="comment">// maintains an object ID.</span></div><div class="line">  basic_counter_proxy proxy(client);</div><div class="line"></div><div class="line">  <span class="comment">//adds 50 to the counter</span></div><div class="line">  proxy.add(50);</div><div class="line"></div><div class="line">  <span class="comment">//adds 12 * 5 to the counter</span></div><div class="line">  proxy.add_multiple(12, 5);</div><div class="line"></div><div class="line">  <span class="comment">// prints the counter value</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Counter Value: &quot;</span> &lt;&lt; proxy.get_val() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">  <span class="comment">// when proxy is destroyed, it destroys the object on the server</span></div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="using_cppipc.html">Introduction to CPPIPC</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
