<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Turi Create: turi::flexible_type Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1flexible__type.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classturi_1_1flexible__type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::flexible_type Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="flexible__type_8hpp_source.html">flexible_type/flexible_type.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab7ced47636ee238dd993324b39ad6610"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> () noexcept</td></tr>
<tr class="separator:ab7ced47636ee238dd993324b39ad6610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c7fa8c01d6db018be39dd30e215799"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2c7fa8c01d6db018be39dd30e215799"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ac2c7fa8c01d6db018be39dd30e215799">flexible_type</a> (std::initializer_list&lt; T &gt; &amp;&amp;list)</td></tr>
<tr class="separator:ac2c7fa8c01d6db018be39dd30e215799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a6ea5c9546e13b27af4d182ffa93a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a51a6ea5c9546e13b27af4d182ffa93a5">~flexible_type</a> ()</td></tr>
<tr class="separator:a51a6ea5c9546e13b27af4d182ffa93a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171b4d172f56f2423cfe1e9a6ede1b28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a171b4d172f56f2423cfe1e9a6ede1b28">flexible_type</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) noexcept</td></tr>
<tr class="separator:a171b4d172f56f2423cfe1e9a6ede1b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9993462e293cbc5f2704f7ca0e11ddc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aa9993462e293cbc5f2704f7ca0e11ddc">flexible_type</a> (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) noexcept</td></tr>
<tr class="separator:aa9993462e293cbc5f2704f7ca0e11ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01bd195ee79870fcb478c502c344ba8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa01bd195ee79870fcb478c502c344ba8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aa01bd195ee79870fcb478c502c344ba8">flexible_type</a> (const T &amp;other, typename std::enable_if&lt; <a class="el" href="structturi_1_1has__direct__conversion__to__flexible__type.html">has_direct_conversion_to_flexible_type</a>&lt; T &gt;::value &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> *=nullptr)</td></tr>
<tr class="separator:aa01bd195ee79870fcb478c502c344ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f079870085a1cf1ef7c388924e3a6d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a1f079870085a1cf1ef7c388924e3a6d0">flexible_type</a> (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a1f079870085a1cf1ef7c388924e3a6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348e5802b07129488147b0f0c1d9645e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a348e5802b07129488147b0f0c1d9645e">flexible_type</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a348e5802b07129488147b0f0c1d9645e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe86bf41dac86c9285d175c6f220056d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe86bf41dac86c9285d175c6f220056d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#afe86bf41dac86c9285d175c6f220056d">flexible_type</a> (T &amp;&amp;other, typename std::enable_if&lt; <a class="el" href="structturi_1_1has__direct__conversion__to__flexible__type.html">has_direct_conversion_to_flexible_type</a>&lt; typename std::remove_reference&lt; T &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> &gt;::value &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> *=nullptr)</td></tr>
<tr class="separator:afe86bf41dac86c9285d175c6f220056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae982bbb01bc4676c69032874d461b69b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ae982bbb01bc4676c69032874d461b69b">soft_assign</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other)</td></tr>
<tr class="separator:ae982bbb01bc4676c69032874d461b69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53b3520c60da7f16acf3c589362cd1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#af53b3520c60da7f16acf3c589362cd1c">operator=</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) noexcept</td></tr>
<tr class="separator:af53b3520c60da7f16acf3c589362cd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af597974b07b643dffdc19de841853d6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#af597974b07b643dffdc19de841853d6c">operator=</a> (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) noexcept</td></tr>
<tr class="separator:af597974b07b643dffdc19de841853d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be2c54cb4dc92389e9939e14d2da671"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a4be2c54cb4dc92389e9939e14d2da671">operator=</a> (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:a4be2c54cb4dc92389e9939e14d2da671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5966a02cba0ea22dfbdf84283402e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ab5966a02cba0ea22dfbdf84283402e82">operator=</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:ab5966a02cba0ea22dfbdf84283402e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8829aee500d6db73b2d433f4e583f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f8829aee500d6db73b2d433f4e583f3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structturi_1_1has__direct__conversion__to__flexible__type.html">has_direct_conversion_to_flexible_type</a>&lt; T &gt;::value, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a5f8829aee500d6db73b2d433f4e583f3">operator=</a> (const T &amp;other)</td></tr>
<tr class="separator:a5f8829aee500d6db73b2d433f4e583f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b818888ac1197bdf9357b143f7512f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a10b818888ac1197bdf9357b143f7512f">operator=</a> (<a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a> other)</td></tr>
<tr class="separator:a10b818888ac1197bdf9357b143f7512f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f5221f75fc0c255da208cdf70b2378"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9f5221f75fc0c255da208cdf70b2378"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structturi_1_1has__direct__conversion__to__flexible__type.html">has_direct_conversion_to_flexible_type</a>&lt; typename std::remove_reference&lt; T &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> &gt;::value, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ab9f5221f75fc0c255da208cdf70b2378">operator=</a> (T &amp;&amp;other)</td></tr>
<tr class="separator:ab9f5221f75fc0c255da208cdf70b2378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed81c5fda8f3b8de29d0c7a91b952c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a4ed81c5fda8f3b8de29d0c7a91b952c5">reset</a> (<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> target_type)</td></tr>
<tr class="separator:a4ed81c5fda8f3b8de29d0c7a91b952c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8258899dbd19b7df408fed0910de568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ab8258899dbd19b7df408fed0910de568">reset</a> ()</td></tr>
<tr class="separator:ab8258899dbd19b7df408fed0910de568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d0457f38e3771d2af4f57da1c17ffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a59d0457f38e3771d2af4f57da1c17ffe">set_date_time_from_timestamp_and_offset</a> (const std::pair&lt; <a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>, int32_t &gt; &amp;datetime, const int32_t microsecond=0)</td></tr>
<tr class="separator:a59d0457f38e3771d2af4f57da1c17ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb5fe9271a6d80e4fdad1444fcec707"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#addb5fe9271a6d80e4fdad1444fcec707">get_date_time_as_timestamp_and_offset</a> () const </td></tr>
<tr class="separator:addb5fe9271a6d80e4fdad1444fcec707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bce4a1134a84369aa8b47d061277c5f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a8bce4a1134a84369aa8b47d061277c5f">get_date_time_microsecond</a> () const </td></tr>
<tr class="separator:a8bce4a1134a84369aa8b47d061277c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0907f9ecf1729ea0abc966d83061039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aa0907f9ecf1729ea0abc966d83061039">swap</a> (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;b)</td></tr>
<tr class="separator:aa0907f9ecf1729ea0abc966d83061039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d458fcb9c26aeb86e4bb97d9c438b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87d458fcb9c26aeb86e4bb97d9c438b1"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a87d458fcb9c26aeb86e4bb97d9c438b1">mutable_get</a> ()</td></tr>
<tr class="separator:a87d458fcb9c26aeb86e4bb97d9c438b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb5ea486620ffdd6f5aef446d3d304b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9cb5ea486620ffdd6f5aef446d3d304b"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a9cb5ea486620ffdd6f5aef446d3d304b">get</a> () const </td></tr>
<tr class="separator:a9cb5ea486620ffdd6f5aef446d3d304b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fba3522c10c5c6f73f260c78866771b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fba3522c10c5c6f73f260c78866771b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a1fba3522c10c5c6f73f260c78866771b">reinterpret_mutable_get</a> ()</td></tr>
<tr class="separator:a1fba3522c10c5c6f73f260c78866771b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d635f1b191841b7a0a621f823df0a7a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d635f1b191841b7a0a621f823df0a7a"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a7d635f1b191841b7a0a621f823df0a7a">reinterpret_get</a> () const </td></tr>
<tr class="separator:a7d635f1b191841b7a0a621f823df0a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada3ceebb28d5983567e22a3ff5ec559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aada3ceebb28d5983567e22a3ff5ec559">get_type</a> () const </td></tr>
<tr class="separator:aada3ceebb28d5983567e22a3ff5ec559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6127144212fdeb61d0094ee013e22baa"><td class="memItemLeft" align="right" valign="top">std::type_index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> () const </td></tr>
<tr class="separator:a6127144212fdeb61d0094ee013e22baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace41cf48dbbaf4f135d162d4526f48b9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ace41cf48dbbaf4f135d162d4526f48b9">which</a> () const </td></tr>
<tr class="separator:ace41cf48dbbaf4f135d162d4526f48b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577751f04f2c83f55daa41f33eac08c5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a577751f04f2c83f55daa41f33eac08c5">hash</a> () const </td></tr>
<tr class="separator:a577751f04f2c83f55daa41f33eac08c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96c79e7593d92dd82edeaff94209999"><td class="memItemLeft" align="right" valign="top">uint128_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ad96c79e7593d92dd82edeaff94209999">hash128</a> () const </td></tr>
<tr class="separator:ad96c79e7593d92dd82edeaff94209999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a682f12baf1051f447c67ba536190e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ab1a682f12baf1051f447c67ba536190e">is_zero</a> () const </td></tr>
<tr class="separator:ab1a682f12baf1051f447c67ba536190e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696f154a155e87d54c5b837b863504de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a696f154a155e87d54c5b837b863504de">is_na</a> () const </td></tr>
<tr class="separator:a696f154a155e87d54c5b837b863504de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0c0492299b1836669fbc82df082cbd"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:a7e0c0492299b1836669fbc82df082cbd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a7e0c0492299b1836669fbc82df082cbd">apply_mutating_visitor</a> (Visitor visitor) -&gt; decltype(visitor(prototype_flex_int))</td></tr>
<tr class="separator:a7e0c0492299b1836669fbc82df082cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1e483031a1fd5fa79b4199e65cdc6b"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:a2e1e483031a1fd5fa79b4199e65cdc6b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a2e1e483031a1fd5fa79b4199e65cdc6b">apply_visitor</a> (Visitor visitor) const  -&gt; decltype(visitor(prototype_flex_int))</td></tr>
<tr class="separator:a2e1e483031a1fd5fa79b4199e65cdc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb2f369d84f4fba671acbcfce09aa3c"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:aadb2f369d84f4fba671acbcfce09aa3c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aadb2f369d84f4fba671acbcfce09aa3c">apply_mutating_visitor</a> (Visitor visitor, const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) -&gt; decltype(visitor(prototype_flex_int, <a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>()))</td></tr>
<tr class="separator:aadb2f369d84f4fba671acbcfce09aa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12122b8e581e5ab73f7025414fbf4ed0"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:a12122b8e581e5ab73f7025414fbf4ed0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a12122b8e581e5ab73f7025414fbf4ed0">apply_visitor</a> (Visitor visitor, const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const  -&gt; decltype(visitor(prototype_flex_int, <a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>()))</td></tr>
<tr class="separator:a12122b8e581e5ab73f7025414fbf4ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421486b2402e8c24c9c0a06fb39a3ae3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a421486b2402e8c24c9c0a06fb39a3ae3"></a>
template&lt;class T , typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type *  = (void*)NULL&gt; </td></tr>
<tr class="memitem:a421486b2402e8c24c9c0a06fb39a3ae3"><td class="memTemplItemLeft" align="right" valign="top">FLEX_ALWAYS_INLINE_FLATTEN&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a421486b2402e8c24c9c0a06fb39a3ae3">operator T</a> () const </td></tr>
<tr class="memdesc:a421486b2402e8c24c9c0a06fb39a3ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit cast to integral types. <br /></td></tr>
<tr class="separator:a421486b2402e8c24c9c0a06fb39a3ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421486b2402e8c24c9c0a06fb39a3ae3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a421486b2402e8c24c9c0a06fb39a3ae3"></a>
template&lt;class T , typename std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &gt;::type *  = (void*)NULL&gt; </td></tr>
<tr class="memitem:a421486b2402e8c24c9c0a06fb39a3ae3"><td class="memTemplItemLeft" align="right" valign="top">FLEX_ALWAYS_INLINE_FLATTEN&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a421486b2402e8c24c9c0a06fb39a3ae3">operator T</a> () const </td></tr>
<tr class="memdesc:a421486b2402e8c24c9c0a06fb39a3ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit cast to floating point types. <br /></td></tr>
<tr class="separator:a421486b2402e8c24c9c0a06fb39a3ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281b20620857a6e39a59b11f022f3d82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a281b20620857a6e39a59b11f022f3d82">operator flex_string</a> () const </td></tr>
<tr class="separator:a281b20620857a6e39a59b11f022f3d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca618256b476d098612cbca055f338cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aca618256b476d098612cbca055f338cc">operator flex_vec</a> () const </td></tr>
<tr class="separator:aca618256b476d098612cbca055f338cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17739bddcfd604d03540b65b4ce55b23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a17739bddcfd604d03540b65b4ce55b23">operator flex_nd_vec</a> () const </td></tr>
<tr class="separator:a17739bddcfd604d03540b65b4ce55b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35192e6a1e990e883bf3345a2eb87fb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a35192e6a1e990e883bf3345a2eb87fb2">operator flex_list</a> () const </td></tr>
<tr class="separator:a35192e6a1e990e883bf3345a2eb87fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e225d180ebb84bee9ff26ab508b1074"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a8e225d180ebb84bee9ff26ab508b1074">operator flex_dict</a> () const </td></tr>
<tr class="separator:a8e225d180ebb84bee9ff26ab508b1074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac314907a4ab42bdf94ddeb9404c91a7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ac314907a4ab42bdf94ddeb9404c91a7a">operator flex_date_time</a> () const </td></tr>
<tr class="separator:ac314907a4ab42bdf94ddeb9404c91a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f300b6f94f99d48bb7fc7ae69764236"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a5f300b6f94f99d48bb7fc7ae69764236">operator flex_image</a> () const </td></tr>
<tr class="separator:a5f300b6f94f99d48bb7fc7ae69764236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b7fc22bd155626bc8b17c418ade1a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a21b7fc22bd155626bc8b17c418ade1a0">operator-</a> () const </td></tr>
<tr class="separator:a21b7fc22bd155626bc8b17c418ade1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c893e29fef3aafaa4c4d65a39d72920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a4c893e29fef3aafaa4c4d65a39d72920">operator+=</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other)</td></tr>
<tr class="separator:a4c893e29fef3aafaa4c4d65a39d72920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9813117352a67df9e2d782ef0252238a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a9813117352a67df9e2d782ef0252238a">operator-=</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other)</td></tr>
<tr class="separator:a9813117352a67df9e2d782ef0252238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704fa4b401fff96130043b1bf535fa54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a704fa4b401fff96130043b1bf535fa54">operator/=</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other)</td></tr>
<tr class="separator:a704fa4b401fff96130043b1bf535fa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1864f0ceb7e763fc9f976847c8d00df6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a1864f0ceb7e763fc9f976847c8d00df6">operator%=</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other)</td></tr>
<tr class="separator:a1864f0ceb7e763fc9f976847c8d00df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8b66fb8c79d711e2ea2af24113d97a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#afe8b66fb8c79d711e2ea2af24113d97a">operator*=</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other)</td></tr>
<tr class="separator:afe8b66fb8c79d711e2ea2af24113d97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df64fbf96ae38712d316ab7ccd98fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a7df64fbf96ae38712d316ab7ccd98fee">operator+</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:a7df64fbf96ae38712d316ab7ccd98fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcd0ad296d3d0a3ca6e81f6fba4ff84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a5fcd0ad296d3d0a3ca6e81f6fba4ff84">operator-</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:a5fcd0ad296d3d0a3ca6e81f6fba4ff84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4c834d1e09a034c94a991032f245f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a2d4c834d1e09a034c94a991032f245f9">operator*</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:a2d4c834d1e09a034c94a991032f245f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb33ffd373f0f3c2d51793b12d82d2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a4eb33ffd373f0f3c2d51793b12d82d2f">operator/</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:a4eb33ffd373f0f3c2d51793b12d82d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29dc1c251759eec47497cc1117187ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ae29dc1c251759eec47497cc1117187ce">operator%</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:ae29dc1c251759eec47497cc1117187ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10d377134fb5abea9450a5ed3ba0d4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ac10d377134fb5abea9450a5ed3ba0d4d">operator==</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:ac10d377134fb5abea9450a5ed3ba0d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690de083c8f339a01d957f915a2ae61a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a690de083c8f339a01d957f915a2ae61a">operator!=</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:a690de083c8f339a01d957f915a2ae61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fdbb828cfcf386849990cb86baa33d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a12fdbb828cfcf386849990cb86baa33d">approx_equal</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:a12fdbb828cfcf386849990cb86baa33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56398d82a710752f5736eed175e5c4b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a56398d82a710752f5736eed175e5c4b4">identical</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:a56398d82a710752f5736eed175e5c4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1eb862f7f63b32d19f414d31aa0052"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aec1eb862f7f63b32d19f414d31aa0052">operator&lt;</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:aec1eb862f7f63b32d19f414d31aa0052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d5d413c609681b711c334b8ca38034"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aa6d5d413c609681b711c334b8ca38034">operator&gt;</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:aa6d5d413c609681b711c334b8ca38034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e79c71995328b08966e521d45475acb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a3e79c71995328b08966e521d45475acb">operator&lt;=</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:a3e79c71995328b08966e521d45475acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab620164ed938167af8830887cbf31126"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ab620164ed938167af8830887cbf31126">operator&gt;=</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const </td></tr>
<tr class="separator:ab620164ed938167af8830887cbf31126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e54f7115fd9b25fa1e30d1174da0f8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e54f7115fd9b25fa1e30d1174da0f8c"></a>
<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a6e54f7115fd9b25fa1e30d1174da0f8c">operator++</a> ()</td></tr>
<tr class="memdesc:a6e54f7115fd9b25fa1e30d1174da0f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement. Equivalent to (*this)+=1. <br /></td></tr>
<tr class="separator:a6e54f7115fd9b25fa1e30d1174da0f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe906e7e6f9293cfcb7c488dfd65a2d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe906e7e6f9293cfcb7c488dfd65a2d9"></a>
<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#afe906e7e6f9293cfcb7c488dfd65a2d9">operator++</a> (int)</td></tr>
<tr class="memdesc:afe906e7e6f9293cfcb7c488dfd65a2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement. Equivalent to (*this)+=1, returning a copy of the previous value. <br /></td></tr>
<tr class="separator:afe906e7e6f9293cfcb7c488dfd65a2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3f59ebff0e68f077fde12526c32dfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf3f59ebff0e68f077fde12526c32dfb"></a>
<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#adf3f59ebff0e68f077fde12526c32dfb">operator--</a> ()</td></tr>
<tr class="memdesc:adf3f59ebff0e68f077fde12526c32dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement. Equivalent to (*this)-=1. <br /></td></tr>
<tr class="separator:adf3f59ebff0e68f077fde12526c32dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8a72aa03f1d62e439e9a0a9ffcdf6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b8a72aa03f1d62e439e9a0a9ffcdf6b"></a>
<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a1b8a72aa03f1d62e439e9a0a9ffcdf6b">operator--</a> (int)</td></tr>
<tr class="memdesc:a1b8a72aa03f1d62e439e9a0a9ffcdf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement. Equivalent to (*this)-=1, returning a copy of the previous value. <br /></td></tr>
<tr class="separator:a1b8a72aa03f1d62e439e9a0a9ffcdf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca31b8b8826a3db141eda3e832fec4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afca31b8b8826a3db141eda3e832fec4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#afca31b8b8826a3db141eda3e832fec4a">operator-</a> (const T &amp;other) const </td></tr>
<tr class="separator:afca31b8b8826a3db141eda3e832fec4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71beb2e603618499ec5db2c1fa27cb9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa71beb2e603618499ec5db2c1fa27cb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aa71beb2e603618499ec5db2c1fa27cb9">operator+</a> (const T &amp;other) const </td></tr>
<tr class="separator:aa71beb2e603618499ec5db2c1fa27cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acf1e2f574773e7371e346217bc0dea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7acf1e2f574773e7371e346217bc0dea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a7acf1e2f574773e7371e346217bc0dea">operator/</a> (const T &amp;other) const </td></tr>
<tr class="separator:a7acf1e2f574773e7371e346217bc0dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645ac3d337b14e47eca54bdb339a6b88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a645ac3d337b14e47eca54bdb339a6b88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a645ac3d337b14e47eca54bdb339a6b88">operator%</a> (const T &amp;other) const </td></tr>
<tr class="separator:a645ac3d337b14e47eca54bdb339a6b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4a9112990d51cc526f9e9dfcf3340e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe4a9112990d51cc526f9e9dfcf3340e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#abe4a9112990d51cc526f9e9dfcf3340e">operator*</a> (const T &amp;other) const </td></tr>
<tr class="separator:abe4a9112990d51cc526f9e9dfcf3340e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5e0af49b011a19bccbc85eb95f041a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d5e0af49b011a19bccbc85eb95f041a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a5d5e0af49b011a19bccbc85eb95f041a">operator==</a> (const T &amp;other) const </td></tr>
<tr class="separator:a5d5e0af49b011a19bccbc85eb95f041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ca50913b2aac23a657cf7eaec53546"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22ca50913b2aac23a657cf7eaec53546"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a22ca50913b2aac23a657cf7eaec53546">operator!=</a> (const T &amp;other) const </td></tr>
<tr class="separator:a22ca50913b2aac23a657cf7eaec53546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa068d06b9b02a181e2dcf45c55986c52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa068d06b9b02a181e2dcf45c55986c52"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aa068d06b9b02a181e2dcf45c55986c52">operator&lt;</a> (const T &amp;other) const </td></tr>
<tr class="separator:aa068d06b9b02a181e2dcf45c55986c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e778b7c024d341b5439a6c1193848a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e778b7c024d341b5439a6c1193848a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a2e778b7c024d341b5439a6c1193848a1">operator&gt;</a> (const T &amp;other) const </td></tr>
<tr class="separator:a2e778b7c024d341b5439a6c1193848a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8039ac9c6d74ecc5a729a085b07718f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8039ac9c6d74ecc5a729a085b07718f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a8039ac9c6d74ecc5a729a085b07718f6">operator&lt;=</a> (const T &amp;other) const </td></tr>
<tr class="separator:a8039ac9c6d74ecc5a729a085b07718f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af54c88bab4f1925d97241aef421afc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1af54c88bab4f1925d97241aef421afc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a1af54c88bab4f1925d97241aef421afc">operator&gt;=</a> (const T &amp;other) const </td></tr>
<tr class="separator:a1af54c88bab4f1925d97241aef421afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628c2e2d0174ef1812abe574ad1531f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flexible__type__types.html#gadcf31f61cc0e0b82bdc9d886fa163e86">flex_float</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a628c2e2d0174ef1812abe574ad1531f1">operator[]</a> (size_t index)</td></tr>
<tr class="separator:a628c2e2d0174ef1812abe574ad1531f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6f7936c64e2c2889f98714d68675eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__group__flexible__type__types.html#gadcf31f61cc0e0b82bdc9d886fa163e86">flex_float</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aca6f7936c64e2c2889f98714d68675eb">operator[]</a> (size_t index) const </td></tr>
<tr class="separator:aca6f7936c64e2c2889f98714d68675eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6235d0d52a801d179134e4a808b17c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a6235d0d52a801d179134e4a808b17c87">array_at</a> (size_t index)</td></tr>
<tr class="separator:a6235d0d52a801d179134e4a808b17c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f99c4389e3b7efce7d0cd6637eac961"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a0f99c4389e3b7efce7d0cd6637eac961">array_at</a> (size_t index) const </td></tr>
<tr class="separator:a0f99c4389e3b7efce7d0cd6637eac961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b446fd5ac6663956f3cd0b1eac242ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a0b446fd5ac6663956f3cd0b1eac242ac">dict_at</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;index)</td></tr>
<tr class="separator:a0b446fd5ac6663956f3cd0b1eac242ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be591554c1a9b534c0492e01a253c18"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a0be591554c1a9b534c0492e01a253c18">dict_at</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;index) const </td></tr>
<tr class="separator:a0be591554c1a9b534c0492e01a253c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdadc21fd950309e4ff337ba4ae6fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#aecdadc21fd950309e4ff337ba4ae6fbe">operator()</a> (size_t index)</td></tr>
<tr class="separator:aecdadc21fd950309e4ff337ba4ae6fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ad7aa2b7d784be1ddc2a379524c149"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ae3ad7aa2b7d784be1ddc2a379524c149">operator()</a> (size_t index) const </td></tr>
<tr class="separator:ae3ad7aa2b7d784be1ddc2a379524c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6527c96210377a9a7dc6695c0ae10121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a6527c96210377a9a7dc6695c0ae10121">operator()</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;index)</td></tr>
<tr class="separator:a6527c96210377a9a7dc6695c0ae10121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51179674cad7e7e55e9e03be5655f523"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a51179674cad7e7e55e9e03be5655f523">operator()</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;index) const </td></tr>
<tr class="separator:a51179674cad7e7e55e9e03be5655f523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8bce670e9c41eea98fb7ede6fdd02a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a4c8bce670e9c41eea98fb7ede6fdd02a">size</a> () const </td></tr>
<tr class="separator:a4c8bce670e9c41eea98fb7ede6fdd02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2623844c41c84a7dd0e5d81c462959"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a8e2623844c41c84a7dd0e5d81c462959">resize</a> (size_t s)</td></tr>
<tr class="separator:a8e2623844c41c84a7dd0e5d81c462959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1973ae42bf80dcbba010cc466d8b541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ab1973ae42bf80dcbba010cc466d8b541">clear</a> ()</td></tr>
<tr class="separator:ab1973ae42bf80dcbba010cc466d8b541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3897d8ed688fbc448860e2cdbe265e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a8d3897d8ed688fbc448860e2cdbe265e">erase</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;index)</td></tr>
<tr class="separator:a8d3897d8ed688fbc448860e2cdbe265e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2f2a1395c3e67b59df7f3dcdbb3a6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a6a2f2a1395c3e67b59df7f3dcdbb3a6e">push_back</a> (<a class="el" href="group__group__flexible__type__types.html#gadcf31f61cc0e0b82bdc9d886fa163e86">flex_float</a> i)</td></tr>
<tr class="separator:a6a2f2a1395c3e67b59df7f3dcdbb3a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb243d623f5b4a0b349a772a8f935b7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#adb243d623f5b4a0b349a772a8f935b7e">push_back</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;i)</td></tr>
<tr class="separator:adb243d623f5b4a0b349a772a8f935b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f51a38d151a5448f99cf683389eeee1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a3f51a38d151a5448f99cf683389eeee1">save</a> (<a class="el" href="classturi_1_1oarchive.html">oarchive</a> &amp;oarc) const </td></tr>
<tr class="separator:a3f51a38d151a5448f99cf683389eeee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63ce0df0cf3733721bcd7638710a07f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ad63ce0df0cf3733721bcd7638710a07f">load</a> (<a class="el" href="classturi_1_1iarchive.html">iarchive</a> &amp;iarc)</td></tr>
<tr class="separator:ad63ce0df0cf3733721bcd7638710a07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed015421ddeabba08878759a6fdb9cf"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:a7ed015421ddeabba08878759a6fdb9cf"><td class="memTemplItemLeft" align="right" valign="top">FLEX_ALWAYS_INLINE_FLATTEN auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a7ed015421ddeabba08878759a6fdb9cf">apply_visitor</a> (Visitor visitor) const  -&gt; decltype(visitor(prototype_flex_int))</td></tr>
<tr class="separator:a7ed015421ddeabba08878759a6fdb9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8abf937c22b3c61c903b2864c132c30"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab8abf937c22b3c61c903b2864c132c30"></a>
template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:ab8abf937c22b3c61c903b2864c132c30"><td class="memTemplItemLeft" align="right" valign="top">FLEX_ALWAYS_INLINE_FLATTEN auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#ab8abf937c22b3c61c903b2864c132c30">apply_visitor</a> (Visitor visitor, const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;other) const  -&gt; decltype(visitor(prototype_flex_int, <a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>()))</td></tr>
<tr class="memdesc:ab8abf937c22b3c61c903b2864c132c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload <br /></td></tr>
<tr class="separator:ab8abf937c22b3c61c903b2864c132c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a34f12dac35bf0035146408baa22bbb86"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34f12dac35bf0035146408baa22bbb86"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_integral&lt; T &gt;::value &amp;&amp;!std::is_floating_point&lt; T &gt;::value, T &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a34f12dac35bf0035146408baa22bbb86">to</a> () const </td></tr>
<tr class="separator:a34f12dac35bf0035146408baa22bbb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6006917f1ac6d8cf94bd772dc9411aaa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6006917f1ac6d8cf94bd772dc9411aaa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; T &gt;::value, T &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a6006917f1ac6d8cf94bd772dc9411aaa">to</a> () const </td></tr>
<tr class="separator:a6006917f1ac6d8cf94bd772dc9411aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6b808f8432454170e91bc79478d5b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c6b808f8432454170e91bc79478d5b0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value, T &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html#a6c6b808f8432454170e91bc79478d5b0">to</a> () const </td></tr>
<tr class="separator:a6c6b808f8432454170e91bc79478d5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is an automatic, self-managing union between the following types.</p><ul>
<li><a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a></li>
<li><a class="el" href="group__group__flexible__type__types.html#gadcf31f61cc0e0b82bdc9d886fa163e86">flex_float</a></li>
<li><a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a></li>
<li><a class="el" href="group__group__flexible__type__types.html#gac2900ffa5e2fef35d706e307db74d859">flex_nd_vec</a></li>
<li><a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a></li>
<li><a class="el" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a></li>
<li><a class="el" href="group__group__flexible__type__types.html#ga40bb1656bebeb5ab0e3cd138c09e5995">flex_image</a></li>
<li><a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a></li>
</ul>
<p>It is nearly every operator overloaded which allows it to behave very similarly to python data types.</p>
<p>The internal representation of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is simply:</p><ul>
<li>8 bytes of (flex_int, flex_double, flex_string* and flex_vec*)</li>
<li>1 byte tag corresponding to a member of the enumeration <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a></li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f = 1;</div><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f2 = 2;</div><div class="line">f += f2; <span class="comment">// f is now 3</span></div><div class="line">f += 1; <span class="comment">// f is now 4</span></div><div class="line"><span class="keywordflow">if</span> (f == 4) std::cout &lt;&lt; <span class="stringliteral">&quot;!&quot;</span>;</div><div class="line">f = float(f); <span class="comment">// convert f to float</span></div><div class="line">f += 2.5; <span class="comment">// f is now 6.5</span></div><div class="line"></div><div class="line"><span class="comment">// convert to string</span></div><div class="line">f = std::string(f); f is now <span class="stringliteral">&quot;5&quot;</span></div><div class="line">f += <span class="stringliteral">&quot;hello&quot;</span>;  <span class="comment">// f is now &quot;5hello&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// vector test</span></div><div class="line">f = {1.1, 2.2};  <span class="comment">// f is now a vector if {1.1, 2.2}</span></div><div class="line">f.push_back(3.3); <span class="comment">// f is now a vector if {1.1, 2.2, 3.3}</span></div><div class="line">f.clear();  <span class="comment">// f is now an empty vector</span></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> i = 0;i &lt; 10; ++i) {</div><div class="line">  f.push_back(i);</div><div class="line">}</div><div class="line"><span class="comment">// f is now a vector from 1.0 to 10.0</span></div><div class="line"></div><div class="line">f = std::string(<span class="stringliteral">&quot;hello&quot;</span>); <span class="comment">// f is now a string again</span></div><div class="line">f.mutable_get&lt;<a class="code" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a>&gt;() = <span class="stringliteral">&quot;boo&quot;</span>;  <span class="comment">// this gets a reference to the underlying storage</span></div><div class="line">f.mutable_get&lt;<a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>&gt;() = 5; <span class="comment">// this will implode at runtime</span></div></div><!-- fragment --><h3>Type Information and Contents</h3>
<p>The type information for the contents of the flexible type can be obtained in three ways.</p><ul>
<li><a class="el" href="classturi_1_1flexible__type.html#aada3ceebb28d5983567e22a3ff5ec559">flexible_type::get_type()</a> Returns a member of the enumeration flex_type_enum</li>
<li><a class="el" href="classturi_1_1flexible__type.html#ace41cf48dbbaf4f135d162d4526f48b9">flexible_type::which()</a> Returns a number corresponding to size_t(get_type()) Provided for compatibility with boost::variant</li>
<li><a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">flexible_type::type()</a> Returns a std::type_index object corresponding to the typeid of the stored object. Provided for compatibility with boost::variant</li>
</ul>
<p>Knowing the type of the contents, the <a class="el" href="classturi_1_1flexible__type.html#a9cb5ea486620ffdd6f5aef446d3d304b">flexible_type::get()</a> function can be used to extract a reference to the content.</p>
<div class="fragment"><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f(5);</div><div class="line">f.mutable_get&lt;<a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>&gt;() = 10;</div><div class="line">std::cout &lt;&lt; f.get&lt;<a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>&gt;();</div></div><!-- fragment --><p>If the incorrect type is provided, the <a class="el" href="classturi_1_1flexible__type.html#a9cb5ea486620ffdd6f5aef446d3d304b">flexible_type::get()</a> function will throw a runtime exception.</p>
<p>A large number of casting operators are also provided and these work as expected. </p><div class="fragment"><div class="line">(int)f    <span class="comment">// casts doubles and integers to a integer. strings and vectors will fail.</span></div><div class="line">(<span class="keywordtype">float</span>)f  <span class="comment">// casts doubles and integers to a double . strings and vectors will fail.</span></div><div class="line">(string)f <span class="comment">// returns a printable string representation of all types.</span></div></div><!-- fragment --><p>However, there are certain ambiguous cases whch do cause issues when using the explicit cast so, the <a class="el" href="classturi_1_1flexible__type.html#a34f12dac35bf0035146408baa22bbb86">flexible_type::to()</a> function is generally preferred: </p><div class="fragment"><div class="line">f.to&lt;<span class="keywordtype">int</span>&gt;()</div><div class="line">f.to&lt;<span class="keywordtype">float</span>&gt;()</div><div class="line">f.to&lt;<span class="keywordtype">string</span>&gt;()</div></div><!-- fragment --><h3>Undefined</h3>
<p>A special undefined type is provided which is useful for identifying missing values (or the None value/type in Python). Such a value can be created using: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f = flex_undefined();</div><div class="line"><span class="comment">// or</span></div><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f = <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>;</div></div><!-- fragment --><h3>Operators</h3>
<p>Practically every operator is overloaded, and the behaviors are relatively intuitive. See the documentation for each operator to determine legality. There are also special operator overloads to simplify access to the vector. For instance, <a class="el" href="classturi_1_1flexible__type.html#a628c2e2d0174ef1812abe574ad1531f1">flexible_type::operator[]</a>, <a class="el" href="classturi_1_1flexible__type.html#ab1973ae42bf80dcbba010cc466d8b541">flexible_type::clear()</a> and <a class="el" href="classturi_1_1flexible__type.html#a6a2f2a1395c3e67b59df7f3dcdbb3a6e">flexible_type::push_back()</a>. In all cases, a runtime exception is thrown if an invalid type combination is encountered.</p>
<p>The basic rule of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is that the internal type is always preserved. Only an assignment can change the internal type of the object. Also, for consistency, operations between two flexible types always return a type corresponding to the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> on the left of the operation. i.e. </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f_int(5);</div><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f_float(2.1);</div><div class="line"></div><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f_res = f_int * f_float;</div><div class="line"><span class="comment">// the type of f_res is an integer</span></div><div class="line"></div><div class="line">f_res = f_float * f_int;</div><div class="line"><span class="comment">// the type of f_res is a float</span></div></div><!-- fragment --><p>This is true also for operations where the 2nd argument is an arbitrary type.</p>
<div class="fragment"><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f_float(2.1);</div><div class="line"></div><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f_res = f_float + 2;</div><div class="line"><span class="comment">// the type of f_res is a float</span></div></div><!-- fragment --><p>The only exception to the rule is when the first argument is not a flexible type and the 2nd argument is a flexible type. In which case, the return type is the a flexible type corresponding to the type on the right.</p>
<div class="fragment"><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f_float(2.1);</div><div class="line"></div><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f_res = 2 + f_float;</div><div class="line"><span class="comment">// the type of f_res is a float</span></div></div><!-- fragment --><p>In summary: Where flexible_type_A is used to denote a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> where the internal contents are of type A, and OP is an arbitrary operator,</p><ul>
<li>flexible_type_A OP flexible_type_B ==&gt; flexible_type_A</li>
<li>flexible_type_A OP T ==&gt; flexible_type_A</li>
<li>T OP flexible_type_A ==&gt; flexible_type_A</li>
</ul>
<p>This does mean that the binary operators are not commutative when performed across different types. ex:</p><ul>
<li>(integer * float) produces an integer</li>
<li>(float * integer) produces an float</li>
</ul>
<h3>Visitors</h3>
<p>Of the most powerful feature of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>, is the visitor mechanism which is designed in a very similar manner to that of the boost::variant. See flexible_type::apply_visitor(Visitor) or <a class="el" href="classturi_1_1flexible__type.html#a7e0c0492299b1836669fbc82df082cbd">flexible_type::apply_mutating_visitor(Visitor)</a> for details.</p>
<h3>Capability Checking</h3>
<p>Sometimes it can be useful to be able to query (at runtime, or at compile time) whether certain <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> operations will succeed or not. A number of useful functions are provided.</p>
<p>Runtime Capability Queries:</p><ul>
<li><a class="el" href="namespaceturi.html#a95083e63ff7e20e03de8833909a699f1">flex_type_has_binary_op</a> . Checks if binary operators between certain types are supported.</li>
<li><a class="el" href="namespaceturi.html#a5163d800c1557ce946f305d93665dbc1">flex_type_is_convertible</a> . Checks if certain type conversions can be performed.</li>
</ul>
<p>Compile-time Capability Queries:</p><ul>
<li><a class="el" href="structturi_1_1is__valid__flex__type.html">is_valid_flex_type</a> . Checks at compile time if a type is one of the internal <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> types.</li>
<li><a class="el" href="structturi_1_1enum__to__type.html">enum_to_type</a> . Gets the internal type from an enumeration value.</li>
<li><a class="el" href="structturi_1_1type__to__enum.html">type_to_enum</a> . Gets the enumeration value from the internal type.</li>
<li><a class="el" href="structturi_1_1has__direct__conversion__to__flexible__type.html">has_direct_conversion_to_flexible_type</a> . Can be casted to a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>.</li>
</ul>
<h3>Performance</h3>
<p>Performance of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is generally extremely good. With modern compilers (sometimes with inlining limit bumped up) can sometimes produce code which is equivalent to, or runs as fast as the version using native types especially if certain type constraints are set-up before hand. For instance:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (x.get_type() == <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a5d5cd46919fa987731fb2edefe0f2a0c">flex_type_enum::INTEGER</a>) {</div><div class="line">  ... <span class="keywordflow">do</span> a whole bunch of stuff on x ...</div><div class="line">}</div></div><!-- fragment --><p>Integers and Floating point values are stored in-place inside the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>. All other types are somewhat more complex (strings, vectors etc) and are optimized by copy on write. i.e. </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> a = <span class="stringliteral">&quot;hello world&quot;</span>;</div><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> b = a;</div></div><!-- fragment --><p> Both b and a will reference the same "hello world" until either one of them gets mutated. As such, all inplace operations (<a class="el" href="classturi_1_1flexible__type.html#a9cb5ea486620ffdd6f5aef446d3d304b">get()</a>, apply_visitor(Visitor)) require const, but also have a mutating version (mutating_get(), <a class="el" href="classturi_1_1flexible__type.html#a7e0c0492299b1836669fbc82df082cbd">apply_mutating_visitor(Visitor)</a>). </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l00251">251</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab7ced47636ee238dd993324b39ad6610"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE turi::flexible_type::flexible_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default Constructor. By default constructs an integer of value 0. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01646">1646</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2c7fa8c01d6db018be39dd30e215799"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">turi::flexible_type::flexible_type </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from initializer List. Makes a vector </p>

</div>
</div>
<a class="anchor" id="a51a6ea5c9546e13b27af4d182ffa93a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::~flexible_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01657">1657</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a171b4d172f56f2423cfe1e9a6ede1b28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::flexible_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Assigns this to a copy of other. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01665">1665</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa9993462e293cbc5f2704f7ca0e11ddc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::flexible_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Assigns this to a copy of other. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01670">1670</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa01bd195ee79870fcb478c502c344ba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">turi::flexible_type::flexible_type </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structturi_1_1has__direct__conversion__to__flexible__type.html">has_direct_conversion_to_flexible_type</a>&lt; T &gt;::value &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Assigns this from arbitrary type. See <a class="el" href="classturi_1_1flexible__type.html#af53b3520c60da7f16acf3c589362cd1c">flexible_type::operator=</a> </p>

</div>
</div>
<a class="anchor" id="a1f079870085a1cf1ef7c388924e3a6d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::flexible_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Just assigns myself to the other, destroying the other. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01681">1681</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a348e5802b07129488147b0f0c1d9645e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::flexible_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. (Const overload. Required since the T&amp;&amp; universal reference has a tendency to capture everything) </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01687">1687</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe86bf41dac86c9285d175c6f220056d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">turi::flexible_type::flexible_type </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; <a class="el" href="structturi_1_1has__direct__conversion__to__flexible__type.html">has_direct_conversion_to_flexible_type</a>&lt; typename std::remove_reference&lt; T &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> &gt;::value &gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move constructor. Assigns this from arbitrary type </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7e0c0492299b1836669fbc82df082cbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto turi::flexible_type::apply_mutating_visitor </td>
          <td>(</td>
          <td class="paramtype">Visitor&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> -&gt;  decltype(visitor(prototype_flex_int))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Executes an apply visitor on the flexible type. The apply visitor object must have a function void operator()(T&amp; t) for every type T the flexible type can contain. The operator() function can be itself templated for convenience. For instance, the following visitor will add the value "1" to the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> if the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> contains an integer, and will ignore otherwise. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>add_one_to_integer {</div><div class="line">  <span class="comment">// do nothing</span></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classturi_1_1flexible__type.html#aecdadc21fd950309e4ff337ba4ae6fbe">operator()</a>(T&amp; t) { }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classturi_1_1flexible__type.html#aecdadc21fd950309e4ff337ba4ae6fbe">operator()</a>(<a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>&amp; t) { t += 1; }</div><div class="line">};</div></div><!-- fragment --><p>The visitor can return values but all versions of the operator() function must return exactly the same type. For instance:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>add_one_and_return {</div><div class="line">  <span class="comment">// do nothing</span></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">  <span class="keywordtype">int</span> <a class="code" href="classturi_1_1flexible__type.html#aecdadc21fd950309e4ff337ba4ae6fbe">operator()</a>(T&amp; t) { <span class="keywordflow">return</span> 0; }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> <a class="code" href="classturi_1_1flexible__type.html#aecdadc21fd950309e4ff337ba4ae6fbe">operator()</a>(<a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>&amp; t) { t += 1; <span class="keywordflow">return</span> t; }</div><div class="line">};</div></div><!-- fragment --><p>In which case, apply_mutating_visitor will return a value: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = flex.apply_mutating_visitor(add_one_and_return());</div></div><!-- fragment --><p>This function assumes that the function will mutate the value. If the function does not mutate the value, the alternative apply_visitor(Visitor) should be used. </p>

</div>
</div>
<a class="anchor" id="aadb2f369d84f4fba671acbcfce09aa3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto turi::flexible_type::apply_mutating_visitor </td>
          <td>(</td>
          <td class="paramtype">Visitor&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(visitor(prototype_flex_int, <a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>()))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Executes a binary visitor on the flexible type. The binary apply visitor object must have a function void operator()(T&amp; t, const U&amp; u) for every pair of types T and U the flexible type can contain. The operator() function can be itself templated for convenience. For instance, the following visitor will do a += if both types are integer. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>add_one_to_integer {</div><div class="line">  <span class="comment">// do nothing</span></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classturi_1_1flexible__type.html#aecdadc21fd950309e4ff337ba4ae6fbe">operator()</a>(T&amp; t, <span class="keyword">const</span> U&amp; u)<span class="keyword"> const </span>{ }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classturi_1_1flexible__type.html#aecdadc21fd950309e4ff337ba4ae6fbe">operator()</a>(<a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>&amp; t, <span class="keyword">const</span> <a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>&amp; u)<span class="keyword"> const </span>{ t += u; }</div><div class="line">};</div></div><!-- fragment --><p>Just like the unary apply_mutating_visitor. the visitor can return a value, but all versions of operator() must return an identical type.</p>
<p>This function assumes that the function will mutate the value. If the function does not mutate the value, the alternative apply_visitor(Visitor, const flexible_type&amp;) should be used. </p>

</div>
</div>
<a class="anchor" id="a2e1e483031a1fd5fa79b4199e65cdc6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto turi::flexible_type::apply_visitor </td>
          <td>(</td>
          <td class="paramtype">Visitor&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const -&gt;  decltype(visitor(prototype_flex_int))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Executes a non-mutating apply visitor on the flexible type. The apply visitor object must have a function void operator()(const T&amp; t) for every type T the flexible type can contain. The operator() function can be itself templated for convenience. For instance, the following visitor will return one plus the value of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> if it contains an integer, or returns 0 otherwise.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>non_mutating_add_one {</div><div class="line">  <span class="comment">// do nothing</span></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">  <span class="keywordtype">int</span> <a class="code" href="classturi_1_1flexible__type.html#aecdadc21fd950309e4ff337ba4ae6fbe">operator()</a>(T&amp; t) { <span class="keywordflow">return</span> 0; }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> <a class="code" href="classturi_1_1flexible__type.html#aecdadc21fd950309e4ff337ba4ae6fbe">operator()</a>(<a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>&amp; t) { <span class="keywordflow">return</span> t + 1; }</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = flex.apply_visitor(non_mutating_add_one());</div></div><!-- fragment --><p>This function requires that the function does not mutate the value. If the function does mutate the value, the alternative <a class="el" href="classturi_1_1flexible__type.html#a7e0c0492299b1836669fbc82df082cbd">apply_mutating_visitor(Visitor)</a> should be used. </p>

</div>
</div>
<a class="anchor" id="a12122b8e581e5ab73f7025414fbf4ed0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto turi::flexible_type::apply_visitor </td>
          <td>(</td>
          <td class="paramtype">Visitor&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt;  decltype(visitor(prototype_flex_int, <a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>()))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Executes a binary visitor on the flexible type. The binary apply visitor object must have a function void operator()(const T&amp; t, const U&amp; u) for every pair of types T and U the flexible type can contain. The operator() function can be itself templated for convenience. For instance, the following visitor will return the sum of both values if only if both types are integral. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>add_one_to_integer {</div><div class="line">  <span class="comment">// do nothing</span></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div><div class="line">  <span class="keywordtype">int</span> <a class="code" href="classturi_1_1flexible__type.html#aecdadc21fd950309e4ff337ba4ae6fbe">operator()</a>(T&amp; t, <span class="keyword">const</span> U&amp; u)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> <a class="code" href="classturi_1_1flexible__type.html#aecdadc21fd950309e4ff337ba4ae6fbe">operator()</a>(<a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>&amp; t, <span class="keyword">const</span> <a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>&amp; u)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> t + u; }</div><div class="line">};</div></div><!-- fragment --><p>Just like the unary apply_visitor. the visitor can return a value, but all versions of operator() must return an identical type.</p>
<p>This function assumes that the function will not mutate the value. If the function does mutate the value, the alternative <a class="el" href="classturi_1_1flexible__type.html#aadb2f369d84f4fba671acbcfce09aa3c">apply_mutating_visitor(Visitor, const flexible_type&amp;)</a> should be used. </p>

</div>
</div>
<a class="anchor" id="a7ed015421ddeabba08878759a6fdb9cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN auto turi::flexible_type::apply_visitor </td>
          <td>(</td>
          <td class="paramtype">Visitor&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const -&gt; decltype(visitor(prototype_flex_int)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01924">1924</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a12fdbb828cfcf386849990cb86baa33d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN bool turi::flexible_type::approx_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares if two flexible types are equivalent in value. i.e. permitting comparisons between integer and floating point types. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02208">2208</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6235d0d52a801d179134e4a808b17c87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::array_at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List indexing operator.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a list. Returns a reference to the 'index' entry in the vector.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02319">2319</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f99c4389e3b7efce7d0cd6637eac961"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::array_at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List indexing operator.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a list. Returns a reference to the 'index' entry in the vector.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02325">2325</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab1973ae42bf80dcbba010cc466d8b541"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN void turi::flexible_type::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array clear function.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a vector, clears the vector.</li>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a recursive object, clears the recursive array</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02431">2431</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b446fd5ac6663956f3cd0b1eac242ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::dict_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>dict indexing operator.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a dictionary, Returns a reference to the 'index' entry in the dict array.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02330">2330</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0be591554c1a9b534c0492e01a253c18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::dict_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>dict indexing operator.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a dictionary, Returns a reference to the 'index' entry in the dict array.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02345">2345</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d3897d8ed688fbc448860e2cdbe265e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::flexible_type::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dict element erase function.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a dict, erases the element indexed by the index value.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

</div>
</div>
<a class="anchor" id="a9cb5ea486620ffdd6f5aef446d3d304b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; turi::flexible_type::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a const reference to the value stored inside the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>. T must be one of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> types. All other types will result in a compile type assertion failure. If the stored type does not match T, it will result in a run-time assertion failure. </p>

</div>
</div>
<a class="anchor" id="addb5fe9271a6d80e4fdad1444fcec707"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE std::pair&lt; <a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>, int32_t &gt; turi::flexible_type::get_date_time_as_timestamp_and_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Where the current <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> contains a datetime type, returns the datetime as a pair of posix timestamp value and its timezone offset.</p>
<p>The timezone offset is integral in <b>fifteen-minute</b> increments. i.e. a offset of 8 means timezone +2 </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01448">1448</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8bce4a1134a84369aa8b47d061277c5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE int32_t turi::flexible_type::get_date_time_microsecond </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the date_time microsecond value </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01455">1455</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aada3ceebb28d5983567e22a3ff5ec559"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> FLEX_ALWAYS_INLINE turi::flexible_type::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of the underlying storage </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01863">1863</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a577751f04f2c83f55daa41f33eac08c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE size_t turi::flexible_type::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a 64 bit hash of the underlying value, switched on type. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01876">1876</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad96c79e7593d92dd82edeaff94209999"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE uint128_t turi::flexible_type::hash128 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a 128 bit hash of the underlying value, switched on type. This hash is appropriate for unique identification. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01880">1880</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a56398d82a710752f5736eed175e5c4b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN bool turi::flexible_type::identical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like operator== but requires also types to be equivalent. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02212">2212</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a696f154a155e87d54c5b837b863504de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::flexible_type::is_na </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the value is considered a "missing value" or NA. </p>

</div>
</div>
<a class="anchor" id="ab1a682f12baf1051f447c67ba536190e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::flexible_type::is_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the value is equal to this type's equivalent of zero. </p>

</div>
</div>
<a class="anchor" id="ad63ce0df0cf3733721bcd7638710a07f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE void turi::flexible_type::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1iarchive.html">iarchive</a> &amp;&#160;</td>
          <td class="paramname"><em>iarc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deserializer. Loads the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> from an archive object. Note that the type of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> may change. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02485">2485</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87d458fcb9c26aeb86e4bb97d9c438b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; turi::flexible_type::mutable_get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a modifiable reference to the value stored inside the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>. T must be one of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> types. All other types will result in a compile type assertion failure. If the stored type does not match T, it will result in a run-time assertion failure. </p>

</div>
</div>
<a class="anchor" id="ac314907a4ab42bdf94ddeb9404c91a7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::operator <a class="el" href="structturi_1_1flex__date__time.html">flex_date_time</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implicit cast to <a class="el" href="structturi_1_1flex__date__time.html">flex_date_time</a> </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02117">2117</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e225d180ebb84bee9ff26ab508b1074"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::operator <a class="el" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implicit cast to vector&lt;pair&lt;flexible_type, flexible_type&gt;&gt; </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02113">2113</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f300b6f94f99d48bb7fc7ae69764236"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::operator <a class="el" href="group__group__flexible__type__types.html#ga40bb1656bebeb5ab0e3cd138c09e5995">flex_image</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implicit cast to flex_image </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02121">2121</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35192e6a1e990e883bf3345a2eb87fb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::operator <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implicit cast to vector&lt;flexible_type&gt; </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02109">2109</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17739bddcfd604d03540b65b4ce55b23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::operator <a class="el" href="group__group__flexible__type__types.html#gac2900ffa5e2fef35d706e307db74d859">flex_nd_vec</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implicit cast to ndarray&lt;double&gt; </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02105">2105</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a281b20620857a6e39a59b11f022f3d82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::operator <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implicit cast to string </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02097">2097</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca618256b476d098612cbca055f338cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN turi::flexible_type::operator <a class="el" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implicit cast to vector&lt;double&gt; </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02101">2101</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a690de083c8f339a01d957f915a2ae61a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN bool turi::flexible_type::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares if two flexible types are not equivalent in value. i.e. permitting comparisons between integer and floating point types. Same as <a class="el" href="classturi_1_1flexible__type.html#a12fdbb828cfcf386849990cb86baa33d">flexible_type::approx_equal</a> </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02204">2204</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a22ca50913b2aac23a657cf7eaec53546"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool turi::flexible_type::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality comparison operator with arbitrary type. Equivalent to (*this) != (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>)(other); </p>

</div>
</div>
<a class="anchor" id="ae29dc1c251759eec47497cc1117187ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::flexible_type::operator% </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modulus operator. Equivalent to </p><div class="fragment"><div class="line">a = (*this);</div><div class="line">a %= otrer;</div><div class="line"><span class="keywordflow">return</span> a;</div></div><!-- fragment --><p>Note that unlike regular C++ typing rules, the resultant type is always the type of the left hand side. i.e. int + float = int, and float + int = float. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02191">2191</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a645ac3d337b14e47eca54bdb339a6b88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::flexible_type::operator% </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modulos operator with arbitrary type. Equivalent to (*this) % (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>)(other); </p>

</div>
</div>
<a class="anchor" id="a1864f0ceb7e763fc9f976847c8d00df6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator%= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>mod-equal operator.</p><ul>
<li>If both are numeric types (int / float), the %= will behave as expected.</li>
<li>If the left hand side is a vector, and right hand side is an int/float, the right hand side value will be divided from each value in the vector.</li>
<li>All other conditions will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02152">2152</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aecdadc21fd950309e4ff337ba4ae6fbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List indexing operator.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a list or dict Returns a reference to the 'index' entry in the vector.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02357">2357</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3ad7aa2b7d784be1ddc2a379524c149"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List indexing operator.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a list or dict, Returns a reference to the 'index' entry in the vector.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02369">2369</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6527c96210377a9a7dc6695c0ae10121"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DIct indexing operator.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a dict, Returns a reference to the 'index' entry in the dict array.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02379">2379</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51179674cad7e7e55e9e03be5655f523"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dict indexing operator.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a dict, Returns a reference to the 'index' entry in the dict array.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02391">2391</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d4c834d1e09a034c94a991032f245f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::flexible_type::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication operator. Equivalent to </p><div class="fragment"><div class="line">a = (*this);</div><div class="line">a *= other;</div><div class="line"><span class="keywordflow">return</span> a;</div></div><!-- fragment --><p>Note that unlike regular C++ typing rules, the resultant type is always the type of the left hand side. i.e. int + float = int, and float + int = float. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02176">2176</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe4a9112990d51cc526f9e9dfcf3340e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::flexible_type::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication operator with arbitrary type. Equivalent to (*this) * (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>)(other); </p>

</div>
</div>
<a class="anchor" id="afe8b66fb8c79d711e2ea2af24113d97a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>times-equal operator.</p><ul>
<li>If both are numeric types (int / float), the *= will behave as expected.</li>
<li>If the left hand side is a vector, and right hand side is an int/float, the right hand side value will be multiplied to each value in the vector.</li>
<li>All other conditions will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02157">2157</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7df64fbf96ae38712d316ab7ccd98fee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::flexible_type::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Plus operator. </p><div class="fragment"><div class="line">a = (*this);</div><div class="line">a += other;</div><div class="line"><span class="keywordflow">return</span> a;</div></div><!-- fragment --><p>Note that unlike regular C++ typing rules, the resultant type is always the type of the left hand side. i.e. int + float = int, and float + int = float. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02163">2163</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa71beb2e603618499ec5db2c1fa27cb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::flexible_type::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition operator with arbitrary type. Equivalent to (*this) + (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>)(other); </p>

</div>
</div>
<a class="anchor" id="a4c893e29fef3aafaa4c4d65a39d72920"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>plus-equal operator.</p><ul>
<li>If both are numeric types (int / flex_float), the += will behave as expected.</li>
<li>If both are strings, the += will append.</li>
<li>If both are vectors, the += will perform a vector addition.</li>
<li>If the left hand side is a vector, and right hand side is an int/float, the right hand side value will be added to each value in the vector.</li>
<li>All other conditions will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02132">2132</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a21b7fc22bd155626bc8b17c418ade1a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::flexible_type::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>negation operator.</p><ul>
<li>negation operator.</li>
<li>If the value is a numeric, the negation will return a negated value of the same type.</li>
<li>If the value is a vector, the negation will return a vector with every element negated.</li>
<li>All other conditions will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02125">2125</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5fcd0ad296d3d0a3ca6e81f6fba4ff84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::flexible_type::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract operator. Equivalent to </p><div class="fragment"><div class="line">a = (*this);</div><div class="line">a += other;</div><div class="line"><span class="keywordflow">return</span> a;</div></div><!-- fragment --><p>Note that unlike regular C++ typing rules, the resultant type is always the type of the left hand side. i.e. int + float = int, and float + int = float. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02169">2169</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afca31b8b8826a3db141eda3e832fec4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::flexible_type::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract operator with arbitrary type. Equivalent to (*this) - (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>)(other); </p>

</div>
</div>
<a class="anchor" id="a9813117352a67df9e2d782ef0252238a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>subtract-equal operator.</p><ul>
<li>If both are numeric types (int / float), the -= will behave as expected.</li>
<li>If both are vectors, the -= will perform a vector subtraction.</li>
<li>If the left hand side is a vector, and right hand side is an int/float, the right hand side value will be subtracted from each value in the vector.</li>
<li>All other conditions will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02138">2138</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4eb33ffd373f0f3c2d51793b12d82d2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::flexible_type::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division operator. Equivalent to </p><div class="fragment"><div class="line">a = (*this);</div><div class="line">a /= other;</div><div class="line"><span class="keywordflow">return</span> a;</div></div><!-- fragment --><p>Note that unlike regular C++ typing rules, the resultant type is always the type of the left hand side. i.e. int + float = int, and float + int = float. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02184">2184</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7acf1e2f574773e7371e346217bc0dea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::flexible_type::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Division operator with arbitrary type. Equivalent to (*this) / (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>)(other); </p>

</div>
</div>
<a class="anchor" id="a704fa4b401fff96130043b1bf535fa54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>divide-equal operator.</p><ul>
<li>If both are numeric types (int / float), the /= will behave as expected.</li>
<li>If the left hand side is a vector, and right hand side is an int/float, the right hand side value will be divided from each value in the vector.</li>
<li>All other conditions will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02145">2145</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aec1eb862f7f63b32d19f414d31aa0052"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN bool turi::flexible_type::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Less than operator.</p><ul>
<li>If both this and other are int / floats. this behaves as expected</li>
<li>All other cases will result in an assertion failure </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02216">2216</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa068d06b9b02a181e2dcf45c55986c52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool turi::flexible_type::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Less than comparison operator with arbitrary type. Equivalent to (*this) &lt; (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>)(other); </p>

</div>
</div>
<a class="anchor" id="a3e79c71995328b08966e521d45475acb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN bool turi::flexible_type::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>less than or equal than operator.</p><ul>
<li>If both this and other are int / floats. this behaves as expected</li>
<li>All other cases will result in an assertion failure </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02224">2224</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8039ac9c6d74ecc5a729a085b07718f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool turi::flexible_type::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Less than or equal comparison operator with arbitrary type. Equivalent to (*this) &lt;= (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>)(other); </p>

</div>
</div>
<a class="anchor" id="af53b3520c60da7f16acf3c589362cd1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. Copies the other to myself. See <a class="el" href="classturi_1_1flexible__type.html#af53b3520c60da7f16acf3c589362cd1c">flexible_type::operator=</a> </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01706">1706</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af597974b07b643dffdc19de841853d6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. Copies the other to myself. See <a class="el" href="classturi_1_1flexible__type.html#af53b3520c60da7f16acf3c589362cd1c">flexible_type::operator=</a> </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01715">1715</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4be2c54cb4dc92389e9939e14d2da671"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment. Assigns myself from the other, destroying the other. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01734">1734</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5966a02cba0ea22dfbdf84283402e82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment. (Const overload. Required since the T&amp;&amp; universal reference has a tendency to capture everything). </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01724">1724</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f8829aee500d6db73b2d433f4e583f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structturi_1_1has__direct__conversion__to__flexible__type.html">has_direct_conversion_to_flexible_type</a>&lt;T&gt;::value, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&amp;&gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> turi::flexible_type::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment from arbitrary type. Figures out what can be casted from provided argument and stores that. Specifically, it tests the following operations in this order.</p><ul>
<li>If T is an integral type, create a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of an integer</li>
<li>If T is a floating point type, create a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of a float</li>
<li>If T can be converted to a string, create a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of a string</li>
<li>If T can be converted to a flex_vec. create a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of a flex_vec. </li>
</ul>

</div>
</div>
<a class="anchor" id="a10b818888ac1197bdf9357b143f7512f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>operator= for the undefined type See <a class="el" href="classturi_1_1flexible__type.html#af53b3520c60da7f16acf3c589362cd1c">flexible_type::operator=</a> </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01757">1757</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9f5221f75fc0c255da208cdf70b2378"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structturi_1_1has__direct__conversion__to__flexible__type.html">has_direct_conversion_to_flexible_type</a>&lt; typename std::remove_reference&lt;T&gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a>&gt;::value, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&amp;&gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> turi::flexible_type::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move assignment from arbitrary type. Figures out what can be casted from provided argument and stores that. Specifically, it tests the following operations in this order.</p><ul>
<li>If T is an integral type, create a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of an integer</li>
<li>If T is a floating point type, create a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of a float</li>
<li>If T can be converted to a string, create a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of a string</li>
<li>If T can be converted to a flex_vec. create a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of a flex_vec. </li>
</ul>

</div>
</div>
<a class="anchor" id="ac10d377134fb5abea9450a5ed3ba0d4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN bool turi::flexible_type::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares if two flexible types are equivalent in value. i.e. permitting comparisons between integer and floating point types. Same as <a class="el" href="classturi_1_1flexible__type.html#a12fdbb828cfcf386849990cb86baa33d">flexible_type::approx_equal</a> </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02199">2199</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5d5e0af49b011a19bccbc85eb95f041a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool turi::flexible_type::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equality comparison operator with arbitrary type. Equivalent to (*this) == (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>)(other); </p>

</div>
</div>
<a class="anchor" id="aa6d5d413c609681b711c334b8ca38034"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN bool turi::flexible_type::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>greater than operator.</p><ul>
<li>If both this and other are int / floats. this behaves as expected</li>
<li>All other cases will result in an assertion failure </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02220">2220</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e778b7c024d341b5439a6c1193848a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool turi::flexible_type::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Greater than comparison operator with arbitrary type. Equivalent to (*this) &gt; (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>)(other); </p>

</div>
</div>
<a class="anchor" id="ab620164ed938167af8830887cbf31126"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN bool turi::flexible_type::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>greater than or equal than operator.</p><ul>
<li>If both this and other are int / floats. this behaves as expected</li>
<li>All other cases will result in an assertion failure </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02228">2228</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1af54c88bab4f1925d97241aef421afc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool turi::flexible_type::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Greater than or equal comparison operator with arbitrary type. Equivalent to (*this) &gt;= (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>)(other); </p>

</div>
</div>
<a class="anchor" id="a628c2e2d0174ef1812abe574ad1531f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="group__group__flexible__type__types.html#gadcf31f61cc0e0b82bdc9d886fa163e86">flex_float</a> &amp; turi::flexible_type::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array indexing operator.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a vector, Returns a reference to the 'index' entry in the vector.</li>
<li>When the contents is a float, returns a reference to the float only if the index is 0. (i.e. letting the scalar float act like a vector of size 1. All other indexes will fail with an assertion failure.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02289">2289</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca6f7936c64e2c2889f98714d68675eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN const <a class="el" href="group__group__flexible__type__types.html#gadcf31f61cc0e0b82bdc9d886fa163e86">flex_float</a> &amp; turi::flexible_type::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array indexing operator.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a vector, Returns a reference to the 'index' entry in the vector.</li>
<li>When the contents is a float, returns a reference to the float only if the index is 0. (i.e. letting the scalar float act like a vector of size 1. All other indexes will fail with an assertion failure.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02304">2304</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a2f2a1395c3e67b59df7f3dcdbb3a6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN void turi::flexible_type::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__flexible__type__types.html#gadcf31f61cc0e0b82bdc9d886fa163e86">flex_float</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array insertion function.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a vector, inserts the element to the end of the vector.</li>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a recursive array, inserts a float to the end of the vector.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02444">2444</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb243d623f5b4a0b349a772a8f935b7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN void turi::flexible_type::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array / List insertion function.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a vector, and the element is a floating point number, inserts the element to the end of the vector.</li>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a list, inserts a value to the end of the vector.</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02459">2459</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7d635f1b191841b7a0a621f823df0a7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; turi::flexible_type::reinterpret_get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a type unchecked modifiable reference to the value stored inside the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>.</p>
<p>This is generally unsafe to use unless you <em>really</em> know what you are doing. Use <a class="el" href="classturi_1_1flexible__type.html#a9cb5ea486620ffdd6f5aef446d3d304b">get()</a> instead.</p>
<p>Note that this is only defined for flex_int and flex_float type. It really does not make sense to use this anywhere else. </p>

</div>
</div>
<a class="anchor" id="a1fba3522c10c5c6f73f260c78866771b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; turi::flexible_type::reinterpret_mutable_get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a modifiable type unchecked modifiable reference to the value stored inside the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>.</p>
<p>This is generally unsafe to use unless you <em>really</em> know what you are doing. Use <a class="el" href="classturi_1_1flexible__type.html#a9cb5ea486620ffdd6f5aef446d3d304b">get()</a> instead.</p>
<p>Note that this is only defined for flex_int and flex_float type. It really does not make sense to use this anywhere else. </p>

</div>
</div>
<a class="anchor" id="a4ed81c5fda8f3b8de29d0c7a91b952c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN void turi::flexible_type::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>target_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes the contents of this class, resetting to a different type.</p>
<p>Note: Also ensures that that the reference count becomes 1. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01778">1778</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab8258899dbd19b7df408fed0910de568"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN void turi::flexible_type::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes the contents of this class, resetting to an integer </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01821">1821</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e2623844c41c84a7dd0e5d81c462959"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN void turi::flexible_type::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array resize function</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a vector or a recursive array resizes the array</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02417">2417</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f51a38d151a5448f99cf683389eeee1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE void turi::flexible_type::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1oarchive.html">oarchive</a> &amp;&#160;</td>
          <td class="paramname"><em>oarc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Serializer. Saves the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> in an archive object. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02475">2475</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59d0457f38e3771d2af4f57da1c17ffe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::set_date_time_from_timestamp_and_offset </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>, int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>datetime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>microsecond</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the current flexible type to a datetime type containing posix_timestamp value and timezone offset. The timezone offset is integral in <b>fifteen-minute</b> increments. i.e. a offset of 8 means timezone +2 </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01460">1460</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c8bce670e9c41eea98fb7ede6fdd02a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN size_t turi::flexible_type::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array length function.</p><ul>
<li>When the contents of the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> is a vector or a recursive array Returns the length of the vector.</li>
<li>When the contents is a float, returns 1 (i.e. letting the scalar float act like a vector of size 1.)</li>
<li>All other types will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l02402">2402</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae982bbb01bc4676c69032874d461b69b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp; turi::flexible_type::soft_assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign from another while preserving the type of the current <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>.</p><ul>
<li>If left side is numeric and right side is numeric, the operation works as expected.</li>
<li>If left side is a string, the right side is converted to a string representation</li>
<li>if left side is a vector and right side is a vector, the vector is copied.</li>
<li>All other cases will result in an assertion failure. </li>
</ul>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01699">1699</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa0907f9ecf1729ea0abc966d83061039"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE_FLATTEN void turi::flexible_type::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps contents with another <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01829">1829</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a34f12dac35bf0035146408baa22bbb86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_floating_point&lt;T&gt;::value, T&gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> turi::flexible_type::to </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> to a particular type. Behaves like the implicit cast operators, but explicit. In particular, this gets around the thorny issue that there is no way to cast to an flex_vec, flex_list or flex_dict even though the implicit cast operators exist. This is due to std::vector&lt;T&gt; having two constructors: </p><div class="fragment"><div class="line"><span class="comment">// regular copy constructor</span></div><div class="line">vector&lt;T&gt;::vector(<span class="keyword">const</span> std::vector&lt;T&gt;&amp;) ...</div><div class="line"></div><div class="line"><span class="comment">// constructs a vector of a particular size</span></div><div class="line">vector&lt;T&gt;::vector(<span class="keywordtype">size_t</span> N, T val = T()) ...</div></div><!-- fragment --><p> Resulting in two possible implicit cast routes when doing: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f;</div><div class="line">...</div><div class="line">flex_vec v = f; <span class="comment">// fails</span></div><div class="line"><a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a> v = (<a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a>)f; <span class="comment">// fails</span></div></div><!-- fragment --><p>This function provides an explicit cast allowing the following to be written: </p><div class="fragment"><div class="line"><a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a> v = f.to&lt;<a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a>&gt;(); </div></div><!-- fragment --><p>Of course, the alternative of is always available. </p><div class="fragment"><div class="line"><a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a> v = f.operator <a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a>();</div></div><!-- fragment --><p> And indeed, the implementation of <a class="el" href="classturi_1_1flexible__type.html#a34f12dac35bf0035146408baa22bbb86">to()</a> simply redirects the calls. </p>

</div>
</div>
<a class="anchor" id="a6006917f1ac6d8cf94bd772dc9411aaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> turi::flexible_type::to </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> to a particular type. Behaves like the implicit cast operators, but explicit. In particular, this gets around the thorny issue that there is no way to cast to an flex_vec, flex_list or flex_dict even though the implicit cast operators exist. This is due to std::vector&lt;T&gt; having two constructors: </p><div class="fragment"><div class="line"><span class="comment">// regular copy constructor</span></div><div class="line">vector&lt;T&gt;::vector(<span class="keyword">const</span> std::vector&lt;T&gt;&amp;) ...</div><div class="line"></div><div class="line"><span class="comment">// constructs a vector of a particular size</span></div><div class="line">vector&lt;T&gt;::vector(<span class="keywordtype">size_t</span> N, T val = T()) ...</div></div><!-- fragment --><p> Resulting in two possible implicit cast routes when doing: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f;</div><div class="line">...</div><div class="line">flex_vec v = f; <span class="comment">// fails</span></div><div class="line"><a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a> v = (<a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a>)f; <span class="comment">// fails</span></div></div><!-- fragment --><p>This function provides an explicit cast allowing the following to be written: </p><div class="fragment"><div class="line"><a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a> v = f.to&lt;<a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a>&gt;(); </div></div><!-- fragment --><p>Of course, the alternative of is always available. </p><div class="fragment"><div class="line"><a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a> v = f.operator <a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a>();</div></div><!-- fragment --><p> And indeed, the implementation of <a class="el" href="classturi_1_1flexible__type.html#a34f12dac35bf0035146408baa22bbb86">to()</a> simply redirects the calls. </p>

</div>
</div>
<a class="anchor" id="a6c6b808f8432454170e91bc79478d5b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::<a class="el" href="classturi_1_1flexible__type.html#a6127144212fdeb61d0094ee013e22baa">type</a> turi::flexible_type::to </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> to a particular type. Behaves like the implicit cast operators, but explicit. In particular, this gets around the thorny issue that there is no way to cast to an flex_vec, flex_list or flex_dict even though the implicit cast operators exist. This is due to std::vector&lt;T&gt; having two constructors: </p><div class="fragment"><div class="line"><span class="comment">// regular copy constructor</span></div><div class="line">vector&lt;T&gt;::vector(<span class="keyword">const</span> std::vector&lt;T&gt;&amp;) ...</div><div class="line"></div><div class="line"><span class="comment">// constructs a vector of a particular size</span></div><div class="line">vector&lt;T&gt;::vector(<span class="keywordtype">size_t</span> N, T val = T()) ...</div></div><!-- fragment --><p> Resulting in two possible implicit cast routes when doing: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1flexible__type.html#ab7ced47636ee238dd993324b39ad6610">flexible_type</a> f;</div><div class="line">...</div><div class="line">flex_vec v = f; <span class="comment">// fails</span></div><div class="line"><a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a> v = (<a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a>)f; <span class="comment">// fails</span></div></div><!-- fragment --><p>This function provides an explicit cast allowing the following to be written: </p><div class="fragment"><div class="line"><a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a> v = f.to&lt;<a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a>&gt;(); </div></div><!-- fragment --><p>Of course, the alternative of is always available. </p><div class="fragment"><div class="line"><a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a> v = f.operator <a class="code" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a>();</div></div><!-- fragment --><p> And indeed, the implementation of <a class="el" href="classturi_1_1flexible__type.html#a34f12dac35bf0035146408baa22bbb86">to()</a> simply redirects the calls. </p>

</div>
</div>
<a class="anchor" id="a6127144212fdeb61d0094ee013e22baa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE std::type_index turi::flexible_type::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type index of the underlying storage. For compatibility with variant. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01868">1868</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace41cf48dbbaf4f135d162d4526f48b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FLEX_ALWAYS_INLINE size_t turi::flexible_type::which </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an integer ID identifying the type of the underlying storage. Equivalent to (size_t)(<a class="el" href="classturi_1_1flexible__type.html#aada3ceebb28d5983567e22a3ff5ec559">get_type()</a>). For compatibility with variant. </p>

<p>Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01872">1872</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>flexible_type/<a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
