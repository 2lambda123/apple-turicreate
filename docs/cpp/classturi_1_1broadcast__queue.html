<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: turi::broadcast_queue&lt; T, Serializer &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1broadcast__queue.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classturi_1_1broadcast__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::broadcast_queue&lt; T, Serializer &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__sframe__query__engine.html">SFrame Logical Query Engine</a> &raquo; <a class="el" href="group__Utilities.html">Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="broadcast__queue_8hpp_source.html">core/storage/query_engine/util/broadcast_queue.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4c258b9e626abee6c09ed390aae3500"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1broadcast__queue.html#ae4c258b9e626abee6c09ed390aae3500">broadcast_queue</a> (size_t num_consumers, size_t cache_limit=128, const Serializer &amp;serializer=Serializer())</td></tr>
<tr class="separator:ae4c258b9e626abee6c09ed390aae3500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5ce2c36d27380939d32fd091b30f33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1broadcast__queue.html#a8b5ce2c36d27380939d32fd091b30f33">set_cache_limit</a> (size_t cache_limit)</td></tr>
<tr class="separator:a8b5ce2c36d27380939d32fd091b30f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cdc8ec8d144f04aaaf33382efd304c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1broadcast__queue.html#ad1cdc8ec8d144f04aaaf33382efd304c">push</a> (const T &amp;el)</td></tr>
<tr class="separator:ad1cdc8ec8d144f04aaaf33382efd304c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab663e51c071e6fcaed3087613cd0bc34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1broadcast__queue.html#ab663e51c071e6fcaed3087613cd0bc34">empty</a> (size_t consumer)</td></tr>
<tr class="separator:ab663e51c071e6fcaed3087613cd0bc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe92c23eb6e52da3c9a5cf1ad0452934"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1broadcast__queue.html#afe92c23eb6e52da3c9a5cf1ad0452934">pop</a> (size_t consumer, T &amp;ret)</td></tr>
<tr class="separator:afe92c23eb6e52da3c9a5cf1ad0452934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67509f16ac63d05409a31d6fded4aa46"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1broadcast__queue.html#a67509f16ac63d05409a31d6fded4aa46">num_elements</a> () const</td></tr>
<tr class="separator:a67509f16ac63d05409a31d6fded4aa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dd3411c031611e9c3d1bfcad3a0b36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1broadcast__queue.html#ae5dd3411c031611e9c3d1bfcad3a0b36">delete_all_cache_files</a> ()</td></tr>
<tr class="separator:ae5dd3411c031611e9c3d1bfcad3a0b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Serializer = broadcast_queue_serializer&lt;T&gt;&gt;<br />
class turi::broadcast_queue&lt; T, Serializer &gt;</h3>

<p>This implements a external memory single producer, multiple-consumer queue where every consumer sees all the produced elements.</p>
<p>This class is <em>not</em> thread safe.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Datatype to be saved. Must be serializable</td></tr>
  </table>
  </dd>
</dl>
<p>This class guarantees very high efficiency if the total number of elements do not exceed the cache limit.</p>
<p>The key design constraint are that files are either open for reading or writing, but not both simultaneously. Random writes are prohibited, but random reads are allowed.</p>
<h2>Single consumer queue </h2>
<p>The single consumer case is easy to understand so we will explain that first.</p>
<ol type="1">
<li>push file</li>
<li>center queue</li>
<li>pop file</li>
</ol>
<p>Elements enter at the top and leave from the bottom.</p>
<p>When data is pushed, we push directly into the center queue. But if the center queue is full, we start writing to the push_file.</p>
<p>When data is popped, we first read from the pop-file. When there are no more pop files, we reads from the center queue. When the center queue is empty, it closes the push and swaps it to a pop file and starts reading from the pop file.</p>
<p>Thus there can be at most one pop file.</p>
<p>There are two interesting properties. Where n is the total number of elements, and k is the limit on the size of center_queue.</p>
<p>1) no more than n / kfiles will be created even under adversial schedulings of consumer and producer.</p>
<p>(Simple proof. Everytime a push file becomes a pop file, the center is empty. Hence at least k elements must be inserted into the center queue before a new push file is started.)</p>
<p>2) Assuming producer and consumer rates match. i.e. we alternate producing 'q' elements and consuming 'q' elements. At most a proportion of (q - k)/q elements will be written to or read from disk.</p>
<h2>Multiple consumer queue 1 </h2>
<p>In the multiple consumer case, every consumer must see every element. This makes the datastructure substantially trickier. Specifically you want to make sure the setting where there are 2 or more consumers and all consumers are very slow except for one which is as fast as the producer, do not result in:</p><ul>
<li>producer writes a single element write to a push file</li>
<li>fast consumer needs the element, closes that push file turns it into a pop file and reads it.</li>
<li>This results in one file per element.</li>
</ul>
<p>In other words, we must try to preserve the property (1) above, that at most O(n / k) files are created for some datastructure cache parameter k.</p>
<p>A simple method is to shift to a pure caching model.</p><ol type="1">
<li>memory queue</li>
<li>pop file</li>
<li>pop file</li>
<li>pop file</li>
<li>...</li>
</ol>
<p>When we push:</p><ul>
<li>It goes into the memory queue</li>
<li>When memory queue exceeds some threshold, it gets written to disk and a new memory queue is started.</li>
</ul>
<p>Every consumer remembers a current file position pointer, and</p><ul>
<li>pops from file</li>
<li>or reads from the in memory queue. (a little bit of bookkeeping is needed since the queue may get flushed to disk)</li>
</ul>
<p>While this satisfies the property (1), this does not satisfy property (2). i.e. Assuming producer and consumer rates match. i.e. we alternate producing 'q' elements and every consumer consuming 'q' elements. When q &gt; k, This procedure will write every element to file.</p>
<h2>Multiple consumer queue 2 </h2>
<p>Lets soften the cache a bit by allowing caching of up to 2k elements. When 2k elements are reached, we flush the first k elements to a file.</p>
<p>It is easy to show that at most O(n / k) files are created since each file must have at least k elements. Similarly, when producer and consumer rates match. At most a proportion of (q - k)/q elements will be written to or read from disk.</p>
<p>This thus satisfies the desirable properties of the single consumer queue.</p>
<p>The architecture is hence:</p><ol type="1">
<li>memory queue</li>
</ol>
<ol type="1">
<li>push file</li>
<li>pop file</li>
<li>pop file</li>
<li>pop file</li>
<li>...</li>
</ol>
<p>On push:</p><ul>
<li>push into memory_queue</li>
<li>if memory_queue size exceeds 2k,<ul>
<li>flush first k into a new push_file</li>
<li>If there is a consumer reading from the memory queue, flip push file to a pop file. (make the push file into a pop file and update all consumers so that they are reading from the pop file.)</li>
</ul>
</li>
<li>else if push file exists,<ul>
<li>pop first element of memory_queue to push_file</li>
</ul>
</li>
</ul>
<p>On pop:</p><ul>
<li>If I am reading from pop file just read next element from pop file advancing to next pop file if necessary</li>
<li>If there are no more pop files, but if there is a push file, flip push file to a pop file.</li>
<li>If I am reading from memory queue, advance to the next memory queue element</li>
</ul>
<h2>Optimizations </h2>
<p>More optimizations are needed to minimize the number of files created.</p><ol type="1">
<li>Use a pool of file names which we can reuse rather than create a new one everytime we need a new file.</li>
<li>Once we reach 2k, we dump the first k to a file. but we don't close the file. After which every new insertion will shift the queue. one element gets written to disk, as one element gets inserted. Only when the file must be read by a consumer, then it gets flushed.</li>
<li>Delay the creation of the "pop file" from the "push file" as late as we can. i.e. we only create the pop file when there is a consumer who needs to read from the data just written to the push file </li>
</ol>

<p class="definition">Definition at line <a class="el" href="broadcast__queue_8hpp_source.html#l00175">175</a> of file <a class="el" href="broadcast__queue_8hpp_source.html">broadcast_queue.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae4c258b9e626abee6c09ed390aae3500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c258b9e626abee6c09ed390aae3500">&#9670;&nbsp;</a></span>broadcast_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Serializer = broadcast_queue_serializer&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1broadcast__queue.html">turi::broadcast_queue</a>&lt; T, Serializer &gt;::<a class="el" href="classturi_1_1broadcast__queue.html">broadcast_queue</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_consumers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cache_limit</em> = <code>128</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Serializer &amp;&#160;</td>
          <td class="paramname"><em>serializer</em> = <code>Serializer()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a disk backed queue </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>limit Number of elements to cache </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="broadcast__queue_8hpp_source.html#l00181">181</a> of file <a class="el" href="broadcast__queue_8hpp_source.html">broadcast_queue.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae5dd3411c031611e9c3d1bfcad3a0b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5dd3411c031611e9c3d1bfcad3a0b36">&#9670;&nbsp;</a></span>delete_all_cache_files()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Serializer = broadcast_queue_serializer&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1broadcast__queue.html">turi::broadcast_queue</a>&lt; T, Serializer &gt;::delete_all_cache_files </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes all unused cache files </p>

<p class="definition">Definition at line <a class="el" href="broadcast__queue_8hpp_source.html#l00305">305</a> of file <a class="el" href="broadcast__queue_8hpp_source.html">broadcast_queue.hpp</a>.</p>

</div>
</div>
<a id="ab663e51c071e6fcaed3087613cd0bc34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab663e51c071e6fcaed3087613cd0bc34">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Serializer = broadcast_queue_serializer&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classturi_1_1broadcast__queue.html">turi::broadcast_queue</a>&lt; T, Serializer &gt;::empty </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>consumer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>if this returns false, the next call to pop(consumer) will succeed, Otherwise it will fail. </p>

<p class="definition">Definition at line <a class="el" href="broadcast__queue_8hpp_source.html#l00256">256</a> of file <a class="el" href="broadcast__queue_8hpp_source.html">broadcast_queue.hpp</a>.</p>

</div>
</div>
<a id="a67509f16ac63d05409a31d6fded4aa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67509f16ac63d05409a31d6fded4aa46">&#9670;&nbsp;</a></span>num_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Serializer = broadcast_queue_serializer&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classturi_1_1broadcast__queue.html">turi::broadcast_queue</a>&lt; T, Serializer &gt;::num_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the queue. </p>

<p class="definition">Definition at line <a class="el" href="broadcast__queue_8hpp_source.html#l00298">298</a> of file <a class="el" href="broadcast__queue_8hpp_source.html">broadcast_queue.hpp</a>.</p>

</div>
</div>
<a id="afe92c23eb6e52da3c9a5cf1ad0452934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe92c23eb6e52da3c9a5cf1ad0452934">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Serializer = broadcast_queue_serializer&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classturi_1_1broadcast__queue.html">turi::broadcast_queue</a>&lt; T, Serializer &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pops and element from the queue. Returns true on success, false on failure (queue is empty) </p>

<p class="definition">Definition at line <a class="el" href="broadcast__queue_8hpp_source.html#l00263">263</a> of file <a class="el" href="broadcast__queue_8hpp_source.html">broadcast_queue.hpp</a>.</p>

</div>
</div>
<a id="ad1cdc8ec8d144f04aaaf33382efd304c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cdc8ec8d144f04aaaf33382efd304c">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Serializer = broadcast_queue_serializer&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1broadcast__queue.html">turi::broadcast_queue</a>&lt; T, Serializer &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>el</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pushes an element into the queue. </p>

<p class="definition">Definition at line <a class="el" href="broadcast__queue_8hpp_source.html#l00218">218</a> of file <a class="el" href="broadcast__queue_8hpp_source.html">broadcast_queue.hpp</a>.</p>

</div>
</div>
<a id="a8b5ce2c36d27380939d32fd091b30f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5ce2c36d27380939d32fd091b30f33">&#9670;&nbsp;</a></span>set_cache_limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Serializer = broadcast_queue_serializer&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1broadcast__queue.html">turi::broadcast_queue</a>&lt; T, Serializer &gt;::set_cache_limit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cache_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the cache limit </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>limit Number of elements to cache </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="broadcast__queue_8hpp_source.html#l00210">210</a> of file <a class="el" href="broadcast__queue_8hpp_source.html">broadcast_queue.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/storage/query_engine/util/<a class="el" href="broadcast__queue_8hpp_source.html">broadcast_queue.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="classturi_1_1broadcast__queue.html">broadcast_queue</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
