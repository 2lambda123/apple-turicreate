<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Turi Create: turi::query_eval::execution_node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1query__eval_1_1execution__node.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classturi_1_1query__eval_1_1execution__node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::query_eval::execution_node Class Reference<div class="ingroups"><a class="el" href="group__sframe__query__engine.html">SFrame Logical Query Engine</a> &raquo; <a class="el" href="group__execution.html">Execution</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="execution__node_8hpp_source.html">core/storage/query_engine/execution/execution_node.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a297aa0097bf801eba1ba106ff844ecec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1query__eval_1_1execution__node.html#a297aa0097bf801eba1ba106ff844ecec">execution_node</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1query__eval_1_1query__operator.html">query_operator</a>&gt;&amp;op, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1query__eval_1_1execution__node.html">execution_node</a> &gt; &gt; &amp;inputs=std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1query__eval_1_1execution__node.html">execution_node</a> &gt;&gt;())</td></tr>
<tr class="separator:a297aa0097bf801eba1ba106ff844ecec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ce1048c49ee7afe052f6f169afcc7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1query__eval_1_1execution__node.html#a96ce1048c49ee7afe052f6f169afcc7b">init</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1query__eval_1_1query__operator.html">query_operator</a>&gt;&amp;op, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1query__eval_1_1execution__node.html">execution_node</a> &gt; &gt; &amp;inputs=std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1query__eval_1_1execution__node.html">execution_node</a> &gt;&gt;())</td></tr>
<tr class="separator:a96ce1048c49ee7afe052f6f169afcc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5463e31d28302f7c003252bbc3d81471"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1query__eval_1_1execution__node.html#a5463e31d28302f7c003252bbc3d81471">register_consumer</a> ()</td></tr>
<tr class="separator:a5463e31d28302f7c003252bbc3d81471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc17ed79a77a591854f5d82e96743db"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1query__eval_1_1execution__node.html#acbc17ed79a77a591854f5d82e96743db">get_next</a> (size_t consumer_id, bool skip=false)</td></tr>
<tr class="separator:acbc17ed79a77a591854f5d82e96743db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d5302596e81a5233eaa4a625f6702f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1query__eval_1_1execution__node.html#a11d5302596e81a5233eaa4a625f6702f">num_inputs</a> () const </td></tr>
<tr class="separator:a11d5302596e81a5233eaa4a625f6702f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb43e3d2bdbe7d1c14d31d56c1205684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1query__eval_1_1execution__node.html#adb43e3d2bdbe7d1c14d31d56c1205684">reset</a> ()</td></tr>
<tr class="separator:adb43e3d2bdbe7d1c14d31d56c1205684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23e21895e60e5c370b77eee2fa92036"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1query__eval_1_1execution__node.html#aa23e21895e60e5c370b77eee2fa92036">exception_occurred</a> () const </td></tr>
<tr class="separator:aa23e21895e60e5c370b77eee2fa92036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad81b57fe3bf8e25c6509fe5e2cdd040"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1query__eval_1_1execution__node.html#aad81b57fe3bf8e25c6509fe5e2cdd040">get_exception</a> () const </td></tr>
<tr class="separator:aad81b57fe3bf8e25c6509fe5e2cdd040"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The execution node provides a wrapper around an operator. It</p><ul>
<li>manages the coroutine context for the operator</li>
<li>manages the connections between the operator and its inputs and outputs.</li>
<li>Manages the buffering and transfer of information between the operator,</li>
</ul>
<p>Essentially, calling a coroutine, causes a context switch to occur starting the coroutine. Then within the coroutine, a "sink()" function can be called which context switches and resumes execution <em>where the coroutine was initially triggered</em>.</p>
<p>The classical example is a producer-consumer queue </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> producer() {</div><div class="line">  <span class="keywordflow">while</span>(1) {</div><div class="line">    a = <span class="keyword">new</span> work</div><div class="line">    consumer(a); <span class="comment">// or sink(a) in the above syntax</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> consumer() {</div><div class="line">  <span class="keywordflow">while</span>(1) {</div><div class="line">    a = producer();</div><div class="line">    <span class="comment">// do work on a</span></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Here, we are using coroutines to attach and communicate between query operators, so for instance, here is a simple transform on a source. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> data_source() {</div><div class="line">  <span class="keywordflow">while</span>(data_source_has_rows) {</div><div class="line">    rows = read_rows</div><div class="line">    sink(rows);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__eager__algorithms.html#gaa10744bd79ea1690d46f800c003c2a94">transform</a>() {</div><div class="line">  <span class="keywordflow">while</span>(1) {</div><div class="line">    data = source()</div><div class="line">    if (data == <span class="keywordtype">nullptr</span>) {</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      transformed_data = apply_transform(data)</div><div class="line">      sink(transformed_data);</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>while the context switch is relatively cheap (boost coroutines promise this at &lt; 100 cycles or so), we still want to avoid performing the context switch for every row, so our unit of communication across coroutines is an <a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a> object which represents a collection of rows, but represented columnar-wise. Every communicated block must be of a constant number of rows (i.e. SFRAME_READ_BATCH_SIZE. ex: 256), except for the last block which may be smaller. Operators which perform filtering for instance, must hence make sure to buffer accordingly.</p>
<p>One key issue with any of the pipeline models (whether pull-based: like here, or push-based) is about rate-control. For instance, the operator graph corresponding to the following expression has issues: </p><div class="fragment"><div class="line">logical_filter(source_A, selector_source) + logical_filter(source_B, selector_source)</div></div><!-- fragment --><ul>
<li>To compute the "+", the left logical filter operator is invoked</li>
<li>To compute the left logical filter, source_A and selector_source is read and they continue to be read until say... 256 rows are generated. This is then sent to the "+" operator which resumes execution.</li>
<li>The "+" operator then reads the right logical filter operator.</li>
<li>The right logical filter operator now needs to read source_B and selector_source.</li>
<li>However, selector_source has already advanced because it was partially consumed for the left logical filter.</li>
</ul>
<p>A solution to this requires the selector_source to buffer its reads while feeding the left logical_filter. The solution to this is to either assume that all connected operators operate at exactly the same rate (we can guarantee this with some care as to how the operator graph is constructed), or we allow buffering. This buffering has to be somewhat intelligent because it may require unbounded buffers.</p>
<p>An earlier version of this execution model used the former procedure (assuming uniform rate), now we use the <a class="el" href="classturi_1_1broadcast__queue.html">broadcast_queue</a> to provide unbounfed buffering.</p>
<p>The <a class="el" href="classturi_1_1query__eval_1_1execution__node.html">execution_node</a> is not generally used directly (see the hierarchy of materialize functions). However, usage is not very complicated.</p>
<p>Given an <a class="el" href="classturi_1_1query__eval_1_1execution__node.html">execution_node</a> graph, with a tip you will like to consume data from: </p><div class="fragment"><div class="line">(tip is a shared_ptr&lt;execution_node&gt;)</div><div class="line"><span class="comment">// register a new consumer (aka myself)</span></div><div class="line"><span class="keywordtype">size_t</span> consumer_id = tip-&gt;register_consumer();</div><div class="line"></div><div class="line"><span class="keywordflow">while</span>(1) {</div><div class="line">  <span class="keyword">auto</span> rows = node-&gt;get_next(consumer_id);</div><div class="line">  <span class="comment">// do stuff. rows == nullptr on completion</span></div><div class="line">}</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="execution__node_8hpp_source.html#l00151">151</a> of file <a class="el" href="execution__node_8hpp_source.html">execution_node.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a297aa0097bf801eba1ba106ff844ecec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">turi::query_eval::execution_node::execution_node </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1query__eval_1_1query__operator.html">query_operator</a>&gt;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1query__eval_1_1execution__node.html">execution_node</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em> = <code>std::vector&lt;&#160;std::shared_ptr&lt;&#160;<a class="el" href="classturi_1_1query__eval_1_1execution__node.html">execution_node</a>&#160;&gt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the execution node with an operator and inputs. Also resets the operator. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa23e21895e60e5c370b77eee2fa92036"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::query_eval::execution_node::exception_occurred </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if an exception occured while executing this node </p>

<p>Definition at line <a class="el" href="execution__node_8hpp_source.html#l00211">211</a> of file <a class="el" href="execution__node_8hpp_source.html">execution_node.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad81b57fe3bf8e25c6509fe5e2cdd040"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::exception_ptr turi::query_eval::execution_node::get_exception </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If an exception occured while excecuting this node, this returns the last exception exception. Otherwise returns an exception_ptr which compares equal to the null pointer. </p>

<p>Definition at line <a class="el" href="execution__node_8hpp_source.html#l00220">220</a> of file <a class="el" href="execution__node_8hpp_source.html">execution_node.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbc17ed79a77a591854f5d82e96743db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a>&gt; turi::query_eval::execution_node::get_next </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>consumer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns nullptr if there is no more data. </p>

</div>
</div>
<a class="anchor" id="a96ce1048c49ee7afe052f6f169afcc7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::query_eval::execution_node::init </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1query__eval_1_1query__operator.html">query_operator</a>&gt;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1query__eval_1_1execution__node.html">execution_node</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em> = <code>std::vector&lt;&#160;std::shared_ptr&lt;&#160;<a class="el" href="classturi_1_1query__eval_1_1execution__node.html">execution_node</a>&#160;&gt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the execution node with an operator and inputs. Also resets the operator. </p>

</div>
</div>
<a class="anchor" id="a11d5302596e81a5233eaa4a625f6702f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::query_eval::execution_node::num_inputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of inputs of the execution node </p>

<p>Definition at line <a class="el" href="execution__node_8hpp_source.html#l00192">192</a> of file <a class="el" href="execution__node_8hpp_source.html">execution_node.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5463e31d28302f7c003252bbc3d81471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::query_eval::execution_node::register_consumer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an execution consumer. This function call then returns an ID which the caller should use with <a class="el" href="classturi_1_1query__eval_1_1execution__node.html#acbc17ed79a77a591854f5d82e96743db">get_next()</a>. </p>

</div>
</div>
<a class="anchor" id="adb43e3d2bdbe7d1c14d31d56c1205684"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::query_eval::execution_node::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>resets the state of this execution node. Note that this does NOT recursively reset all parents (since in a general graph this could cause multiple resets of the same vertex). The caller must ensure that all connected execution nodes are reset. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/storage/query_engine/execution/<a class="el" href="execution__node_8hpp_source.html">execution_node.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="namespaceturi_1_1query__eval.html">query_eval</a></li><li class="navelem"><a class="el" href="classturi_1_1query__eval_1_1execution__node.html">execution_node</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
