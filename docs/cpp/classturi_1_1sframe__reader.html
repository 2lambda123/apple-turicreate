<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Turi Create: turi::sframe_reader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1sframe__reader.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classturi_1_1sframe__reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::sframe_reader Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__sframe__physical.html">SFrame : Physical</a> &raquo; <a class="el" href="group__sframe__main.html">Main SFrame Objects</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sframe__reader_8hpp_source.html">core/storage/sframe_data/sframe_reader.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa6fb42f3f07190880ac210cd2b9067d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6fb42f3f07190880ac210cd2b9067d2"></a>
typedef <a class="el" href="classturi_1_1sframe__iterator.html">sframe_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#aa6fb42f3f07190880ac210cd2b9067d2">iterator</a></td></tr>
<tr class="memdesc:aa6fb42f3f07190880ac210cd2b9067d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator type which <a class="el" href="classturi_1_1sframe__reader.html#a61ea963b7ab3c345101313e1ef37c140">begin</a> and <a class="el" href="classturi_1_1sframe__reader.html#aeeab87609ea0384ad75d85d2a07ce1d5">end</a> returns. <br /></td></tr>
<tr class="separator:aa6fb42f3f07190880ac210cd2b9067d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cdffe54bc5bf2dd1a87fb83f300d3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20cdffe54bc5bf2dd1a87fb83f300d3c"></a>
typedef sframe_iterator::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a20cdffe54bc5bf2dd1a87fb83f300d3c">value_type</a></td></tr>
<tr class="memdesc:a20cdffe54bc5bf2dd1a87fb83f300d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type the sframe stores. <br /></td></tr>
<tr class="separator:a20cdffe54bc5bf2dd1a87fb83f300d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a2a4078bf781e8a7382b133d0ab1bc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a4a2a4078bf781e8a7382b133d0ab1bc1">sframe_reader</a> ()=default</td></tr>
<tr class="separator:a4a2a4078bf781e8a7382b133d0ab1bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfff57a51b6ae547b60497ec72ed98c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfff57a51b6ae547b60497ec72ed98c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#abfff57a51b6ae547b60497ec72ed98c1">sframe_reader</a> (const <a class="el" href="classturi_1_1sframe__reader.html">sframe_reader</a> &amp;other)=delete</td></tr>
<tr class="memdesc:abfff57a51b6ae547b60497ec72ed98c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted Copy constructor. <br /></td></tr>
<tr class="separator:abfff57a51b6ae547b60497ec72ed98c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00dad06e76d733d7b0ed703cebd85c59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00dad06e76d733d7b0ed703cebd85c59"></a>
<a class="el" href="classturi_1_1sframe__reader.html">sframe_reader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a00dad06e76d733d7b0ed703cebd85c59">operator=</a> (const <a class="el" href="classturi_1_1sframe__reader.html">sframe_reader</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a00dad06e76d733d7b0ed703cebd85c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted Assignment operator. <br /></td></tr>
<tr class="separator:a00dad06e76d733d7b0ed703cebd85c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4de823399753f13e581d5ee2ef84a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#aba4de823399753f13e581d5ee2ef84a6">init</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;array, size_t <a class="el" href="classturi_1_1sframe__reader.html#a93f124b3729ebc9ab2cb9b277f55967a">num_segments</a>=(size_t)(-1))</td></tr>
<tr class="separator:aba4de823399753f13e581d5ee2ef84a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0210d3a96886975b4edcc1239e0909a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a0210d3a96886975b4edcc1239e0909a6">init</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;array, const std::vector&lt; size_t &gt; &amp;segment_lengths)</td></tr>
<tr class="separator:a0210d3a96886975b4edcc1239e0909a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ea963b7ab3c345101313e1ef37c140"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61ea963b7ab3c345101313e1ef37c140"></a>
<a class="el" href="classturi_1_1sframe__reader.html#aa6fb42f3f07190880ac210cd2b9067d2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a61ea963b7ab3c345101313e1ef37c140">begin</a> (size_t segmentid) const </td></tr>
<tr class="memdesc:a61ea963b7ab3c345101313e1ef37c140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the begin iterator of the segment. <br /></td></tr>
<tr class="separator:a61ea963b7ab3c345101313e1ef37c140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeab87609ea0384ad75d85d2a07ce1d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeab87609ea0384ad75d85d2a07ce1d5"></a>
<a class="el" href="classturi_1_1sframe__reader.html#aa6fb42f3f07190880ac210cd2b9067d2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#aeeab87609ea0384ad75d85d2a07ce1d5">end</a> (size_t segmentid) const </td></tr>
<tr class="memdesc:aeeab87609ea0384ad75d85d2a07ce1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end iterator of the segment. <br /></td></tr>
<tr class="separator:aeeab87609ea0384ad75d85d2a07ce1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4feb7756ff08277218afd7eaafc7b818"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a4feb7756ff08277218afd7eaafc7b818">read_rows</a> (size_t row_start, size_t row_end, std::vector&lt; std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &amp;out_obj)</td></tr>
<tr class="separator:a4feb7756ff08277218afd7eaafc7b818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d2e36b85ee65f9921c882ebf3c3e2c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a23d2e36b85ee65f9921c882ebf3c3e2c">read_rows</a> (size_t row_start, size_t row_end, <a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a> &amp;out_obj)</td></tr>
<tr class="separator:a23d2e36b85ee65f9921c882ebf3c3e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8003689a903baa74c206c067d75bfd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#ab8003689a903baa74c206c067d75bfd4">reset_iterators</a> ()</td></tr>
<tr class="separator:ab8003689a903baa74c206c067d75bfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0d60475dd7c2b585a930c5ffef19f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e0d60475dd7c2b585a930c5ffef19f7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a0e0d60475dd7c2b585a930c5ffef19f7">num_columns</a> () const </td></tr>
<tr class="memdesc:a0e0d60475dd7c2b585a930c5ffef19f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the SFrame. Does not throw. <br /></td></tr>
<tr class="separator:a0e0d60475dd7c2b585a930c5ffef19f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca762a6adeadbc7563fb309bcd85ce63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca762a6adeadbc7563fb309bcd85ce63"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#aca762a6adeadbc7563fb309bcd85ce63">num_rows</a> () const </td></tr>
<tr class="memdesc:aca762a6adeadbc7563fb309bcd85ce63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of each sarray. <br /></td></tr>
<tr class="separator:aca762a6adeadbc7563fb309bcd85ce63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3718bbe5b6689eaf8312a61340d60a63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3718bbe5b6689eaf8312a61340d60a63"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a3718bbe5b6689eaf8312a61340d60a63">size</a> () const </td></tr>
<tr class="memdesc:a3718bbe5b6689eaf8312a61340d60a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of each sarray. <br /></td></tr>
<tr class="separator:a3718bbe5b6689eaf8312a61340d60a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1303ec9a1169fd55c777b24b3183d25d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a1303ec9a1169fd55c777b24b3183d25d">column_name</a> (size_t i) const </td></tr>
<tr class="separator:a1303ec9a1169fd55c777b24b3183d25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08621674b2a7e5b2a4a187a21abf4cc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a08621674b2a7e5b2a4a187a21abf4cc3">column_type</a> (size_t i) const </td></tr>
<tr class="separator:a08621674b2a7e5b2a4a187a21abf4cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f124b3729ebc9ab2cb9b277f55967a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93f124b3729ebc9ab2cb9b277f55967a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a93f124b3729ebc9ab2cb9b277f55967a">num_segments</a> () const </td></tr>
<tr class="memdesc:a93f124b3729ebc9ab2cb9b277f55967a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of segments in the SFrame. Does not throw. <br /></td></tr>
<tr class="separator:a93f124b3729ebc9ab2cb9b277f55967a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd2a91d573c863fee0522bbcc52519c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a1bd2a91d573c863fee0522bbcc52519c">segment_length</a> (size_t segment) const </td></tr>
<tr class="separator:a1bd2a91d573c863fee0522bbcc52519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8436e1f3bf6b68604643a125172ca6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a2c8436e1f3bf6b68604643a125172ca6">contains_column</a> (const std::string &amp;<a class="el" href="classturi_1_1sframe__reader.html#a1303ec9a1169fd55c777b24b3183d25d">column_name</a>) const </td></tr>
<tr class="separator:a2c8436e1f3bf6b68604643a125172ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa042cabeb6619f92856d1ca5e1b49b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html#a8aa042cabeb6619f92856d1ca5e1b49b">column_index</a> (const std::string &amp;<a class="el" href="classturi_1_1sframe__reader.html#a1303ec9a1169fd55c777b24b3183d25d">column_name</a>) const </td></tr>
<tr class="separator:a8aa042cabeb6619f92856d1ca5e1b49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c699d2a0d709a457da479d4eedd62b"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1siterable.html#af5c699d2a0d709a457da479d4eedd62b">read_rows</a> (size_t row_start, size_t row_end, std::vector&lt; typename sframe_iterator::value_type &gt; &amp;out_obj)=0</td></tr>
<tr class="separator:af5c699d2a0d709a457da479d4eedd62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classturi_1_1sframe__reader.html">sframe_reader</a> provides a reading interface to an <a class="el" href="classturi_1_1sframe.html">sframe</a> : an immutable on-disk set of columns, each with their own type. These types are represented as a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>.</p>
<p>The SFrame is represented as an ordered set of SArrays, each with an enforcable name and type. Each SArray in an SFrame must have the same number of segments as all other SArrays in the SFrame, which each must have the same number of elements as all other segments. A segment of an SFrame is a disjoint subset of rows with an entry from each column. Segments can be read in parallel.</p>
<p>To read from an sframe use <a class="el" href="classturi_1_1sframe.html#a1ee01e7a95370639b3335dc04086b6b5">sframe::get_reader()</a>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> reader = frame.get_reader();</div></div><!-- fragment --><p> reader will be of type <a class="el" href="classturi_1_1sframe__reader.html">sframe_reader</a></p>
<p>reader can then provide input iterators from segments via the <a class="el" href="classturi_1_1sframe__reader.html#a61ea963b7ab3c345101313e1ef37c140" title="Return the begin iterator of the segment. ">begin()</a> and <a class="el" href="classturi_1_1sframe__reader.html#aeeab87609ea0384ad75d85d2a07ce1d5" title="Return the end iterator of the segment. ">end()</a> functions. </p>

<p>Definition at line <a class="el" href="sframe__reader_8hpp_source.html#l00204">204</a> of file <a class="el" href="sframe__reader_8hpp_source.html">sframe_reader.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4a2a4078bf781e8a7382b133d0ab1bc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">turi::sframe_reader::sframe_reader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty sframe. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8aa042cabeb6619f92856d1ca5e1b49b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::sframe_reader::column_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the column index of column_name.</p>
<p>Throws an exception of the column_ does not exist. </p>

<p>Definition at line <a class="el" href="sframe__reader_8hpp_source.html#l00364">364</a> of file <a class="el" href="sframe__reader_8hpp_source.html">sframe_reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1303ec9a1169fd55c777b24b3183d25d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::sframe_reader::column_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the name of the given column. Throws an exception if the column id is out of range. </p>

<p>Definition at line <a class="el" href="sframe__reader_8hpp_source.html#l00318">318</a> of file <a class="el" href="sframe__reader_8hpp_source.html">sframe_reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08621674b2a7e5b2a4a187a21abf4cc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> turi::sframe_reader::column_type </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of the given column. Throws an exception if the column id is out of range. </p>

<p>Definition at line <a class="el" href="sframe__reader_8hpp_source.html#l00328">328</a> of file <a class="el" href="sframe__reader_8hpp_source.html">sframe_reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c8436e1f3bf6b68604643a125172ca6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::sframe_reader::contains_column </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the sframe contains the given column. </p>

<p>Definition at line <a class="el" href="sframe__reader_8hpp_source.html#l00353">353</a> of file <a class="el" href="sframe__reader_8hpp_source.html">sframe_reader.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba4de823399753f13e581d5ee2ef84a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe_reader::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_segments</em> = <code>(size_t)(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to construct an <a class="el" href="classturi_1_1sframe__iterator.html">sframe_iterator</a> which reads If the index file cannot be opened, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to read </td></tr>
    <tr><td class="paramname">num_segments</td><td>If num_segments == (size_t)(-1), the segmentation of the first column is used. Otherwise, the array is cut into num_segments number of logical segments which distribute the rows uniformly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0210d3a96886975b4edcc1239e0909a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe_reader::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>segment_lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to construct an <a class="el" href="classturi_1_1sframe__iterator.html">sframe_iterator</a> which reads from an existing sframe and uses a segmentation defined by an argument. If the index file cannot be opened, an exception is thrown. If the sum of the lengths of all the segments do not add up to the length of the sframe , an exception is thrown</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The frame to read </td></tr>
    <tr><td class="paramname">segment_lengths</td><td>An array describing the lengths of each segment. This must sum up to the length of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5c699d2a0d709a457da479d4eedd62b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t <a class="el" href="classturi_1_1siterable.html">turi::siterable</a>&lt; <a class="el" href="classturi_1_1sframe__iterator.html">sframe_iterator</a>  &gt;::read_rows </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename <a class="el" href="classturi_1_1sframe__iterator.html">sframe_iterator</a> ::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads a collection of rows, storing the result in out_obj. This function is independent of the begin/end iterator functions, and can be called anytime. This function is also fully concurrent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_start</td><td>First row to read </td></tr>
    <tr><td class="paramname">row_end</td><td>one past the last row to read (i.e. EXCLUSIVE). row_end can be beyond the end of the array, in which case, fewer rows will be read. </td></tr>
    <tr><td class="paramname">out_obj</td><td>The output array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual number of rows read. Return (size_t)(-1) on failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not always efficient. Different file formats implementations will have different characteristics. </dd></dl>

</div>
</div>
<a class="anchor" id="a4feb7756ff08277218afd7eaafc7b818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::sframe_reader::read_rows </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a collection of rows, storing the result in out_obj. This function is independent of the begin/end iterator functions, and can be called anytime. This function is also fully concurrent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_start</td><td>First row to read </td></tr>
    <tr><td class="paramname">row_end</td><td>one past the last row to read (i.e. EXCLUSIVE). row_end can be beyond the end of the array, in which case, fewer rows will be read. </td></tr>
    <tr><td class="paramname">out_obj</td><td>The output array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual number of rows read. Return (size_t)(-1) on failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not always efficient. Different file formats implementations will have different characteristics. </dd></dl>

</div>
</div>
<a class="anchor" id="a23d2e36b85ee65f9921c882ebf3c3e2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::sframe_reader::read_rows </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a> &amp;&#160;</td>
          <td class="paramname"><em>out_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a collection of rows, storing the result in out_obj. This function is independent of the begin/end iterator functions, and can be called anytime. This function is also fully concurrent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_start</td><td>First row to read </td></tr>
    <tr><td class="paramname">row_end</td><td>one past the last row to read (i.e. EXCLUSIVE). row_end can be beyond the end of the array, in which case, fewer rows will be read. </td></tr>
    <tr><td class="paramname">out_obj</td><td>The output array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual number of rows read. Return (size_t)(-1) on failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not always efficient. Different file formats implementations will have different characteristics. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8003689a903baa74c206c067d75bfd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe_reader::reset_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets all the file handles. All existing iterators are invalidated. </p>

<p>Implements <a class="el" href="classturi_1_1siterable.html#af76dc4c470ab6894d1859a5f687c47d9">turi::siterable&lt; sframe_iterator &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1bd2a91d573c863fee0522bbcc52519c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::sframe_reader::segment_length </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the length of the given segment. Throws an exception if the segment id is out of range. </p>

<p>Implements <a class="el" href="classturi_1_1siterable.html#ad3ed50d8fd6886df940c16d657566c7b">turi::siterable&lt; sframe_iterator &gt;</a>.</p>

<p>Definition at line <a class="el" href="sframe__reader_8hpp_source.html#l00343">343</a> of file <a class="el" href="sframe__reader_8hpp_source.html">sframe_reader.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/storage/sframe_data/<a class="el" href="sframe__reader_8hpp_source.html">sframe_reader.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="classturi_1_1sframe__reader.html">sframe_reader</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
