<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: Unity FFI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('unity_writing_toolkit.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Unity FFI </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Unity FFI layer describes the basic C++ &lt;&ndash;&gt; Python interface layer. Using this layer directly requires a decent breadth of knowledge of the underlying architecture. It is recommended that you first take a look at the serialization documentation, the <a class="el" href="using_cppipc.html">CPPIPC documentation</a>.</p>
<p>The unity system basically is a client-server architecture which uses the CPPIPC library to share objects on the server, to the client. The server is implemented in C++ toolkits/unity, and the client is implemented mostly in Cython in src/cython_interface. Much of the common code is in src/sframe/unity. This in theory allows the C++ and Python processes to be located in different processes, or even different machines / systems across the network. This is less efficient than sharing pointers between C++ and Python directly, but this provides a more generic interface for which the Python end can be easily swapped out to, for instance, support new languages.</p>
<h1><a class="anchor" id="unity_architecture_basic"></a>
Basic Types</h1>
<p>To allow effective communication between the server and the client (where the client is Python), we need to be able to translate between Python types and C++ types. However, since Python types are dynamic types, and C++ does not quite have an equivalent, we need to build a solution for this.</p>
<p>These two are the two key dynamic object types:</p>
<ul>
<li><a class="el" href="classturi_1_1flexible__type.html">turi::flexible_type</a> A runtime typed object capable of storing an integer, a double, a string, or vector&lt;double&gt;. It also can contain two recursive types, but these are at the moment not used. In Python, these are used in settings where I need to transport an object (say... a dictionary) containing elements of variable types to C++. For instance, a regular dictionary gets converted to std::map&lt;std::string, flexible_type&gt;.</li>
</ul>
<ul>
<li><a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">turi::variant_type</a> A more generic type that describes a union over a fixed set of types to support other stuff like passing SFrames, SArrays, SGraphs, or other user defined classes around. The flex</li>
</ul>
<h1><a class="anchor" id="unity_architecture_unity_types"></a>
Unity Types</h1>
<p>To expose a type X </p><ul>
<li>X_interface.hpp contains the CPPIPC interface descriptor. i.e. this contains the call to GENERATE_INTERFACE_AND_PROXY. The base class must be called X_base and the proxy class must be called X_proxy. </li>
<li>X.hpp/cpp contains the server-side implementation. X.hpp must NOT be included by X_interface.hpp. The server-side class is called X.</li>
</ul>
<p>For an example of the above convention, see unity_global.</p>
<p>For the unity subsystem, the following key types are exposed from the server to the client. We follow the following file naming convention for any exposed type.</p>
<ul>
<li><a class="el" href="classturi_1_1unity__global.html">turi::unity_global</a> The CPPIPC framework is fully object oriented, so an object is needed to to hold the miscellaneous "global function". And this is that object. It contains a collection of functions relating to the operation of the unity system, for instance, <a class="el" href="classturi_1_1unity__global.html#a4aabf668085939b602bfd93f7123735b">turi::unity_global::get_version()</a>, or turi::unity_global::list_toolkits(), or turi::unity_global::run_toolkits(). The interface is defined in <a class="el" href="unity__global__interface_8hpp_source.html">unity_global_interface.hpp</a>, and the base class is called <a class="el" href="classturi_1_1unity__global__base.html">turi::unity_global_base</a>. The proxy class is called turi::unity_global_proxy. The unity_global server-side object is in <a class="el" href="unity__global_8hpp_source.html">unity_global.hpp</a> and is called <a class="el" href="classturi_1_1unity__global.html">turi::unity_global</a>.</li>
</ul>
<ul>
<li><a class="el" href="classturi_1_1unity__sframe.html">turi::unity_sframe</a> This represents the immutable scalable Dataframe object. It is a lazy evaluated datastructure.</li>
</ul>
<ul>
<li><a class="el" href="classturi_1_1unity__sgraph.html">turi::unity_sgraph</a> This represents the immutable graph object and implements all the graph manipulation primitives. (object naming and file names all follow the convention above). Like the unity_sframe, the unity_sgraph implementation is that it is an immutable, dataflow, lazy-evaluated datastructure. The details of the object are out of scope of this brief paragraph, but to summarize quickly, the unity_sgraph datastructure wraps a shared_ptr to a node in a lazy evaluation graph (<a class="el" href="classturi_1_1lazy__eval__future.html">turi::lazy_eval_future</a>), which in turn evaluates to a unity_sgraph_impl object, where all the graph manipulation logic really lives.</li>
</ul>
<ul>
<li><a class="el" href="classturi_1_1model__base.html">turi::model_base</a> The model object describes the interface for the return type of all toolkit executions. This object breaks convention in that it can have numerous server-side implementations, as long as it implements the described interface. The interface is highly generic (essentially representing a generalized key-value map) to suit the purposes of almost all toolkits. This is what the SDK (turicreate_extension_interface) uses to export functionality to Python.</li>
</ul>
<h1><a class="anchor" id="unity_architecture_exposing_new_types"></a>
Exposing New Types to Python</h1>
<p>While The Extension interface (turicreate_extension_interface) should be sufficient for most purposes, on occasion it might be necessary to expose a new fundamental type to Python. This is unfortunately, a slightly involving process, but we do not expect this to happen too frequently (You should <b>really</b> use the extension interface).</p>
<p>On a high level, you first implement an object exposed via the CPPIPC interface. Then you need to persuade Cython to pick up the proxy object, and then further wrapping the proxy object in a Python class if necessary.</p>
<p>Lets walk through a simple example. Say we are going to expose a new type called "counter" which implements a simple integer counter with two functions, increment(int), and int get(). The tasks involved are essentially:</p>
<ul>
<li><a class="el" href="unity_writing_toolkit.html#unity_architecture_exposing_new_types_base">Creating Base and Proxy</a> </li>
<li><a class="el" href="unity_writing_toolkit.html#unity_architecture_exposing_new_types_impl">Creating the Implementation</a> </li>
<li><a class="el" href="unity_writing_toolkit.html#unity_architecture_exposing_new_types_registration">Registering the New Type</a> </li>
<li><a class="el" href="unity_writing_toolkit.html#unity_architecture_exposing_new_types_cython">Exposing the Proxy to Cython</a> </li>
<li><a class="el" href="unity_writing_toolkit.html#unity_architecture_exposing_new_types_usage">Using the Counter type</a></li>
</ul>
<h2><a class="anchor" id="unity_architecture_exposing_new_types_base"></a>
Creating Base and Proxy</h2>
<p>First, we create a new header for the CPPIPC base and proxy classes. Going with the convention, the file is called counter_interface.hpp</p>
<dl class="section note"><dt>Note</dt><dd>Much of this example is written without testing... If someone tries it, that would be fantastic</dd></dl>
<div class="fragment"><div class="line"><span class="comment">/// This is in src/model_server/lib/counter_interface.hpp</span></div><div class="line"><span class="comment"></span><span class="preprocessor">#ifndef TURI_COUNTER_INTERFACE_HPP</span></div><div class="line"><span class="preprocessor">#define TURI_COUNTER_INTERFACE_HPP</span></div><div class="line"><span class="preprocessor">#include &lt;core/system/cppipc/cppipc.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;core/system/cppipc/magic_macros.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceturi.html">turi</a> {</div><div class="line"></div><div class="line"><a class="code" href="group__cppipc.html#ga838dae619459dce33202c1e28ecc2966">GENERATE_INTERFACE_AND_PROXY</a>(counter_base, counter_proxy,</div><div class="line">                             (<span class="keywordtype">int</span>, <span class="keyword">get</span>, )</div><div class="line">                             (<span class="keywordtype">void</span>, increment, (<span class="keywordtype">int</span>))</div><div class="line">                            )</div><div class="line">} <span class="comment">// namespace turi</span></div></div><!-- fragment --><h2><a class="anchor" id="unity_architecture_exposing_new_types_impl"></a>
Creating the Implementation</h2>
<p>The implementation header is in in counter.hpp. (it must inherit from counter_base) </p><div class="fragment"><div class="line"><span class="comment">/// This is in src/model_server/lib/counter.hpp</span></div><div class="line"><span class="comment"></span><span class="preprocessor">#ifndef TURI_COUNTER_HPP</span></div><div class="line"><span class="preprocessor">#define TURI_COUNTER_HPP</span></div><div class="line"><span class="preprocessor">#include &lt;unity/lib/counter_interface.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceturi.html">turi</a> {</div><div class="line"></div><div class="line"><span class="keyword">class </span>counter: <span class="keyword">public</span> counter_base {</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> val;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  counter();</div><div class="line">  <span class="keywordtype">int</span> <span class="keyword">get</span>();</div><div class="line">  <span class="keywordtype">void</span> increment(<span class="keywordtype">int</span> v);</div><div class="line">};</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">} // namespace turi</span></div></div><!-- fragment --><p>And the implementation itself is in counter.cpp. While the hpp/cpp split is not strictly necessary (especially for such a simple class, it is still good practice.</p>
<div class="fragment"><div class="line"><span class="comment">/// This is in src/model_server/lib/counter.cpp</span></div><div class="line"><span class="comment"></span><span class="preprocessor">#ifndef TURI_COUNTER_HPP</span></div><div class="line"><span class="preprocessor">#define TURI_COUNTER_HPP</span></div><div class="line"><span class="preprocessor">#include &lt;unity/lib/counter.hpp&gt;</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceturi.html">turi</a> {</div><div class="line"></div><div class="line">counter::counter():val(0) { }</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> counter::get() {</div><div class="line">  <span class="keywordflow">return</span> val;</div><div class="line">}</div><div class="line"><span class="keywordtype">void</span> counter::increment(<span class="keywordtype">int</span> v) {</div><div class="line">  val += v;</div><div class="line">}</div><div class="line"></div><div class="line">} <span class="comment">// namespace turi</span></div></div><!-- fragment --><p>counter.cpp has to be added to the UNITY_FILES list in the unity CMakeLists.txt</p>
<h2><a class="anchor" id="unity_architecture_exposing_new_types_registration"></a>
Registering the New Type</h2>
<p>Finally, the type has to be registered with CPPIPC on the server side. See unity/server/unity_server.cpp (which implements the main() function for the unity_server) and look for a sequence of calls to</p>
<p><a class="el" href="classcppipc_1_1comm__server.html#ae1a4b406f8b0061a14e00634228ee8bd">cppipc::comm_server::register_type</a>, and add the lines: </p><div class="fragment"><div class="line">server-&gt;register_type&lt;turi::counter&gt;([](){</div><div class="line">                                          <span class="keywordflow">return</span> <span class="keyword">new</span> turi::counter();</div><div class="line">                                        });</div></div><!-- fragment --><p> Remember you have to include src/model_server/lib/counter.hpp at the top of unity_server.cpp.</p>
<p>Done!. Thats it to create a counter object and expose it via CPPIPC. Next, we need Python to be able to see the object type. And that is the tricky part.</p>
<h2><a class="anchor" id="unity_architecture_exposing_new_types_cython"></a>
Exposing the Proxy to Cython</h2>
<p>The counter_proxy object must now be exposed to python via cython. This is can be a mildly annoying process due to Cython oddities, especially if your functions take interesting types (like maps and vectors).</p>
<dl class="section note"><dt>Note</dt><dd>When interesting types are used, we suggest the use of dataframe, flexible_types (or the containers of flexible_types which are appropriate translators), or simple types which Cython have already implemented the translators for. The Cython documentation (<a href="http://docs.cython.org">http://docs.cython.org</a>) is an crucial resource (as poorly organized as it is).</dd></dl>
<p>All the Cython classes are implemented in src/python/turicreate/cython. To expose the counter object, first create a counter.pxd file (definition).</p>
<div class="fragment"><div class="line"><span class="comment"># This is in src/python/turicreate/cython/counter.pxd</span></div><div class="line">cdef extern <span class="keyword">from</span> <span class="stringliteral">&quot;&lt;unity/lib/counter_interface.hpp&gt;&quot;</span> namespace <span class="stringliteral">&#39;turi&#39;</span>:</div><div class="line">    cdef cppclass counter_proxy:</div><div class="line">        int get() <span class="keywordflow">except</span> +</div><div class="line">        void increment(int) <span class="keywordflow">except</span> +</div></div><!-- fragment --><p>Now, this just makes Cython aware of the counter_proxy type. We further wrap the counter_proxy object time with a Cython class which can ensure correct allocation and deletion behavior. This wrapper can also further wrap functions to provide translators from Python types to C++ types. It is also at this point, we can switch from C++ conventions to Python conventions.</p>
<div class="fragment"><div class="line"><span class="comment"># Continuing on in src/python/turicreate/cython/counter.pxd</span></div><div class="line">cdef <span class="keyword">class </span>Counter:</div><div class="line">    <span class="comment"># the wrapped proxy object</span></div><div class="line">    cdef counter_proxy* thisptr</div><div class="line">    <span class="comment"># a reference to the comm_client</span></div><div class="line">    cdef _cli</div><div class="line"></div><div class="line">    cpdef get(self)</div><div class="line"></div><div class="line">    cpdef increment(int v)</div></div><!-- fragment --><p>This new Counter class needs an implementation in counter.pyx</p>
<div class="fragment"><div class="line"><span class="comment"># In src/python/turicreate/cython/counter.pyx</span></div><div class="line"><span class="keyword">from</span> .ipc cimport PyCommClient</div><div class="line"></div><div class="line">cdef <span class="keyword">class </span>Counter:</div><div class="line">    <span class="keyword">def </span>__cinit__(self, PyCommClient cli):</div><div class="line">        <span class="keyword">assert</span> cli, <span class="stringliteral">&quot;CommClient is Null&quot;</span></div><div class="line">        self.thisptr = new counter_proxy(deref(cli.thisptr))</div><div class="line">        self._cli = cli</div><div class="line"></div><div class="line">    <span class="keyword">def </span>__dealloc__(self):</div><div class="line">        <span class="comment"># cleanup</span></div><div class="line">        del self.thisptr</div><div class="line"></div><div class="line">    cpdef get(self):</div><div class="line">        <span class="keywordflow">return</span> self.thisptr.get()</div><div class="line"></div><div class="line">    cpdef increment(int v)</div><div class="line">        self.thisptr.get(v)</div></div><!-- fragment --><h2><a class="anchor" id="unity_architecture_exposing_new_types_usage"></a>
Using the Counter type</h2>
<p>Now, in Python, once a a connection has been established, a counter object can be created with</p>
<div class="fragment"><div class="line">c = Counter(turicreate.connect.getConn())</div><div class="line">c.increment(5)</div><div class="line">c.get() <span class="comment"># returns 5</span></div><div class="line">c.increment(2)</div><div class="line">c.get() <span class="comment"># returns 7</span></div></div><!-- fragment --><p>Note that in some situations, you may in fact want to rename the Counter class as CounterProxy, and further wrap it with a Counter class fully implemented in Python. For instance, this is done with the Graph object to provide a fully Pythonic interface (The Cython cdef limitations can make it very difficult to implement interesting functions).</p>
<h1><a class="anchor" id="unity_implementing_toolkits"></a>
Implementing Toolkits</h1>
<p>This section describes the old toolkit interface, a <b>deprecated</b> method for exporting objects and methods to Python. The new SDK method via turicreate_extension_interface is preferred.</p>
<p>A toolkit is very simply stated, a collection of functions, all with a common input/output interface. That is: </p><div class="fragment"><div class="line">turi::toolkit_response_type exec(turi::toolkit_invocation&amp; invoke);</div></div><!-- fragment --><p> Both toolkit_invocation and toolkit_response are highly generic, and mainly contain a special map datastructure called turi::variant_map_type which can contain within it, a graph, a dataframe, a model or a flexible_type, and has automatic translators to and from Python.</p>
<p>A toolkit may contain many functions of the above form, and to expose it to the unity_server requires the writing of a "registration" function of the type: </p><div class="fragment"><div class="line">std::vector&lt;turi::toolkit_specification&gt; get_registration();</div></div><!-- fragment --><p> which basically lists all the functions to expose.</p>
<p>Lets try this out with a simple example. We are going to implement a toolkit which simply adds one to an input integer/float. This is actually fully implemented in unity/server/toolkits/demo_addone.* files.</p>
<ul>
<li>unity_implementing_toolkits_add_one </li>
<li>unity_implementing_toolkits_registration </li>
<li>unity_implementing_toolkits_usage</li>
</ul>
<h2><a class="anchor" id="unity_implementing_toolkits_add_one"></a>
Toolkit Implementation</h2>
<p>The invoke datastructure basically contains within it a member called "params" which is really a map from string to a <a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">turi::variant_type</a> variant type. This type is special because it is wrappers are implemented so that it is correctly recognized by Python and can be correctly converted to and from a Python dictionary.</p>
<p>We first implement the toolkit. Since the toolkit essentially takes a map as an input, and a map as an output, it is up to us to specify the actual argument interface (i.e. what the contents of the map should be). Here, we state that the input map should have a field "x" which contains either an integer, or a float. The return map should also have a field "x" which is of the same type as the input, but contains the value incremented by one.</p>
<div class="fragment"><div class="line"><span class="comment">// in demo_addone.cpp</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceturi.html">turi</a> {</div><div class="line">namespce demo_addone {</div><div class="line">toolkit_response_type add_one(toolkit_invocation&amp; invoke) {</div><div class="line">  toolkit_response_type ret_status;</div><div class="line"></div><div class="line">  <span class="comment">// you should always parse all the arguments first.</span></div><div class="line">  <span class="comment">// turi::safe_varmap_map will throw a descriptive string exception</span></div><div class="line">  <span class="comment">// on failure.</span></div><div class="line">  flexible_type x = safe_varmap_get&lt;flexible_type&gt;(invoke.params, <span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Check if the types are correct. If anything is incorrect,</span></div><div class="line">  <span class="comment">// we throw a string which will get printed on the client side.</span></div><div class="line">  <span class="keywordflow">if</span> (x.get_type() == <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a5d5cd46919fa987731fb2edefe0f2a0c">flex_type_enum::INTEGER</a> ||</div><div class="line">      x.get_type() == <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>) {</div><div class="line">    x = x + 1;</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;x of invalid type. Must be an integer or a float!&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// return the output, flagging success.</span></div><div class="line">  ret_status.params[<span class="stringliteral">&quot;x&quot;</span>] = x;</div><div class="line">  ret_status.success = <span class="keyword">true</span>;</div><div class="line">  <span class="keywordflow">return</span> ret_status;</div><div class="line">}</div><div class="line">} <span class="comment">// namespace demo_addone</span></div><div class="line">} <span class="comment">// namespace turi</span></div></div><!-- fragment --><p>Thats it!</p>
<h2><a class="anchor" id="unity_implementing_toolkits_registration"></a>
Toolkit Registration</h2>
<p>Now, to implement the registration function. This is quite straightforward. Basically, it just associates the C++ function with a name.</p>
<div class="fragment"><div class="line"><span class="comment">// in demo_addone.cpp</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceturi.html">turi</a> {</div><div class="line">namespce demo_addone {</div><div class="line"></div><div class="line">std::vector&lt;toolkit_specification&gt; get_registration() {</div><div class="line">  toolkit_specification spec;</div><div class="line">  spec.name = <span class="stringliteral">&quot;demo_addone&quot;</span>;</div><div class="line">  spec.toolkit_execute_function = add_one;</div><div class="line">  <span class="keywordflow">return</span> {spec};</div><div class="line">}</div><div class="line"></div><div class="line">} <span class="comment">// namespace demo_addone</span></div><div class="line">} <span class="comment">// namespace turi</span></div></div><!-- fragment --><p>A demo_addone.hpp should also be created which exposes the get_registration() function. Finally, the unity_server binary (in src/server/unity_server.cpp) must register the toolkit. (Search for a collection of register_toolkit calls) </p><div class="fragment"><div class="line">g_toolkits-&gt;register_toolkit(turi::demo_addone::get_registration());</div></div><!-- fragment --><p> The demo_addone.hpp must of course be included at the top of unity_server.cpp</p>
<h2><a class="anchor" id="unity_implementing_toolkits_usage"></a>
Toolkit Usage</h2>
<p>Thats it! To run from Python:</p>
<div class="fragment"><div class="line">val = {<span class="stringliteral">&#39;x&#39;</span>:5}</div><div class="line"><span class="keyword">import</span> turicreate.toolkits.main <span class="keyword">as</span> main</div><div class="line">ret = main.run(<span class="stringliteral">&quot;demo_addone&quot;</span>, val)</div></div><!-- fragment --><h2><a class="anchor" id="unity_implementing_advanced_toolkits"></a>
Advanced Toolkits</h2>
<p>While the above is a simple demonstration of the toolkit interface, it covers all the key concepts of toolkit implementation. Much of the rest of the work of implementing a toolkit is in making the interface friendly.</p>
<ul>
<li>Wrapping the toolkit call in Python to make the interface friendly. </li>
<li>Providing incremental metrics via the simple metrics interface </li>
<li>If toolkit should return a complex state that should not be all communicated back to the client, toolkit should instead store an return a model object, in which case the Python-side has to provide a friendly interface for the model object.</li>
</ul>
<p>It might be useful to see the pagerank toolkit to see how this is done. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="unity_lib.html">Unity Library</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
