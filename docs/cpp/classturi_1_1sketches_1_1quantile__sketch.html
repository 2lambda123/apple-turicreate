<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: turi::sketches::quantile_sketch&lt; T, Comparator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1sketches_1_1quantile__sketch.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classturi_1_1sketches_1_1quantile__sketch-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::sketches::quantile_sketch&lt; T, Comparator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__sketching.html">Sketching Datastructures and Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="quantile__sketch_8hpp_source.html">ml/sketches/quantile_sketch.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5204dc0a1ebb5448669a1e214e4b243d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a5204dc0a1ebb5448669a1e214e4b243d">quantile_sketch</a> ()</td></tr>
<tr class="separator:a5204dc0a1ebb5448669a1e214e4b243d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18252bc6968326a3c3e0771fe1d2ef7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#ad18252bc6968326a3c3e0771fe1d2ef7">quantile_sketch</a> (size_t desired_n, double epsilon=0.005, const Comparator &amp;comparator=Comparator())</td></tr>
<tr class="separator:ad18252bc6968326a3c3e0771fe1d2ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17968d6d02bec92a05a31556d5c53aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a17968d6d02bec92a05a31556d5c53aa8">init</a> (size_t desired_n, double epsilon, const Comparator &amp;comparator=Comparator())</td></tr>
<tr class="separator:a17968d6d02bec92a05a31556d5c53aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915e64286e69c7b76d0faa7009f58694"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a915e64286e69c7b76d0faa7009f58694">sketch_size</a> ()</td></tr>
<tr class="separator:a915e64286e69c7b76d0faa7009f58694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a21d5c4f7d26a1de81ab72621c1313b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a3a21d5c4f7d26a1de81ab72621c1313b">memory_usage</a> ()</td></tr>
<tr class="separator:a3a21d5c4f7d26a1de81ab72621c1313b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743abb8c8b102b867ff495d52b522dd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a743abb8c8b102b867ff495d52b522dd5">add</a> (T t)</td></tr>
<tr class="separator:a743abb8c8b102b867ff495d52b522dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e08d94476e66ff833d6923674403ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a47e08d94476e66ff833d6923674403ee">finalize</a> ()</td></tr>
<tr class="separator:a47e08d94476e66ff833d6923674403ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb392cde1b37db8d14d6d8b7c25eeabd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#adb392cde1b37db8d14d6d8b7c25eeabd">size</a> () const</td></tr>
<tr class="separator:adb392cde1b37db8d14d6d8b7c25eeabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c41e9db0c8282e50a5898eafd43c442"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a4c41e9db0c8282e50a5898eafd43c442">query</a> (size_t rank) const</td></tr>
<tr class="separator:a4c41e9db0c8282e50a5898eafd43c442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d3fde5d846ad27937144a8c94bd765"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#aa5d3fde5d846ad27937144a8c94bd765">query_quantile</a> (double quantile) const</td></tr>
<tr class="separator:aa5d3fde5d846ad27937144a8c94bd765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833793f8bf9e5113189be02cfcdb4d43"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a833793f8bf9e5113189be02cfcdb4d43">fast_query</a> (size_t rank) const</td></tr>
<tr class="separator:a833793f8bf9e5113189be02cfcdb4d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae902ebe8d93516d6da7b459ea46468f7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#ae902ebe8d93516d6da7b459ea46468f7">fast_query_quantile</a> (double quantile) const</td></tr>
<tr class="separator:ae902ebe8d93516d6da7b459ea46468f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec8ac3070fe7de589d07b7338da6707"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a7ec8ac3070fe7de589d07b7338da6707">combine</a> (const <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">quantile_sketch</a> &amp;other)</td></tr>
<tr class="separator:a7ec8ac3070fe7de589d07b7338da6707"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt;<br />
class turi::sketches::quantile_sketch&lt; T, Comparator &gt;</h3>

<p>This class implements a quantile sketching datastructure as described in Qi Zhang and Wei Wang. A Fast Algorithm for Approximate Quantiles in High Speed Data Streams. SSDBM 2007.</p>
<p>It constructs a low memory sketch from a stream of known length. To summarize the basic idea, it draws samples from the stream and maintains for each sample a lower bound and an upper bound on its rank in the stream.</p>
<p>The known length condition is not strictly true. While the sketch is constructed for particular stream length N, this datastructure does not limit the number of elements can be inserted, but then in which case the accuracy guarantee no longer applies.</p>
<p>Usage is simple: </p><div class="fragment"><div class="line"><span class="comment">// construct sketch at a particular size</span></div><div class="line">quantile_sketch&lt;double&gt; sketch(100000, 0.01);</div><div class="line">...</div><div class="line">insert any number elements into the sketch <span class="keyword">using</span></div><div class="line">quality guarantees only apply when &lt;100000 elements are inserted.</div><div class="line">sketch.add(value)</div><div class="line">...</div><div class="line">sketch.finalize() <span class="comment">// finalize must be called before queries can be made</span></div></div><!-- fragment --><p>To query, two family of functions are provided.</p>
<p>The regular query functions take linear time in the size of the sketch, and have accuracy guarantees when &lt;=desired_n elements are inserted (100000 elements in the above example) </p><div class="fragment"><div class="line">sketch.query(rank) <span class="comment">// rank is between [0, N-1]</span></div><div class="line">sketch.query_quantile(quantile) <span class="comment">// quantile is between [0, 1.0]</span></div></div><!-- fragment --><p>The fast query functions take logarithmic time in the size of the sketch, and have no accuracy guarantees. </p><div class="fragment"><div class="line">sketch.fast_query(rank) <span class="comment">// rank is between [0, N-1]</span></div><div class="line">sketch.fast_query_quantile(quantile) <span class="comment">// quantile is between [0, 1.0]</span></div></div><!-- fragment --><p>The sketch structure also support parallel sketching:</p>
<p>Example: If I have 16 data streams, each of size N/16 I can construct 16 quantile_sketches, each initialized with desired_n = N (note. N here! not N/16)</p>
<p>Each sketch can then be ran on each data stream independently. Then all can be combined into one:</p>
<div class="fragment"><div class="line"><a class="code" href="classturi_1_1sketches_1_1quantile__sketch.html#a5204dc0a1ebb5448669a1e214e4b243d">quantile_sketch</a> sketch(N)</div><div class="line"><span class="keywordflow">for each</span> sub-stream sketch:</div><div class="line">  sketch.combine(sub-stream-sketch)</div><div class="line">sketch.finalize()</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>to contain in the sketch. type must be less-than-comparable, constructible, copy constructible, assignable.</td></tr>
  </table>
  </dd>
</dl>
<h2>Technical Details </h2>
<p>The basic mechanic of the sketch lies in making a hierarchy of sketches, each having size m_b. The first sketch has error 0. The second sketch has error 1/b, the 3rd sketch has error 2/b and so on. These sketches are treated like a binary sequence:</p><ul>
<li>When a buffer of size b has been accumulated, it gets sorted and inserted into sketch 1</li>
<li>If sketch 1 exists, the two are merged (no increase in error) and compressed (increase error by 1/b) and the result tries to get placed as sketch 2.</li>
<li>If sketch 2 exists, this repeats.</li>
</ul>
<p>The procedure thus seem like binary addition.</p>
<p>By picking the size b appropriately for a given value of N and , At the end, all the sketches can be merged to get a sketch of error .</p>
<p>Here is where we deviate from the paper slightly. The "compress" procedure has the advantage of decreasing the total amount of memory required, By finishing/finalizing with a simple merge, means that the resultant array could be much bigger than desired. The way the binary addition works, also means the resultant sketch size is somewhat unpredictable. Thus here lies the modification.</p>
<p>We compute the sketch as usual, but sizing "b" to end up with a final merged error of  / 2. We then perform one addition compress(/2) phase to compress the final sketch into requiring only O(1/epsilon) memory. </p>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00118">118</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5204dc0a1ebb5448669a1e214e4b243d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5204dc0a1ebb5448669a1e214e4b243d">&#9670;&nbsp;</a></span>quantile_sketch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::<a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">quantile_sketch</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. Does nothing. <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a17968d6d02bec92a05a31556d5c53aa8">init()</a> MUST be called before any operations are performed. </p>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00125">125</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<a id="ad18252bc6968326a3c3e0771fe1d2ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18252bc6968326a3c3e0771fe1d2ef7">&#9670;&nbsp;</a></span>quantile_sketch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::<a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">quantile_sketch</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>desired_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.005</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comparator &amp;&#160;</td>
          <td class="paramname"><em>comparator</em> = <code>Comparator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">quantile_sketch</a> with a desired target number of elements, and a desired accuracy. See <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a17968d6d02bec92a05a31556d5c53aa8">init()</a> for details. </p>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00131">131</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a743abb8c8b102b867ff495d52b522dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743abb8c8b102b867ff495d52b522dd5">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::add </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a value into the sketch. Not safe to use in parallel. </p>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00225">225</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<a id="a7ec8ac3070fe7de589d07b7338da6707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec8ac3070fe7de589d07b7338da6707">&#9670;&nbsp;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::combine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">quantile_sketch</a>&lt; T, Comparator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges two unfinalized <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">quantile_sketch</a> into one quantile sketch. Both this and the other quantile sketch must not be finalized(). This allows two quantile sketches to be generated on two disjoint streams of data, and then combined at the end. For quality guarantees to apply, BOTH sketches must be constructed with the final number of elements.</p>
<p>Example: If I have 16 data streams, each of size N/16 I can construct 16 quantile_sketches, each initialized with desired_n = N (note. N here! not N/16)</p>
<p>Each sketch can then be ran on each data stream independently. Then all can be combined into one:</p>
<div class="fragment"><div class="line"><a class="code" href="classturi_1_1sketches_1_1quantile__sketch.html#a5204dc0a1ebb5448669a1e214e4b243d">quantile_sketch</a> sketch(N)</div><div class="line"><span class="keywordflow">for each</span> sub-stream sketch:</div><div class="line">  sketch.combine(sub-stream-sketch)</div><div class="line">sketch.finalize()</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The predictions produced by the combined sketch is not generally going to be the same as the sequentially produced sketch </dd></dl>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00461">461</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<a id="a833793f8bf9e5113189be02cfcdb4d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833793f8bf9e5113189be02cfcdb4d43">&#9670;&nbsp;</a></span>fast_query()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::fast_query </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quickly queries for the value at rank k of all the elements inserted. Assuming N elements are inserted. Rank 0 will be the minimum value, rank N-1, the maximum value.</p>
<p>Note that this rank is in relation to the total number of elements inserted. For instance, </p><div class="fragment"><div class="line">quantile_sketch&lt;double&gt; sketch(1000);</div><div class="line">...</div><div class="line">insert 10,000 elements into the sketch</div></div><!-- fragment --><p> sketch.fast_query(9999) will be the maximum.</p>
<p>Unlike <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a4c41e9db0c8282e50a5898eafd43c442">query()</a>, this function is never guaranteed to provide an epsilon error bound. Instead, this function assumes that each element in the sketch has a point estimate of its rank (the center of its rmin/rmax range), and looks for the element closest to the desired rank.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a47e08d94476e66ff833d6923674403ee">finalize()</a> must be called prior to using this function.</dd>
<dd>
The complexity of this function is logarithmic in the sketch size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00405">405</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<a id="ae902ebe8d93516d6da7b459ea46468f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae902ebe8d93516d6da7b459ea46468f7">&#9670;&nbsp;</a></span>fast_query_quantile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::fast_query_quantile </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantile</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quickly returns the value at a quantile. For instance: </p><div class="fragment"><div class="line">sketch.fast_query_quantile(0.01) <span class="comment">// returns the 1% quantile</span></div><div class="line">sketch.fast_query_quantile(0.50) <span class="comment">// returns the median</span></div><div class="line">sketch.fast_query_quantile(1.00) <span class="comment">// returns the max</span></div></div><!-- fragment --><p>quantile values below 0 will be interpreted as 0 (hence the minimum). quantile values above 1 will be interpreted as 1 (hence the maximum).</p>
<p>Unlike <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#aa5d3fde5d846ad27937144a8c94bd765">query_quantile()</a>, this function is never guaranteed to provide an epsilon error bound. Instead, this function assumes that each element in the sketch has a point estimate of its rank (the center of its rmin/rmax range), and looks for the element closest to the desired rank.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a47e08d94476e66ff833d6923674403ee">finalize()</a> must be called prior to using this function.</dd>
<dd>
The complexity of this function is logarithmic in the sketch size. </dd></dl>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00430">430</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<a id="a47e08d94476e66ff833d6923674403ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e08d94476e66ff833d6923674403ee">&#9670;&nbsp;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finalizes the sketch datastructure. Must be called before queries are made. Once <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a47e08d94476e66ff833d6923674403ee">finalize()</a> is called, elements may no longer be inserted. </p>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00247">247</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<a id="a17968d6d02bec92a05a31556d5c53aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17968d6d02bec92a05a31556d5c53aa8">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>desired_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comparator &amp;&#160;</td>
          <td class="paramname"><em>comparator</em> = <code>Comparator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the quantile sketch, resetting it. epsilon is the desired accuracy of the quantiles. An -approximate quantile is an element in the data stream whose approximate rank r' is within [r- n and r +  n] i.e. a 0.0001 approximate median in a 1,000,000 element array may have true rank [499,000, and 501,000].</p>
<p>The runtime memory requirements of this sketch is O((1/) (log  N)^2) The final memory requirements after finalization is O(1/).</p>
<p>To give a sense of the runtime memory requirements, at  = 0.01 </p><pre class="fragment">* N = 100,000: sketch has size = 45528 bytes
* N = 1,000,000: sketch has size = 96144 bytes
* N = 10,000,000: sketch has size = 123504 bytes
* N = 100,000,000: sketch has size = 316536 bytes
* </pre><p>(Increasing N by 10 roughly increases the sketch size by 2. Note that the growth function is a little wierd. this is due to the structure of the algorithm which maintains multi-level sketches, then during the final phase, just merging all those sketches together. This results in somewhat oddly behaved memory utilization as a function of N.)</p>
<p>At N = 1,000,000 </p><pre class="fragment">* epsilon = 0.1: sketch has size = 12480 bytes
* epsilon = 0.01: sketch has size = 96144 bytes
* epsilon = 0.001: sketch has size = 442776 bytes
* epsilon = 0.0001: sketch has size = 3271440 bytes
* </pre><p>(decreasing epsilon by 10 roughly increases the sketch size by 5)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desired_n</td><td>An UPPER BOUND on the number of elements to be inserted, to guarantee epsilon accuracy. The epsilon accuracy guarantee is only true if you do not insert more than n elements. </td></tr>
    <tr><td class="paramname">epsilon</td><td>The desired accuracy </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00178">178</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<a id="a3a21d5c4f7d26a1de81ab72621c1313b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a21d5c4f7d26a1de81ab72621c1313b">&#9670;&nbsp;</a></span>memory_usage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::memory_usage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the approximate current memory usage of the sketch in bytes. </p>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00218">218</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<a id="a4c41e9db0c8282e50a5898eafd43c442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c41e9db0c8282e50a5898eafd43c442">&#9670;&nbsp;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::query </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queries for the value at rank k of all the elements inserted. Assuming N elements are inserted. Rank 0 will be the minimum value, rank N-1, the maximum value.</p>
<p>Note that this rank is in relation to the total number of elements inserted. For instance, </p><div class="fragment"><div class="line">quantile_sketch&lt;double&gt; sketch(1000);</div><div class="line">...</div><div class="line">insert 10,000 elements into the sketch</div></div><!-- fragment --><p> sketch.query(9999) will be the maximum.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a47e08d94476e66ff833d6923674403ee">finalize()</a> must be called prior to using this function.</dd>
<dd>
This function is guaranteed to provide an epsilon accurate value if only the desired number of elements (as set in the constructor) are inserted. In all other cases, this may not.</dd>
<dd>
The complexity of this function can be logarithmic in the sketch size in the best case (appears to be all the time, empirically), or linear in the worst case. Essentially, it first tests the result of the fast_query to see if that fits the bound requirements. If it does not, it takes a full linear search. The fast_query seems to work pretty much all the time on randomized inputs of varying distributions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00295">295</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<a id="aa5d3fde5d846ad27937144a8c94bd765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d3fde5d846ad27937144a8c94bd765">&#9670;&nbsp;</a></span>query_quantile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::query_quantile </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantile</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value at a quantile. For instance: </p><div class="fragment"><div class="line">sketch.query_quantile(0.01) <span class="comment">// returns the 1% quantile</span></div><div class="line">sketch.query_quantile(0.50) <span class="comment">// returns the median</span></div><div class="line">sketch.query_quantile(1.00) <span class="comment">// returns the max</span></div></div><!-- fragment --><p>quantile values below 0 will be interpreted as 0 (hence the minimum). quantile values above 1 will be interpreted as 1 (hence the maximum).</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html#a47e08d94476e66ff833d6923674403ee">finalize()</a> must be called prior to using this function.</dd>
<dd>
This function is guaranteed to provide an epsilon accurate value if only the desired number of elements (as set in the constructor) are inserted. In all other cases, this may not.</dd>
<dd>
The complexity of this function can be logarithmic in the sketch size in the best case (appears to be all the time, empirically), or linear in the worst case. Essentially, it first tests the result of the fast_query to see if that fits the bound requirements. If it does not, it takes a full linear search. The fast_query seems to work pretty much all the time on randomized inputs of varying distributions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00376">376</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<a id="adb392cde1b37db8d14d6d8b7c25eeabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb392cde1b37db8d14d6d8b7c25eeabd">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements inserted into the sketch. </p>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00264">264</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<a id="a915e64286e69c7b76d0faa7009f58694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915e64286e69c7b76d0faa7009f58694">&#9670;&nbsp;</a></span>sketch_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Comparator = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">turi::sketches::quantile_sketch</a>&lt; T, Comparator &gt;::sketch_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements stored in the sketch </p>

<p class="definition">Definition at line <a class="el" href="quantile__sketch_8hpp_source.html#l00206">206</a> of file <a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ml/sketches/<a class="el" href="quantile__sketch_8hpp_source.html">quantile_sketch.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><b>sketches</b></li><li class="navelem"><a class="el" href="classturi_1_1sketches_1_1quantile__sketch.html">quantile_sketch</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
