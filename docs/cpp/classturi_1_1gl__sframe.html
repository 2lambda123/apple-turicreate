<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Turi Create: turi::gl_sframe Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1gl__sframe.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classturi_1_1gl__sframe-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::gl_sframe Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="gl__sframe_8hpp_source.html">core/data/sframe/gl_sframe.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78e4306bd76ecfa597bde4244dee49aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78e4306bd76ecfa597bde4244dee49aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> ()</td></tr>
<tr class="memdesc:a78e4306bd76ecfa597bde4244dee49aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. <br /></td></tr>
<tr class="separator:a78e4306bd76ecfa597bde4244dee49aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0201b3d8714933fb0d220f4e04bbde8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0201b3d8714933fb0d220f4e04bbde8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#aa0201b3d8714933fb0d220f4e04bbde8">gl_sframe</a> (const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;)</td></tr>
<tr class="memdesc:aa0201b3d8714933fb0d220f4e04bbde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor. <br /></td></tr>
<tr class="separator:aa0201b3d8714933fb0d220f4e04bbde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93c1425d65c57bc823ab85cd2e2f26d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad93c1425d65c57bc823ab85cd2e2f26d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ad93c1425d65c57bc823ab85cd2e2f26d">gl_sframe</a> (<a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;&amp;)</td></tr>
<tr class="memdesc:ad93c1425d65c57bc823ab85cd2e2f26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Constructor. <br /></td></tr>
<tr class="separator:ad93c1425d65c57bc823ab85cd2e2f26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135cdb74a59901e51564ddcfc7880f83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a135cdb74a59901e51564ddcfc7880f83">gl_sframe</a> (const std::string &amp;directory)</td></tr>
<tr class="separator:a135cdb74a59901e51564ddcfc7880f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa86422340f6320da5434e0cafca193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a0fa86422340f6320da5434e0cafca193">construct_from_csvs</a> (std::string csv_file, csv_parsing_config_map csv_config, str_flex_type_map column_type_hints)</td></tr>
<tr class="separator:a0fa86422340f6320da5434e0cafca193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2363c318a5a106ec950205981426faa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2363c318a5a106ec950205981426faa"></a>
<a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#aa2363c318a5a106ec950205981426faa">operator=</a> (const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;)</td></tr>
<tr class="memdesc:aa2363c318a5a106ec950205981426faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment. <br /></td></tr>
<tr class="separator:aa2363c318a5a106ec950205981426faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59907b61a027f58f8dfa16ce52d8fc57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59907b61a027f58f8dfa16ce52d8fc57"></a>
<a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a59907b61a027f58f8dfa16ce52d8fc57">operator=</a> (<a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;&amp;)</td></tr>
<tr class="memdesc:a59907b61a027f58f8dfa16ce52d8fc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment. <br /></td></tr>
<tr class="separator:a59907b61a027f58f8dfa16ce52d8fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af540e300aebd52885b5f20fcfb446e3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#af540e300aebd52885b5f20fcfb446e3f">show</a> (const std::string &amp;path_to_client) const </td></tr>
<tr class="separator:af540e300aebd52885b5f20fcfb446e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb517440b96be7d81a8da8ffdf68b406"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1model__base.html">model_base</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#aeb517440b96be7d81a8da8ffdf68b406">plot</a> () const </td></tr>
<tr class="separator:aeb517440b96be7d81a8da8ffdf68b406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd178007b6231606d86d2f16f988e4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#aefd178007b6231606d86d2f16f988e4d">gl_sframe</a> (const std::map&lt; std::string, std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &amp;data)</td></tr>
<tr class="separator:aefd178007b6231606d86d2f16f988e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dee5eef29adf9bfe588885fcc5b185"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#af9dee5eef29adf9bfe588885fcc5b185">gl_sframe</a> (const std::map&lt; std::string, <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &gt; &amp;data)</td></tr>
<tr class="separator:af9dee5eef29adf9bfe588885fcc5b185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8162175a620ffa87ff0a9c25c92e033b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a8162175a620ffa87ff0a9c25c92e033b">gl_sframe</a> (std::initializer_list&lt; std::pair&lt; std::string, <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &gt;&gt;)</td></tr>
<tr class="separator:a8162175a620ffa87ff0a9c25c92e033b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258f8beb81645e5ae540fb2a702e5685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a258f8beb81645e5ae540fb2a702e5685">operator[]</a> (const <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &amp;logical_filter) const </td></tr>
<tr class="separator:a258f8beb81645e5ae540fb2a702e5685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efaca3b4931004192bac3e7b10aaec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a9efaca3b4931004192bac3e7b10aaec9">materialize_to_callback</a> (std::function&lt; bool(size_t, const std::shared_ptr&lt; <a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a> &gt; &amp;)&gt; callback, size_t nthreads=(size_t)(-1))</td></tr>
<tr class="separator:a9efaca3b4931004192bac3e7b10aaec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628d77e61284ac2ab876fee7881136ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe__range.html">gl_sframe_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a628d77e61284ac2ab876fee7881136ad">range_iterator</a> (size_t start=0, size_t end=(size_t)(-1)) const </td></tr>
<tr class="separator:a628d77e61284ac2ab876fee7881136ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996a165e932c322c003d3be275e32b6e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a996a165e932c322c003d3be275e32b6e">size</a> () const </td></tr>
<tr class="separator:a996a165e932c322c003d3be275e32b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcbec920508d8cbab095a9e308331f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#aedcbec920508d8cbab095a9e308331f7">empty</a> () const </td></tr>
<tr class="separator:aedcbec920508d8cbab095a9e308331f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b8e24216433856d64126ab3b12b7c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a25b8e24216433856d64126ab3b12b7c6">is_materialized</a> () const </td></tr>
<tr class="separator:a25b8e24216433856d64126ab3b12b7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e5666b09b30317ec397b5266c2f4be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ab8e5666b09b30317ec397b5266c2f4be">has_size</a> () const </td></tr>
<tr class="separator:ab8e5666b09b30317ec397b5266c2f4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf487ad5b75b7cff5e0aef3cf54857fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#adf487ad5b75b7cff5e0aef3cf54857fb">materialize</a> ()</td></tr>
<tr class="separator:adf487ad5b75b7cff5e0aef3cf54857fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9148b0602a4c59730c6c0e6b77ddbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a7c9148b0602a4c59730c6c0e6b77ddbd">save</a> (const std::string &amp;path, const std::string &amp;format=&quot;&quot;) const </td></tr>
<tr class="separator:a7c9148b0602a4c59730c6c0e6b77ddbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab406e6e4714b58b82bbe0b821db4fff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#aab406e6e4714b58b82bbe0b821db4fff">save_reference</a> (const std::string &amp;path) const </td></tr>
<tr class="separator:aab406e6e4714b58b82bbe0b821db4fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04011513cb649b8b0fdc4105eeb2281d"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a04011513cb649b8b0fdc4105eeb2281d">column_types</a> () const </td></tr>
<tr class="separator:a04011513cb649b8b0fdc4105eeb2281d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e201949eec3ae44e18cdaecfee15ef5"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a5e201949eec3ae44e18cdaecfee15ef5">num_columns</a> () const </td></tr>
<tr class="separator:a5e201949eec3ae44e18cdaecfee15ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ec072e385fe36c6c26905847d6d8a4"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a60ec072e385fe36c6c26905847d6d8a4">column_names</a> () const </td></tr>
<tr class="separator:a60ec072e385fe36c6c26905847d6d8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c74f5d14bb621ce71251c05dd37573"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a25c74f5d14bb621ce71251c05dd37573">contains_column</a> (const std::string &amp;col_name) const </td></tr>
<tr class="separator:a25c74f5d14bb621ce71251c05dd37573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ef4ac30b1c59786e9ee3042e323451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a53ef4ac30b1c59786e9ee3042e323451">head</a> (size_t n) const </td></tr>
<tr class="separator:a53ef4ac30b1c59786e9ee3042e323451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2647e8daca2846e317eef54bb2eeae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ad2647e8daca2846e317eef54bb2eeae1">tail</a> (size_t n) const </td></tr>
<tr class="separator:ad2647e8daca2846e317eef54bb2eeae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11b87f882679d051106fbbf2fb73507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ab11b87f882679d051106fbbf2fb73507">apply</a> (std::function&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>(const <a class="el" href="structturi_1_1sframe__rows_1_1row.html">sframe_rows::row</a> &amp;)&gt; fn, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> dtype) const </td></tr>
<tr class="separator:ab11b87f882679d051106fbbf2fb73507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e4c4f7bf5d52ecbdfb0d2728e54298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a65e4c4f7bf5d52ecbdfb0d2728e54298">sample</a> (double fraction) const </td></tr>
<tr class="separator:a65e4c4f7bf5d52ecbdfb0d2728e54298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8611489111164e4e3712f18069b2fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a0f8611489111164e4e3712f18069b2fb">sample</a> (double fraction, size_t seed, bool exact=false) const </td></tr>
<tr class="separator:a0f8611489111164e4e3712f18069b2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f9a2f546932b5a2d39a66f6986baf7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a88f9a2f546932b5a2d39a66f6986baf7">random_split</a> (double fraction) const </td></tr>
<tr class="separator:a88f9a2f546932b5a2d39a66f6986baf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92825d8fcd0c9d8d0df0e8a57d7f5150"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a92825d8fcd0c9d8d0df0e8a57d7f5150">random_split</a> (double fraction, size_t seed, bool exact=false) const </td></tr>
<tr class="separator:a92825d8fcd0c9d8d0df0e8a57d7f5150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70f5158431f9d55ab56494272c21199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#af70f5158431f9d55ab56494272c21199">topk</a> (const std::string &amp;<a class="el" href="classturi_1_1gl__sframe.html#af0e05e25b80ab22ffa2e90c92b6c0d59">column_name</a>, size_t k=10, bool reverse=false) const </td></tr>
<tr class="separator:af70f5158431f9d55ab56494272c21199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85cf94fde77f948ee68f2ec0572d0b0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ab85cf94fde77f948ee68f2ec0572d0b0">column_index</a> (const std::string &amp;<a class="el" href="classturi_1_1gl__sframe.html#af0e05e25b80ab22ffa2e90c92b6c0d59">column_name</a>) const </td></tr>
<tr class="separator:ab85cf94fde77f948ee68f2ec0572d0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e05e25b80ab22ffa2e90c92b6c0d59"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#af0e05e25b80ab22ffa2e90c92b6c0d59">column_name</a> (size_t index) const </td></tr>
<tr class="separator:af0e05e25b80ab22ffa2e90c92b6c0d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db73f6ccb38e1cc3de7086ed1d067ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a2db73f6ccb38e1cc3de7086ed1d067ec">select_column</a> (const std::string &amp;colname) const </td></tr>
<tr class="separator:a2db73f6ccb38e1cc3de7086ed1d067ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14a0eec9d6e00e0215c0be86bc253c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#af14a0eec9d6e00e0215c0be86bc253c4">select_columns</a> (const std::vector&lt; std::string &gt; &amp;colnames) const </td></tr>
<tr class="separator:af14a0eec9d6e00e0215c0be86bc253c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba874d1a42ffcf07c73a759b1be2f600"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#aba874d1a42ffcf07c73a759b1be2f600">replace_add_column</a> (const <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &amp;data, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="separator:aba874d1a42ffcf07c73a759b1be2f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e10776c78d91b8a8ace9c2a32cb8b60"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a6e10776c78d91b8a8ace9c2a32cb8b60">add_column</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;data, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="separator:a6e10776c78d91b8a8ace9c2a32cb8b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3751ba842c96411b5dd845f1294a5bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ae3751ba842c96411b5dd845f1294a5bd">add_column</a> (const <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &amp;data, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="separator:ae3751ba842c96411b5dd845f1294a5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3532de58f8d8ab3c55186a2dd52c4b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#abf3532de58f8d8ab3c55186a2dd52c4b">add_columns</a> (const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;data)</td></tr>
<tr class="separator:abf3532de58f8d8ab3c55186a2dd52c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4703483f47a91e780d50f27eda68dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a1d4703483f47a91e780d50f27eda68dd">remove_column</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a1d4703483f47a91e780d50f27eda68dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e0b9ab9d94a78cb554056350e4b22f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a37e0b9ab9d94a78cb554056350e4b22f">swap_columns</a> (const std::string &amp;column_1, const std::string &amp;column_2)</td></tr>
<tr class="separator:a37e0b9ab9d94a78cb554056350e4b22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209c96048dd921d8cfe58cc5d269bef9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a209c96048dd921d8cfe58cc5d269bef9">rename</a> (const std::map&lt; std::string, std::string &gt; &amp;old_to_new_names)</td></tr>
<tr class="separator:a209c96048dd921d8cfe58cc5d269bef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc741a5e0ba6cf03c17262fc0205963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a2fc741a5e0ba6cf03c17262fc0205963">append</a> (const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;other) const </td></tr>
<tr class="separator:a2fc741a5e0ba6cf03c17262fc0205963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9762ca4858f7422616f48e05e4247ef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a9762ca4858f7422616f48e05e4247ef4">groupby</a> (const std::vector&lt; std::string &gt; &amp;groupkeys, const std::map&lt; std::string, <a class="el" href="structturi_1_1aggregate_1_1groupby__descriptor__type.html">aggregate::groupby_descriptor_type</a> &gt; &amp;operators=std::map&lt; std::string, <a class="el" href="structturi_1_1aggregate_1_1groupby__descriptor__type.html">aggregate::groupby_descriptor_type</a> &gt;()) const </td></tr>
<tr class="separator:a9762ca4858f7422616f48e05e4247ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a4f0e0c1ba3c70b2bc0505628e4729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ac4a4f0e0c1ba3c70b2bc0505628e4729">join</a> (const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;right, const std::vector&lt; std::string &gt; &amp;joinkeys, const std::string &amp;how=&quot;inner&quot;) const </td></tr>
<tr class="separator:ac4a4f0e0c1ba3c70b2bc0505628e4729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ac4fb73c8b27c06338a02c1c0b1100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#aa6ac4fb73c8b27c06338a02c1c0b1100">join</a> (const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;right, const std::map&lt; std::string, std::string &gt; &amp;joinkeys, const std::string &amp;how=&quot;inner&quot;) const </td></tr>
<tr class="separator:aa6ac4fb73c8b27c06338a02c1c0b1100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2680c487cf3c81bd3853372c02e2e742"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a2680c487cf3c81bd3853372c02e2e742">filter_by</a> (const <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &amp;<a class="el" href="group__set__and__map.html#gaa4a5ba603bdef39e4c11f7d8692741c7">values</a>, const std::string &amp;<a class="el" href="classturi_1_1gl__sframe.html#af0e05e25b80ab22ffa2e90c92b6c0d59">column_name</a>, bool exclude=false) const </td></tr>
<tr class="separator:a2680c487cf3c81bd3853372c02e2e742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad180a15f62085157698d0ac12b8dff58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ad180a15f62085157698d0ac12b8dff58">pack_columns</a> (const std::vector&lt; std::string &gt; &amp;columns, const std::string &amp;new_column_name, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> dtype=<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a298cb25408234de02baf2085803a464a">flex_type_enum::LIST</a>, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> fill_na=<a class="el" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>) const </td></tr>
<tr class="separator:ad180a15f62085157698d0ac12b8dff58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1523cf90a84cf5e98ae1c3bd437ce668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a1523cf90a84cf5e98ae1c3bd437ce668">pack_columns</a> (const std::string &amp;column_prefix, const std::string &amp;new_column_name, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> dtype=<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a298cb25408234de02baf2085803a464a">flex_type_enum::LIST</a>, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> fill_na=<a class="el" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>) const </td></tr>
<tr class="separator:a1523cf90a84cf5e98ae1c3bd437ce668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3837285fdecdcbd8c5f3d4b897760426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a3837285fdecdcbd8c5f3d4b897760426">split_datetime</a> (const std::string &amp;expand_column, const std::string &amp;column_name_prefix=&quot;X&quot;, const std::vector&lt; std::string &gt; &amp;limit=std::vector&lt; std::string &gt;(), bool tzone=false) const </td></tr>
<tr class="separator:a3837285fdecdcbd8c5f3d4b897760426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317924b4743f3ff5a9710deee8052cfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a317924b4743f3ff5a9710deee8052cfc">unpack</a> (const std::string &amp;unpack_column, const std::string &amp;column_name_prefix=&quot;X&quot;, const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;<a class="el" href="classturi_1_1gl__sframe.html#a04011513cb649b8b0fdc4105eeb2281d">column_types</a>=std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt;(), const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;na_value=<a class="el" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;limit=std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;()) const </td></tr>
<tr class="separator:a317924b4743f3ff5a9710deee8052cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e67a97288ecbac0b1a0dfa4ae71764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a80e67a97288ecbac0b1a0dfa4ae71764">stack</a> (const std::string &amp;<a class="el" href="classturi_1_1gl__sframe.html#af0e05e25b80ab22ffa2e90c92b6c0d59">column_name</a>, const std::string &amp;new_column_names, bool drop_na=false) const </td></tr>
<tr class="separator:a80e67a97288ecbac0b1a0dfa4ae71764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532c17f03b896064dc7d2c2afc472e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a532c17f03b896064dc7d2c2afc472e5f">stack</a> (const std::string &amp;<a class="el" href="classturi_1_1gl__sframe.html#af0e05e25b80ab22ffa2e90c92b6c0d59">column_name</a>, const std::vector&lt; std::string &gt; &amp;new_column_names, bool drop_na=false) const </td></tr>
<tr class="separator:a532c17f03b896064dc7d2c2afc472e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c871590042d94c5486278296814e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ac0c871590042d94c5486278296814e4d">unstack</a> (const std::string &amp;columns, const std::string &amp;new_column_name=&quot;&quot;) const </td></tr>
<tr class="separator:ac0c871590042d94c5486278296814e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ed60b99a17669a732012a4607fd3fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a03ed60b99a17669a732012a4607fd3fd">unstack</a> (const std::vector&lt; std::string &gt; &amp;columns, const std::string &amp;new_column_name=&quot;&quot;) const </td></tr>
<tr class="separator:a03ed60b99a17669a732012a4607fd3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4330bbe2e6276fcf0c94dca0405ddc48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a4330bbe2e6276fcf0c94dca0405ddc48">unique</a> () const </td></tr>
<tr class="separator:a4330bbe2e6276fcf0c94dca0405ddc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e77d1b853f16abcb7b17159640ed57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ac3e77d1b853f16abcb7b17159640ed57">sort</a> (const std::string &amp;column, bool ascending=true) const </td></tr>
<tr class="separator:ac3e77d1b853f16abcb7b17159640ed57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7b9d0c17924489767cb47875e6721f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a4f7b9d0c17924489767cb47875e6721f">sort</a> (const std::vector&lt; std::string &gt; &amp;columns, bool ascending=true) const </td></tr>
<tr class="separator:a4f7b9d0c17924489767cb47875e6721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93367d33f564e183ae29420d9468737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ad93367d33f564e183ae29420d9468737">sort</a> (const std::initializer_list&lt; std::string &gt; &amp;columns, bool ascending=true) const </td></tr>
<tr class="separator:ad93367d33f564e183ae29420d9468737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c95fee095834645fb33eb879d40b48e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a6c95fee095834645fb33eb879d40b48e">sort</a> (const std::vector&lt; std::pair&lt; std::string, bool &gt;&gt; &amp;column_and_ascending) const </td></tr>
<tr class="separator:a6c95fee095834645fb33eb879d40b48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdbb4d1bc385420cd1280e274b73b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a8bdbb4d1bc385420cd1280e274b73b2b">dropna</a> (const std::vector&lt; std::string &gt; &amp;columns=std::vector&lt; std::string &gt;(), std::string how=&quot;any&quot;, bool recursive=false) const </td></tr>
<tr class="separator:a8bdbb4d1bc385420cd1280e274b73b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf67eebe0e720b75f4d77d21006700b0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#acf67eebe0e720b75f4d77d21006700b0">dropna_split</a> (const std::vector&lt; std::string &gt; &amp;columns=std::vector&lt; std::string &gt;(), std::string how=&quot;any&quot;, bool recursive=false) const </td></tr>
<tr class="separator:acf67eebe0e720b75f4d77d21006700b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28184f0c79aeeb42789455f23273282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#ad28184f0c79aeeb42789455f23273282">fillna</a> (const std::string &amp;column, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> value) const </td></tr>
<tr class="separator:ad28184f0c79aeeb42789455f23273282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8a9c6d44e842623fc68be80004493f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#add8a9c6d44e842623fc68be80004493f">add_row_number</a> (const std::string &amp;<a class="el" href="classturi_1_1gl__sframe.html#af0e05e25b80ab22ffa2e90c92b6c0d59">column_name</a>=&quot;id&quot;, size_t start=0) const </td></tr>
<tr class="separator:add8a9c6d44e842623fc68be80004493f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acb3d50c5d978bf53af08bbb041d1a0f8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#acb3d50c5d978bf53af08bbb041d1a0f8">operator[]</a> (int64_t i)</td></tr>
<tr class="separator:acb3d50c5d978bf53af08bbb041d1a0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a1f19c116316327bc11b6e621ac4a7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a67a1f19c116316327bc11b6e621ac4a7">operator[]</a> (int64_t i) const </td></tr>
<tr class="separator:a67a1f19c116316327bc11b6e621ac4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a31154a8ea5ebf5b7d50e223b46aa887f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#a31154a8ea5ebf5b7d50e223b46aa887f">operator[]</a> (const std::initializer_list&lt; int64_t &gt; &amp;slice)</td></tr>
<tr class="separator:a31154a8ea5ebf5b7d50e223b46aa887f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdeae8b0f02bf076ea79d404a765ae9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#acdeae8b0f02bf076ea79d404a765ae9c">operator[]</a> (const std::initializer_list&lt; int64_t &gt; &amp;slice) const </td></tr>
<tr class="separator:acdeae8b0f02bf076ea79d404a765ae9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Column Indexing</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Selects a single column of the SFrame.</p>
<p><a class="anchor" id="column_indexing"></a> This returns an internal array reference object that can be used exactly like a <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a>. The design is quite similar to the reference object used by std::vector&lt;bool&gt; for indexing.</p>
<p>For instance:</p>
<div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}},</div><div class="line">             {<span class="stringliteral">&quot;c&quot;</span>, {1.0,2.0,3.0,4.0,5.0}}};</div><div class="line">gl_sarray t = sf[<span class="stringliteral">&quot;a&quot;</span>]; <span class="comment">// takes out column &quot;a&quot;</span></div></div><!-- fragment --><p>However, this operator can also be used for modifying existing columns, or creating new columns. For instance:</p>
<div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}},</div><div class="line">             {<span class="stringliteral">&quot;c&quot;</span>, {1.0,2.0,3.0,4.0,5.0}}};</div><div class="line">sf[<span class="stringliteral">&quot;a&quot;</span>] = sf[<span class="stringliteral">&quot;a&quot;</span>] + 1; <span class="comment">// sf[&quot;a&quot;] is now {2,3,4,5,6}</span></div><div class="line">sf[<span class="stringliteral">&quot;d&quot;</span>] = sf[<span class="stringliteral">&quot;c&quot;</span>] - 1; <span class="comment">// sf[&quot;d&quot;] is now {0.0,1.0,2.0,3.0,4.0}</span></div></div><!-- fragment --><p>Entire constant columns can also be created the same way: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}},</div><div class="line">             {<span class="stringliteral">&quot;c&quot;</span>, {1.0,2.0,3.0,4.0,5.0}}};</div><div class="line">sf[<span class="stringliteral">&quot;ones&quot;</span>] = 1;</div></div><!-- fragment --><p>Since the returned object is meant to be a short-lived reference, the following is not permitted: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}},</div><div class="line">             {<span class="stringliteral">&quot;c&quot;</span>, {1.0,2.0,3.0,4.0,5.0}}};</div><div class="line"><span class="keyword">auto</span> a_col = sf[<span class="stringliteral">&quot;a&quot;</span>];</div></div><!-- fragment --><p> since "auto" resolves to <a class="el" href="classturi_1_1gl__sarray__reference.html">gl_sarray_reference</a> which is intentionally, not copy-constructible.</p>
<p>For functional alternatives, See <a class="el" href="classturi_1_1gl__sframe.html#aba874d1a42ffcf07c73a759b1be2f600">replace_add_column</a>, <a class="el" href="classturi_1_1gl__sframe.html#a6e10776c78d91b8a8ace9c2a32cb8b60">add_column</a>, <a class="el" href="classturi_1_1gl__sframe.html#ae3751ba842c96411b5dd845f1294a5bd">add_column(const gl_sarray&amp;, const std::string&amp;)</a>, "add_column overload". </p>
</div></td></tr>
<tr class="memitem:a8d73adf54aa7e8289e7c45ac26618f5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d73adf54aa7e8289e7c45ac26618f5a"></a>
<a class="el" href="classturi_1_1const__gl__sarray__reference.html">const_gl_sarray_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const std::string &amp;column) const </td></tr>
<tr class="separator:a8d73adf54aa7e8289e7c45ac26618f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc44091dbed8b35260f8ecf88c12237"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fc44091dbed8b35260f8ecf88c12237"></a>
<a class="el" href="classturi_1_1gl__sarray__reference.html">gl_sarray_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const std::string &amp;column)</td></tr>
<tr class="separator:a1fc44091dbed8b35260f8ecf88c12237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multi-Column Indexing</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="multi_column_indexing"></a>Subselects a subset of columns returning the an SFrame containing only those columns.</p>
<div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}},</div><div class="line">             {<span class="stringliteral">&quot;c&quot;</span>, {1.0,2.0,3.0,4.0,5.0}}};</div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> ret = sf[{<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>}]</div><div class="line"><span class="comment">// ret has 2 columns &quot;a&quot; and &quot;b&quot;</span></div></div><!-- fragment --> </div></td></tr>
<tr class="memitem:a17d94d5e739479eb57bb7d1aff300b13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17d94d5e739479eb57bb7d1aff300b13"></a>
<a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const std::vector&lt; std::string &gt; &amp;columns) const </td></tr>
<tr class="separator:a17d94d5e739479eb57bb7d1aff300b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e2a9c5918875c19b255ee9820a8ff0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4e2a9c5918875c19b255ee9820a8ff0"></a>
<a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const std::initializer_list&lt; std::string &gt; &amp;columns)</td></tr>
<tr class="separator:ae4e2a9c5918875c19b255ee9820a8ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab616d58bbf744314c9124f1239088b25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab616d58bbf744314c9124f1239088b25"></a>
<a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const std::initializer_list&lt; std::string &gt; &amp;columns) const </td></tr>
<tr class="separator:ab616d58bbf744314c9124f1239088b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afe7a7f882ece2d394a9465430b9bd7d7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html#afe7a7f882ece2d394a9465430b9bd7d7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;other)</td></tr>
<tr class="separator:afe7a7f882ece2d394a9465430b9bd7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A tabular, column-mutable dataframe object that can scale to big data.</p>
<p>The data in <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> is stored column-wise on persistent storage (e.g. disk) to avoid being constrained by memory size. Each column in an <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> is a immutable <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a>, but <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> objects are mutable in that columns can be added and subtracted with ease. An <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> essentially acts as an ordered dictionary of <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> objects. Usage:</p>
<h3>Usage</h3>
<p>The <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> API is designed to very closely mimic the Python SFrame API and supports much of the Python-like capabilities, but in C++.</p>
<p>Column Creation And Referencing </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf;</div><div class="line">sf[<span class="stringliteral">&quot;a&quot;</span>] = gl_sarray{1,2,3,4,5};</div><div class="line">gl_sarray a_5_element_sarray{1,1,1,1,1};</div><div class="line">sf[<span class="stringliteral">&quot;b&quot;</span>] = a_5_element_sarray;</div><div class="line">gl_sarray some_other_sarray{2,2,2,2,2};</div><div class="line">sf[<span class="stringliteral">&quot;c&quot;</span>] = sf[<span class="stringliteral">&quot;a&quot;</span>] / sf[<span class="stringliteral">&quot;b&quot;</span>] + some_other_sarray;</div></div><!-- fragment --><p>Logical Filter: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}}};</div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> t = sf[sf[<span class="stringliteral">&quot;a&quot;</span>] &lt; 3]</div><div class="line"><span class="comment">// t now has 2 columns. a: [1,2] b:[&quot;1&quot;,&quot;2&quot;]</span></div></div><!-- fragment --><p>Python Range Slicing: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}}};</div><div class="line">t = sf[{0,3}];</div><div class="line"><span class="comment">// t is the first 3 rows of sf</span></div></div><!-- fragment --><p>And many others.</p>
<p>The <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> can be read <b>inefficiently</b> using operator[] </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}}};</div><div class="line">std::vector&lt;flexible_type&gt; val = s[2];</div><div class="line"><span class="comment">// val[0] == 3, val[1] == &quot;3&quot;</span></div></div><!-- fragment --><p>Or iterated efficiently using the <a class="el" href="classturi_1_1gl__sframe.html#a628d77e61284ac2ab876fee7881136ad">range_iterator</a> </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; i: sa.range_iterator()) {</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>Note that using "auto" above is more efficient than using vector&lt;flexible_type&gt; </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> std::vector&lt;flexible_type&gt; &amp; i: sa.range_iterator()) {</div></div><!-- fragment --><p>The range_iterator materializes the SFrame if not already materialized, but <a class="el" href="classturi_1_1gl__sframe.html#a9efaca3b4931004192bac3e7b10aaec9">materialize_to_callback</a> can be used to read the SFrame without materialization.</p>
<p>The <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> can constructed in a variety of means:</p><ul>
<li>If the data to be written is already in memory, it can be created using the <a class="el" href="classturi_1_1gl__sframe.html#aefd178007b6231606d86d2f16f988e4d">gl_sframe constructor</a></li>
<li>Otherwise, the <a class="el" href="classturi_1_1gl__sframe__writer.html">gl_sframe_writer</a> can be used which provides a simple write interface.</li>
</ul>
<h3>Python Binding</h3>
<p>When used as an input argument in an SDK function, it permits a Python SFrame to be passed as an argument. When used in an output argument, it will return a Python SFrame.</p>
<p>For instance: </p><div class="fragment"><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Compiled as example.so</span></div><div class="line"><span class="comment">//</span></div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> add_ones_column(<span class="keyword">const</span> <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>&amp; data) {</div><div class="line">  <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf = data;</div><div class="line">  sf[<span class="stringliteral">&quot;ones&quot;</span>] = 1;</div><div class="line">  <span class="keywordflow">return</span> sf;</div><div class="line">}</div><div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga2d8058d55689f2f68a1bfd3c6266cebf">BEGIN_FUNCTION_REGISTRATION</a></div><div class="line"><a class="code" href="group__group__gl__function__ffi.html#gafd6f96997a5f904c3d9aa9204417aaf0">REGISTER_FUNCTION</a>(add_ones_column, <span class="stringliteral">&quot;data&quot;</span>);</div><div class="line"><a class="code" href="group__group__gl__function__ffi.html#ga24327cae92937381554e92becdbcff32">END_FUNCTION_REGISTRATION</a></div></div><!-- fragment --><p>Will allow this to be done in Python: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">import</span> turicreate <span class="keyword">as</span> gl</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="keyword">import</span> example</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;sa = SFrame({<span class="stringliteral">&quot;a&quot;</span>:[1,2,3,4,5]})</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;ret = example.add_ones_column(sa)</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"># ret now has two columns. &quot;a&quot;:[1,2,3,4,5] and &quot;ones&quot;:[1,1,1,1,1]</span></div></div><!-- fragment --><h3>Details</h3>
<p>The <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> is also lazy evaluated behind the scenes to minimize disk access. This may have the unfortunate effect of hiding errors until materialization is forced to occur. i.e. it might be some time much later in your code that errors will trigger.</p>
<p>However, not all operations are lazy and certain operations will force materialization, and that is a constant target for optimization.</p>
<p>If you want to force materialization yourself, use <a class="el" href="classturi_1_1gl__sframe.html#adf487ad5b75b7cff5e0aef3cf54857fb">materialize()</a> </p>

<p>Definition at line <a class="el" href="gl__sframe_8hpp_source.html#l00492">492</a> of file <a class="el" href="gl__sframe_8hpp_source.html">gl_sframe.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a135cdb74a59901e51564ddcfc7880f83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">turi::gl_sframe::gl_sframe </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> from a binary SFrame saved previously with <a class="el" href="classturi_1_1gl__sframe.html#a7c9148b0602a4c59730c6c0e6b77ddbd">save()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a7c9148b0602a4c59730c6c0e6b77ddbd">save()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aefd178007b6231606d86d2f16f988e4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">turi::gl_sframe::gl_sframe </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> from an in-memory map of values </p><div class="fragment"><div class="line">std::vector&lt;flexible_type&gt; a{1,2,3,4,5};</div><div class="line">std::vector&lt;flexible_type&gt; a_str{<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>};</div><div class="line">std::map&lt;std::string, std::vector&lt;flexible_type&gt;&gt; cols;</div><div class="line">cols[<span class="stringliteral">&quot;a&quot;</span>] = a;</div><div class="line">cols[<span class="stringliteral">&quot;a_str&quot;</span>] = a_str;</div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf(cols);</div></div><!-- fragment --><p>Or, more compactly using C++11 initializer lists: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf({{<span class="stringliteral">&quot;a&quot;</span>, a},{<span class="stringliteral">&quot;a_str&quot;</span>, a_str}});</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af9dee5eef29adf9bfe588885fcc5b185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">turi::gl_sframe::gl_sframe </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> from a collection of gl_sarrays.</p>
<div class="fragment"><div class="line">gl_sarray a{1,2,3,4,5};</div><div class="line">gl_sarray a_str{<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}</div><div class="line">std::map&lt;std::string, gl_sarray&gt; cols;</div><div class="line">cols[<span class="stringliteral">&quot;a&quot;</span>] = a;</div><div class="line">cols[<span class="stringliteral">&quot;a_str&quot;</span>] = a_str;</div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf(cols);</div></div><!-- fragment --><p>Or, more compactly using C++11 initializer lists: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf({{<span class="stringliteral">&quot;a&quot;</span>, a},{<span class="stringliteral">&quot;a_str&quot;</span>, a_str}});</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8162175a620ffa87ff0a9c25c92e033b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">turi::gl_sframe::gl_sframe </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::pair&lt; std::string, <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &gt;&gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> from an initializer list of columns.</p>
<div class="fragment"><div class="line">gl_sarray a{1,2,3,4,5};</div><div class="line">gl_sarray a_str{<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}</div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, a},{<span class="stringliteral">&quot;a_str&quot;</span>, a_str}};</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6e10776c78d91b8a8ace9c2a32cb8b60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void turi::gl_sframe::add_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a column of identical values this <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, raising an exception if a column the same name already exists. This operation modifies the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> in place. If no name is given, a default name is chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The value to assign to each entry in the new column</td></tr>
    <tr><td class="paramname">name</td><td>Optional. The name of the column. If no name is given, a default name is chosen.</td></tr>
  </table>
  </dd>
</dl>
<p>This is almost equivalent to using <a class="el" href="classturi_1_1gl__sframe.html#column_indexing">operator[]</a> for column assignment, but raises an exception if overwriting a column with the same name. </p><div class="fragment"><div class="line">sf[name] = data;</div></div><!-- fragment --><p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 2, 3}},</div><div class="line">                     {<span class="stringliteral">&quot;val&quot;</span>, {<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>}}});</div><div class="line"><span class="keyword">auto</span> sa = gl_sarray({<span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;fossa&quot;</span>});</div><div class="line">sf.replace_add_column(<span class="stringliteral">&quot;fish&quot;</span>, <span class="stringliteral">&quot;species&quot;</span>);</div><div class="line">std::cout &lt;&lt;  sf;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+----+-----+---------+</div><div class="line">| <span class="keywordtype">id</span> | val | species |</div><div class="line">+----+-----+---------+</div><div class="line">| 1  |  A  |  fish   |</div><div class="line">| 2  |  B  |  fish   |</div><div class="line">| 3  |  C  |  fish   |</div><div class="line">+----+-----+---------+</div><div class="line">[3 rows x 3 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#aba874d1a42ffcf07c73a759b1be2f600">replace_add_column</a> </dd>
<dd>
<a class="el" href="classturi_1_1gl__sframe.html#ae3751ba842c96411b5dd845f1294a5bd">add_column(const gl_sarray&amp;, const std::string&amp;)</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classturi_1_1gl__gframe.html#acfeffb9fa392580db53e70e9e4f46235">turi::gl_gframe</a>.</p>

</div>
</div>
<a class="anchor" id="ae3751ba842c96411b5dd845f1294a5bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void turi::gl_sframe::add_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a column to this <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, raising an exception if a column the same name already exists. The number of elements in the data given must match the length of every other column of the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. This operation modifies the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> in place. If no name is given, a default name is chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The column of data to add.</td></tr>
    <tr><td class="paramname">name</td><td>Optional. The name of the column. If no name is given, a default name is chosen.</td></tr>
  </table>
  </dd>
</dl>
<p>This is almost equivalent to using <a class="el" href="classturi_1_1gl__sframe.html#column_indexing">operator[]</a> for column assignment, but raises an exception if overwriting a column with the same name. </p><div class="fragment"><div class="line">sf[name] = data;</div></div><!-- fragment --><p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 2, 3}},</div><div class="line">                     {<span class="stringliteral">&quot;val&quot;</span>, {<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>}}});</div><div class="line"><span class="keyword">auto</span> sa = gl_sarray({<span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;fossa&quot;</span>});</div><div class="line">sf.replace_add_column(sa, <span class="stringliteral">&quot;species&quot;</span>);</div><div class="line">std::cout &lt;&lt;  sf;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+----+-----+---------+</div><div class="line">| <span class="keywordtype">id</span> | val | species |</div><div class="line">+----+-----+---------+</div><div class="line">| 1  |  A  |   cat   |</div><div class="line">| 2  |  B  |   dog   |</div><div class="line">| 3  |  C  |  fossa  |</div><div class="line">+----+-----+---------+</div><div class="line">[3 rows x 3 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#aba874d1a42ffcf07c73a759b1be2f600">replace_add_column</a> </dd>
<dd>
<a class="el" href="classturi_1_1gl__sframe.html#a6e10776c78d91b8a8ace9c2a32cb8b60">add_column(const flexible_type&amp;, const std::string&amp;)</a>, </dd></dl>

<p>Reimplemented in <a class="el" href="classturi_1_1gl__gframe.html#a83663b15e6285174968c259280ef4eaf">turi::gl_gframe</a>.</p>

</div>
</div>
<a class="anchor" id="abf3532de58f8d8ab3c55186a2dd52c4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void turi::gl_sframe::add_columns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds multiple columns to this <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. The number of elements in all columns must match the length of every other column of the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. This operation modifies the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> in place</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The columns to add.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 2, 3}},</div><div class="line">                     {<span class="stringliteral">&quot;val&quot;</span>, {<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>}}});</div><div class="line"><span class="keyword">auto</span> sf2 = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;species&quot;</span>, {<span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;fossa&quot;</span>}},</div><div class="line">                      {<span class="stringliteral">&quot;age&quot;</span>, {3, 5, 9}}});</div><div class="line">std::cout &lt;&lt;  sf.add_columns(sf2);</div><div class="line">std::cout &lt;&lt;  sf;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+----+-----+-----+---------+</div><div class="line">| <span class="keywordtype">id</span> | val | age | species |</div><div class="line">+----+-----+-----+---------+</div><div class="line">| 1  |  A  |  3  |   cat   |</div><div class="line">| 2  |  B  |  5  |   dog   |</div><div class="line">| 3  |  C  |  9  |  fossa  |</div><div class="line">+----+-----+-----+---------+</div><div class="line">[3 rows x 4 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a6e10776c78d91b8a8ace9c2a32cb8b60">add_column</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classturi_1_1gl__gframe.html#ace609374924fef71163ee21de0f6f8aa">turi::gl_gframe</a>.</p>

</div>
</div>
<a class="anchor" id="add8a9c6d44e842623fc68be80004493f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::add_row_number </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em> = <code>&quot;id&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> with a new column that numbers each row sequentially. By default the count starts at 0, but this can be changed to a positive or negative number. The new column will be named with the given column name. An error will be raised if the given column name already exists in the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_name</td><td>Optional. The name of the new column that will hold the row numbers.</td></tr>
    <tr><td class="paramname">start</td><td>Optional. The number used to start the row number count.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>{{<span class="stringliteral">&quot;a&quot;</span>: {1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>}},</div><div class="line">               {<span class="stringliteral">&quot;b&quot;</span>: {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, FLEX_UNDEFINED}} };</div><div class="line">std::cout &lt;&lt; sf.add_row_number() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+----+------+------+</div><div class="line">| <span class="keywordtype">id</span> |  a   |  b   |</div><div class="line">+----+------+------+</div><div class="line">| 0  |  1   |  a   |</div><div class="line">| 1  | None |  b   |</div><div class="line">| 2  | None | None |</div><div class="line">+----+------+------+</div><div class="line">[3 rows x 3 columns]</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2fc741a5e0ba6cf03c17262fc0205963"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the rows of an <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> to the end of this <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. Both <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> objects must have the same set of columns with the same column names and column types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> whose rows are appended to the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {4, 6, 8}},</div><div class="line">                     {<span class="stringliteral">&quot;val&quot;</span>, {<span class="stringliteral">&quot;D&quot;</span>, <span class="stringliteral">&quot;F&quot;</span>, <span class="stringliteral">&quot;H&quot;</span>}}});</div><div class="line"><span class="keyword">auto</span> sf2 = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 2, 3}},</div><div class="line">                      {<span class="stringliteral">&quot;val&quot;</span>, {<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>}}});</div><div class="line"><span class="keyword">auto</span> sf = sf.append(sf2);</div><div class="line">std::cout &lt;&lt;  sf;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+----+-----+</div><div class="line">| <span class="keywordtype">id</span> | val |</div><div class="line">+----+-----+</div><div class="line">| 4  |  D  |</div><div class="line">| 6  |  F  |</div><div class="line">| 8  |  H  |</div><div class="line">| 1  |  A  |</div><div class="line">| 2  |  B  |</div><div class="line">| 3  |  C  |</div><div class="line">+----+-----+</div><div class="line">[6 rows x 2 columns]</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab11b87f882679d051106fbbf2fb73507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> turi::gl_sframe::apply </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>(const <a class="el" href="structturi_1_1sframe__rows_1_1row.html">sframe_rows::row</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps each row of the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> by a given function to a single value. The result <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> is of type "dtype". "fn" should be a function that returns exactly one value which can be cast into the type specified by "dtype".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The function to transform each element. Must return exactly one value which can be cast into the type specified by "dtype".</td></tr>
    <tr><td class="paramname">dtype</td><td>The data type of the new <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;c&quot;</span>, {1.0,2.0,3.0,4.0,5.0}}};</div><div class="line">std::cout &lt;&lt; sf.apply([](<span class="keyword">const</span> sframe_rows::row&amp; x) {</div><div class="line">                        <span class="keywordflow">return</span> x[0] * x[1];</div><div class="line">                      }, <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>);</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">dtype: <span class="keywordtype">float</span></div><div class="line">Rows: 5</div><div class="line">[1.0, 4.0, 9.0, 16.0, 25.0]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sarray.html#aec34627a47e344db79cc283cce325252">gl_sarray::apply</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab85cf94fde77f948ee68f2ec0572d0b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::gl_sframe::column_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of column <code>column_name</code>. </p>

</div>
</div>
<a class="anchor" id="af0e05e25b80ab22ffa2e90c92b6c0d59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; turi::gl_sframe::column_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of column <code>index</code>. </p>

</div>
</div>
<a class="anchor" id="a60ec072e385fe36c6c26905847d6d8a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; turi::gl_sframe::column_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the columns names of the SFrame. </p>

<p>Reimplemented in <a class="el" href="classturi_1_1gl__gframe.html#ab9f6dfac2cc54017753148685bb0dd9e">turi::gl_gframe</a>.</p>

</div>
</div>
<a class="anchor" id="a04011513cb649b8b0fdc4105eeb2281d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&gt; turi::gl_sframe::column_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an array of types of each column. </p>

<p>Reimplemented in <a class="el" href="classturi_1_1gl__gframe.html#a84878afbfc11e3278a03399c3f88d42e">turi::gl_gframe</a>.</p>

</div>
</div>
<a class="anchor" id="a0fa86422340f6320da5434e0cafca193"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::gl_sframe::construct_from_csvs </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>csv_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">csv_parsing_config_map&#160;</td>
          <td class="paramname"><em>csv_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str_flex_type_map&#160;</td>
          <td class="paramname"><em>column_type_hints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> from a csv file </p>

</div>
</div>
<a class="anchor" id="a25c74f5d14bb621ce71251c05dd37573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::gl_sframe::contains_column </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>col_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the column is present in the sframe, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a8bdbb4d1bc385420cd1280e274b73b2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::dropna </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>columns</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;any&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove missing values from an <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. A missing value is either "FLEX_UNDEFINED" or "NaN". If "how" is "any", a row will be removed if any of the columns in the "columns" parameter contains at least one missing value. If "how" is "all", a row will be removed if all of the columns in the "columns" parameter are missing values. If the "columns" parameter is not specified, the default is to consider all columns when searching for missing values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columns</td><td>Optional. The columns to use when looking for missing values. By default, all columns are used.</td></tr>
    <tr><td class="paramname">how</td><td>Optional. Specifies whether a row should be dropped if at least one column has missing values, or if all columns have missing values. "any" is default.</td></tr>
  </table>
  </dd>
</dl>
<p>For instance </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf { {<span class="stringliteral">&quot;a&quot;</span>, {1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>}},</div><div class="line">               {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, FLEX_UNDEFINED}} };</div><div class="line"></div><div class="line">std::cout &lt;&lt; sf.dropna() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output:</p>
<div class="fragment"><div class="line">+---+---+</div><div class="line">| a | b |</div><div class="line">+---+---+</div><div class="line">| 1 | a |</div><div class="line">+---+---+</div><div class="line">[1 rows x 2 columns]</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Drop when all values are missing.</span></div><div class="line">std::cout &lt;&lt; sf.dropna({}, all) &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+------+---+</div><div class="line">|  a   | b |</div><div class="line">+------+---+</div><div class="line">|  1   | a |</div><div class="line">| None | b |</div><div class="line">+------+---+</div><div class="line">[2 rows x 2 columns]</div></div><!-- fragment --><p> Example: </p><div class="fragment"><div class="line"><span class="comment">// Drop rows where column &quot;a&quot; has a missing value.</span></div><div class="line">std::cout &lt;&lt; sf.dropna({<span class="stringliteral">&quot;a&quot;</span>}) &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+---+---+</div><div class="line">| a | b |</div><div class="line">+---+---+</div><div class="line">| 1 | a |</div><div class="line">+---+---+</div><div class="line">[1 rows x 2 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#acf67eebe0e720b75f4d77d21006700b0">dropna_split</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acf67eebe0e720b75f4d77d21006700b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&gt; turi::gl_sframe::dropna_split </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>columns</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;any&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split rows with missing values from this <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. This function has the same functionality as dropna, but returns a tuple of two <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> objects. The first item is the expected output from dropna, and the second item contains all the rows filtered out by the "dropna" algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columns</td><td>Optional. The columns to use when looking for missing values. By default, all columns are used.</td></tr>
    <tr><td class="paramname">how</td><td>Optional. Specifies whether a row should be dropped if at least one column has missing values, or if all columns have missing values. "any" is default.</td></tr>
    <tr><td class="paramname">recursive</td><td>Optional. It will recursively check whether a cell contains nan or not. This is handy for nested data structure like list, dictionary. For instance, {{FLEX_UNDEFINED, 1}, {1} will be treat as nan and will be removed if recursive is set to be true. Otherwise it won't be treated as nan-value.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf { {<span class="stringliteral">&quot;a&quot;</span>: {1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>}},</div><div class="line">               {<span class="stringliteral">&quot;b&quot;</span>: {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, FLEX_UNDEFINED}} };</div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> good, bad;</div><div class="line">std::tie(good, bad) = sf.dropna_split();</div><div class="line">std::cout &lt;&lt; good &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+---+---+</div><div class="line">| a | b |</div><div class="line">+---+---+</div><div class="line">| 1 | a |</div><div class="line">+---+---+</div><div class="line">[1 rows x 2 columns]</div></div><!-- fragment --><p>Example: </p><div class="fragment"><div class="line">std::cout &lt;&lt; bad &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+------+------+</div><div class="line">|  a   |  b   |</div><div class="line">+------+------+</div><div class="line">| None |  b   |</div><div class="line">| None | None |</div><div class="line">+------+------+</div><div class="line">[2 rows x 2 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a8bdbb4d1bc385420cd1280e274b73b2b">dropna</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aedcbec920508d8cbab095a9e308331f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::gl_sframe::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if <a class="el" href="classturi_1_1gl__sframe.html#a996a165e932c322c003d3be275e32b6e">size()</a> == 0. </p>

</div>
</div>
<a class="anchor" id="ad28184f0c79aeeb42789455f23273282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::fillna </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill all missing values with a given value in a given column. If the "value" is not the same type as the values in "column", this method attempts to convert the value to the original column"s type. If this fails, an error is raised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>The name of the column to modify.</td></tr>
    <tr><td class="paramname">value</td><td>The value used to replace all missing values.</td></tr>
    <tr><td class="paramname">recursive</td><td>The recursive is used to set the manner of nan-value checking. If this value is true, a cell will be treated as missing value iff it contains nan. For instance, {{FLEX_UNDEFINED, 1}, {0}} and {FLEX_UNDEFINED, 1} will be all treated as nan-values.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf {{<span class="stringliteral">&quot;a&quot;</span>: {1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>},</div><div class="line">              {<span class="stringliteral">&quot;b&quot;</span>:[<span class="stringliteral">&quot;13.1&quot;</span>, <span class="stringliteral">&quot;17.2&quot;</span>, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>]}};</div><div class="line">sf = sf.fillna(<span class="stringliteral">&quot;a&quot;</span>, 0);</div><div class="line">std::cout &lt;&lt; sf &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+---+------+</div><div class="line">| a |  b   |</div><div class="line">+---+------+</div><div class="line">| 1 | 13.1 |</div><div class="line">| 0 | 17.2 |</div><div class="line">| 0 | None |</div><div class="line">+---+------+</div><div class="line">[3 rows x 2 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a8bdbb4d1bc385420cd1280e274b73b2b">dropna</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2680c487cf3c81bd3853372c02e2e742"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::filter_by </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclude</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filter an <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> by values inside an iterable object. Result is an <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> that only includes (or excludes) the rows that have a column with the given "column_name" which holds one of the values in the given "values" <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The values to use to filter the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. The resulting <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> will only include rows that have one of these values in the given column.</td></tr>
    <tr><td class="paramname">column_name</td><td>The column of the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> to match with the given "values".</td></tr>
    <tr><td class="paramname">exclude</td><td>Optional. Defaults to false. If true, the result <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> will contain all rows except those that have one of "values" in "column_name".</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 2, 3, 4}},</div><div class="line">                     {<span class="stringliteral">&quot;animal_type&quot;</span>, {<span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;cow&quot;</span>, <span class="stringliteral">&quot;horse&quot;</span>}},</div><div class="line">                     {<span class="stringliteral">&quot;name&quot;</span>, {<span class="stringliteral">&quot;bob&quot;</span>, <span class="stringliteral">&quot;jim&quot;</span>, <span class="stringliteral">&quot;jimbob&quot;</span>, <span class="stringliteral">&quot;bobjim&quot;</span>}}});</div><div class="line"><span class="keyword">auto</span> household_pets = {<span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;hamster&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;fish&quot;</span>, <span class="stringliteral">&quot;bird&quot;</span>, <span class="stringliteral">&quot;snake&quot;</span>};</div><div class="line">std::cout &lt;&lt; sf.filter_by(household_pets, <span class="stringliteral">&quot;animal_type&quot;</span>);</div><div class="line">std::cout &lt;&lt; sf.filter_by(household_pets, <span class="stringliteral">&quot;animal_type&quot;</span>, exclude=True);</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+-------------+----+------+</div><div class="line">| animal_type | <span class="keywordtype">id</span> | name |</div><div class="line">+-------------+----+------+</div><div class="line">|     dog     | 1  | bob  |</div><div class="line">|     cat     | 2  | jim  |</div><div class="line">+-------------+----+------+</div><div class="line">[2 rows x 3 columns]</div><div class="line">+-------------+----+--------+</div><div class="line">| animal_type | <span class="keywordtype">id</span> |  name  |</div><div class="line">+-------------+----+--------+</div><div class="line">|    horse    | 4  | bobjim |</div><div class="line">|     cow     | 3  | jimbob |</div><div class="line">+-------------+----+--------+</div><div class="line">[2 rows x 3 columns]</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9762ca4858f7422616f48e05e4247ef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::groupby </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>groupkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="structturi_1_1aggregate_1_1groupby__descriptor__type.html">aggregate::groupby_descriptor_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operators</em> = <code>std::map&lt;&#160;std::string,&#160;<a class="el" href="structturi_1_1aggregate_1_1groupby__descriptor__type.html">aggregate::groupby_descriptor_type</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a group on the key_columns followed by aggregations on the columns listed in operations. The operations parameter is a dictionary that indicates which aggregation operators to use and which columns to use them on. The available operators are SUM, MAX, MIN, COUNT, AVG, VAR, STDV, CONCAT, SELECT_ONE, ARGMIN, ARGMAX, and QUANTILE. For convenience, aggregators MEAN, STD, and VARIANCE are available as synonyms for AVG, STDV, and VAR. See <a class="el" href="namespaceturi_1_1aggregate.html" title="All the available groupby aggregators aggregators. See gl_sframe::groupby for details. ">turi::aggregate</a> for more detail on the aggregators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupkeys</td><td>Columns to group on. Type of key columns can be of any type other than dictionary.</td></tr>
    <tr><td class="paramname">operations</td><td>Map of columns and aggregation operations. Each key is a output column name and each value is an aggregator.</td></tr>
  </table>
  </dd>
</dl>
<p>Suppose we have an SFrame (sf) with movie ratings by many users. </p><div class="fragment"><div class="line">+---------+----------+--------+</div><div class="line">| user_id | movie_id | rating |</div><div class="line">+---------+----------+--------+</div><div class="line">|  25904  |   1663   |   3    |</div><div class="line">|  25907  |   1663   |   3    |</div><div class="line">|  25923  |   1663   |   3    |</div><div class="line">|  25924  |   1663   |   3    |</div><div class="line">|  25928  |   1663   |   2    |</div><div class="line">|  25933  |   1663   |   4    |</div><div class="line">|  25934  |   1663   |   4    |</div><div class="line">|  25935  |   1663   |   4    |</div><div class="line">|  25936  |   1663   |   5    |</div><div class="line">|  25937  |   1663   |   2    |</div><div class="line">|   ...   |   ...    |  ...   |</div><div class="line">+---------+----------+--------+</div><div class="line">[10000 rows x 3 columns]</div></div><!-- fragment --><p>Compute the number of occurrences of each user. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> user_count = sf.groupby({<span class="stringliteral">&quot;user_id&quot;</span>},</div><div class="line">                             {{<span class="stringliteral">&quot;count&quot;</span>, <a class="code" href="namespaceturi_1_1aggregate.html#ad3bd6d3ee660eb617d9c5557ab642453">aggregate::COUNT</a>()}});</div><div class="line">std::cout &lt;&lt; user_count;</div></div><!-- fragment --> <div class="fragment"><div class="line">+---------+-------+</div><div class="line">| user_id | count |</div><div class="line">+---------+-------+</div><div class="line">|  62361  |   1   |</div><div class="line">|  30727  |   1   |</div><div class="line">|  40111  |   1   |</div><div class="line">|  50513  |   1   |</div><div class="line">|  35140  |   1   |</div><div class="line">|  42352  |   1   |</div><div class="line">|  29667  |   1   |</div><div class="line">|  46242  |   1   |</div><div class="line">|  58310  |   1   |</div><div class="line">|  64614  |   1   |</div><div class="line">|   ...   |  ...  |</div><div class="line">+---------+-------+</div><div class="line">[9852 rows x 2 columns]</div></div><!-- fragment --><p>Compute the mean and standard deviation of ratings per user. </p><div class="fragment"><div class="line"><span class="keyword">auto</span>  user_rating_stats = sf.groupby({<span class="stringliteral">&quot;user_id&quot;</span>},</div><div class="line">                                     {{ <span class="stringliteral">&quot;mean_rating&quot;</span>, <a class="code" href="namespaceturi_1_1aggregate.html#afb5809da0928656357a27e0048e64bce">aggregate::MEAN</a>(<span class="stringliteral">&quot;rating&quot;</span>)},</div><div class="line">                                      {<span class="stringliteral">&quot;std_rating&quot;</span>, <a class="code" href="namespaceturi_1_1aggregate.html#a57a4ad0cd9f15cd2bf930a443cb21bd1">aggregate::STD</a>(<span class="stringliteral">&quot;rating&quot;</span>)}});</div><div class="line">std::cout &lt;&lt; user_rating_stats;</div></div><!-- fragment --> <div class="fragment"><div class="line">+---------+-------------+------------+</div><div class="line">| user_id | mean_rating | std_rating |</div><div class="line">+---------+-------------+------------+</div><div class="line">|  62361  |     5.0     |    0.0     |</div><div class="line">|  30727  |     4.0     |    0.0     |</div><div class="line">|  40111  |     2.0     |    0.0     |</div><div class="line">|  50513  |     4.0     |    0.0     |</div><div class="line">|  35140  |     4.0     |    0.0     |</div><div class="line">|  42352  |     5.0     |    0.0     |</div><div class="line">|  29667  |     4.0     |    0.0     |</div><div class="line">|  46242  |     5.0     |    0.0     |</div><div class="line">|  58310  |     2.0     |    0.0     |</div><div class="line">|  64614  |     2.0     |    0.0     |</div><div class="line">|   ...   |     ...     |    ...     |</div><div class="line">+---------+-------------+------------+</div><div class="line">[9852 rows x 3 columns]</div></div><!-- fragment --><p>Compute the movie with the minimum rating per user. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> chosen_movies = sf.groupby({<span class="stringliteral">&quot;user_id&quot;</span>},</div><div class="line">                                {{ <span class="stringliteral">&quot;worst_movies&quot;</span>, <a class="code" href="namespaceturi_1_1aggregate.html#af3495fd3418ec6c2d2890de2099e95c0">aggregate::ARGMIN</a>(<span class="stringliteral">&quot;rating&quot;</span>,<span class="stringliteral">&quot;movie_id&quot;</span>)}});</div><div class="line">std::cout &lt;&lt;  chosen_movies;</div></div><!-- fragment --> <div class="fragment"><div class="line">+---------+-------------+</div><div class="line">| user_id | worst_movies |</div><div class="line">+---------+-------------+</div><div class="line">|  62361  |     1663    |</div><div class="line">|  30727  |     1663    |</div><div class="line">|  40111  |     1663    |</div><div class="line">|  50513  |     1663    |</div><div class="line">|  35140  |     1663    |</div><div class="line">|  42352  |     1663    |</div><div class="line">|  29667  |     1663    |</div><div class="line">|  46242  |     1663    |</div><div class="line">|  58310  |     1663    |</div><div class="line">|  64614  |     1663    |</div><div class="line">|   ...   |     ...     |</div><div class="line">+---------+-------------+</div><div class="line">[9852 rows x 2 columns]</div></div><!-- fragment --><p>Compute the count, mean, and standard deviation of ratings per (user, time), automatically assigning output column names. </p><div class="fragment"><div class="line"><span class="comment">// make up some time column which is a combination of user id and movie id</span></div><div class="line">sf[<span class="stringliteral">&quot;time&quot;</span>] = sf.apply([](<span class="keyword">const</span> flexible_type&amp; x) {</div><div class="line">                         <span class="keywordflow">return</span> (x[0] + x[1]) % 11 + 2000;</div><div class="line">                       });</div><div class="line"><span class="keyword">auto</span> user_rating_stats = sf.groupby({<span class="stringliteral">&quot;user_id&quot;</span>, <span class="stringliteral">&quot;time&quot;</span>},</div><div class="line">                                    {{<span class="stringliteral">&quot;Count&quot;</span>, <a class="code" href="namespaceturi_1_1aggregate.html#ad3bd6d3ee660eb617d9c5557ab642453">aggregate::COUNT</a>()},</div><div class="line">                                     {<span class="stringliteral">&quot;Avg of rating&quot;</span>, <a class="code" href="namespaceturi_1_1aggregate.html#a9201475dd6d9c2e8a5c7431d579ff1e8">aggregate::AVG</a>(<span class="stringliteral">&quot;rating&quot;</span>)},</div><div class="line">                                     {<span class="stringliteral">&quot;Stdv of rating&quot;</span>, <a class="code" href="namespaceturi_1_1aggregate.html#a120824a01e823fea76d27f532fb9a48f">aggregate::STDV</a>(<span class="stringliteral">&quot;rating&quot;</span>)}});</div><div class="line">std::cout &lt;&lt;  user_rating_stats;</div></div><!-- fragment --> <div class="fragment"><div class="line">+------+---------+-------+---------------+----------------+</div><div class="line">| time | user_id | Count | Avg of rating | Stdv of rating |</div><div class="line">+------+---------+-------+---------------+----------------+</div><div class="line">| 2006 |  61285  |   1   |      4.0      |      0.0       |</div><div class="line">| 2000 |  36078  |   1   |      4.0      |      0.0       |</div><div class="line">| 2003 |  47158  |   1   |      3.0      |      0.0       |</div><div class="line">| 2007 |  34446  |   1   |      3.0      |      0.0       |</div><div class="line">| 2010 |  47990  |   1   |      3.0      |      0.0       |</div><div class="line">| 2003 |  42120  |   1   |      5.0      |      0.0       |</div><div class="line">| 2007 |  44940  |   1   |      4.0      |      0.0       |</div><div class="line">| 2008 |  58240  |   1   |      4.0      |      0.0       |</div><div class="line">| 2002 |   102   |   1   |      1.0      |      0.0       |</div><div class="line">| 2009 |  52708  |   1   |      3.0      |      0.0       |</div><div class="line">| ...  |   ...   |  ...  |      ...      |      ...       |</div><div class="line">+------+---------+-------+---------------+----------------+</div><div class="line">[10000 rows x 5 columns]</div></div><!-- fragment --><p>The groupby function can take a variable length list of aggregation specifiers so if we want the count and the 0.25 and 0.75 quantiles of ratings: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> user_rating_stats = sf.groupby({<span class="stringliteral">&quot;user_id&quot;</span>, <span class="stringliteral">&quot;time&quot;</span>},</div><div class="line">                                    {{<span class="stringliteral">&quot;Count&quot;</span>, <a class="code" href="namespaceturi_1_1aggregate.html#ad3bd6d3ee660eb617d9c5557ab642453">aggregate::COUNT</a>()},</div><div class="line">                                     {<span class="stringliteral">&quot;rating_quantiles&quot;</span>, agggregate.QUANTILE(<span class="stringliteral">&quot;rating&quot;</span>,{0.25, 0.75}) }});</div><div class="line">std::cout &lt;&lt;  user_rating_stats;</div></div><!-- fragment --> <div class="fragment"><div class="line">+------+---------+-------+------------------------+</div><div class="line">| time | user_id | Count |    rating_quantiles    |</div><div class="line">+------+---------+-------+------------------------+</div><div class="line">| 2006 |  61285  |   1   |      [4.0, 4.0]        |</div><div class="line">| 2000 |  36078  |   1   |      [4.0, 4.0]        |</div><div class="line">| 2003 |  47158  |   1   |      [3.0, 3.0]        |</div><div class="line">| 2007 |  34446  |   1   |      [3.0, 3.0]        |</div><div class="line">| 2010 |  47990  |   1   |      [3.0, 3.0]        |</div><div class="line">| 2003 |  42120  |   1   |      [5.0, 5.0]        |</div><div class="line">| 2007 |  44940  |   1   |      [4.0, 4.0]        |</div><div class="line">| 2008 |  58240  |   1   |      [4.0, 4.0]        |</div><div class="line">| 2002 |   102   |   1   |      [1.0, 1.0]        |</div><div class="line">| 2009 |  52708  |   1   |      [3.0, 3.0]        |</div><div class="line">| ...  |   ...   |  ...  |          ...           |</div><div class="line">+------+---------+-------+------------------------+</div><div class="line">[10000 rows x 4 columns]</div></div><!-- fragment --><p>To put all items a user rated into one list value by their star rating: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>  user_rating_stats = sf.groupby({<span class="stringliteral">&quot;user_id&quot;</span>, <span class="stringliteral">&quot;rating&quot;</span>},</div><div class="line">                                     {{<span class="stringliteral">&quot;rated_movie_ids&quot;</span>,<a class="code" href="namespaceturi_1_1aggregate.html#a6921ac08f15c6b2d9201d4be2139d318">aggregate::CONCAT</a>(<span class="stringliteral">&quot;movie_id&quot;</span>)}});</div><div class="line">std::cout &lt;&lt;  user_rating_stats;</div></div><!-- fragment --> <div class="fragment"><div class="line">+--------+---------+----------------------+</div><div class="line">| rating | user_id |     rated_movie_ids  |</div><div class="line">+--------+---------+----------------------+</div><div class="line">|   3    |  31434  | array(<span class="stringliteral">&quot;d&quot;</span>, [1663.0]) |</div><div class="line">|   5    |  25944  | array(<span class="stringliteral">&quot;d&quot;</span>, [1663.0]) |</div><div class="line">|   4    |  38827  | array(<span class="stringliteral">&quot;d&quot;</span>, [1663.0]) |</div><div class="line">|   4    |  51437  | array(<span class="stringliteral">&quot;d&quot;</span>, [1663.0]) |</div><div class="line">|   4    |  42549  | array(<span class="stringliteral">&quot;d&quot;</span>, [1663.0]) |</div><div class="line">|   4    |  49532  | array(<span class="stringliteral">&quot;d&quot;</span>, [1663.0]) |</div><div class="line">|   3    |  26124  | array(<span class="stringliteral">&quot;d&quot;</span>, [1663.0]) |</div><div class="line">|   4    |  46336  | array(<span class="stringliteral">&quot;d&quot;</span>, [1663.0]) |</div><div class="line">|   4    |  52133  | array(<span class="stringliteral">&quot;d&quot;</span>, [1663.0]) |</div><div class="line">|   5    |  62361  | array(<span class="stringliteral">&quot;d&quot;</span>, [1663.0]) |</div><div class="line">|  ...   |   ...   |         ...          |</div><div class="line">+--------+---------+----------------------+</div><div class="line">[9952 rows x 3 columns]</div></div><!-- fragment --><p>To put all items and rating of a given user together into a dictionary value: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>  user_rating_stats = sf.groupby({<span class="stringliteral">&quot;user_id&quot;</span>},</div><div class="line">                                     {{<span class="stringliteral">&quot;movie_rating&quot;</span>,agg.CONCAT(<span class="stringliteral">&quot;movie_id&quot;</span>, <span class="stringliteral">&quot;rating&quot;</span>)}});</div><div class="line">std::cout &lt;&lt;  user_rating_stats;</div></div><!-- fragment --> <div class="fragment"><div class="line">+---------+--------------+</div><div class="line">| user_id | movie_rating |</div><div class="line">+---------+--------------+</div><div class="line">|  62361  |  {1663: 5}   |</div><div class="line">|  30727  |  {1663: 4}   |</div><div class="line">|  40111  |  {1663: 2}   |</div><div class="line">|  50513  |  {1663: 4}   |</div><div class="line">|  35140  |  {1663: 4}   |</div><div class="line">|  42352  |  {1663: 5}   |</div><div class="line">|  29667  |  {1663: 4}   |</div><div class="line">|  46242  |  {1663: 5}   |</div><div class="line">|  58310  |  {1663: 2}   |</div><div class="line">|  64614  |  {1663: 2}   |</div><div class="line">|   ...   |     ...      |</div><div class="line">+---------+--------------+</div><div class="line">[9852 rows x 2 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceturi_1_1aggregate.html" title="All the available groupby aggregators aggregators. See gl_sframe::groupby for details. ">aggregate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8e5666b09b30317ec397b5266c2f4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::gl_sframe::has_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the size of the SFrame is known. If it is not known, calling <a class="el" href="classturi_1_1gl__sframe.html#a996a165e932c322c003d3be275e32b6e">size()</a> may trigger materialization. </p>

</div>
</div>
<a class="anchor" id="a53ef4ac30b1c59786e9ee3042e323451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::head </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> which contains the first n rows of this <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of rows to fetch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25b8e24216433856d64126ab3b12b7c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::gl_sframe::is_materialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not the sarray has been materialized.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#adf487ad5b75b7cff5e0aef3cf54857fb">materialize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac4a4f0e0c1ba3c70b2bc0505628e4729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>joinkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;inner&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Joins two <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> objects. Merges the current (left) <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> with the given (right) <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> using a SQL-style equi-join operation by columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> to join.</td></tr>
    <tr><td class="paramname">on</td><td>The column name(s) representing the set of join keys. Each row that has the same value in this set of columns will be merged together.</td></tr>
    <tr><td class="paramname">how</td><td>Optional. The type of join to perform. "inner" is default.<ul>
<li><b>"inner"</b> : Equivalent to a SQL inner join. Result consists of the rows from the two frames whose join key values match exactly, merged together into one <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</li>
<li><b>"left"</b> : Equivalent to a SQL left outer join. Result is the union between the result of an inner join and the rest of the rows from the left <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, merged with missing values.</li>
<li><b>"right"</b> : Equivalent to a SQL right outer join. Result is the union between the result of an inner join and the rest of the rows from the right <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, merged with missing values.</li>
<li><b>"outer"</b> : Equivalent to a SQL full outer join. Result is the union between the result of a left outer join and a right outer join.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> animals = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 2, 3, 4}},</div><div class="line">                          {<span class="stringliteral">&quot;name&quot;</span>, {<span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;sheep&quot;</span>, <span class="stringliteral">&quot;cow&quot;</span>}}});</div><div class="line"><span class="keyword">auto</span> sounds = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 3, 4, 5}},</div><div class="line">                         {<span class="stringliteral">&quot;sound&quot;</span>, {<span class="stringliteral">&quot;woof&quot;</span>, <span class="stringliteral">&quot;baa&quot;</span>, <span class="stringliteral">&quot;moo&quot;</span>, <span class="stringliteral">&quot;oink&quot;</span>}}});</div><div class="line">std::cout &lt;&lt;  animals.join(sounds, {<span class="stringliteral">&quot;id&quot;</span>});</div><div class="line">std::cout &lt;&lt;  animals.join(sounds, {<span class="stringliteral">&quot;id&quot;</span>}, <span class="stringliteral">&quot;left&quot;</span>);</div><div class="line">std::cout &lt;&lt;  animals.join(sounds, {<span class="stringliteral">&quot;id&quot;</span>}, <span class="stringliteral">&quot;right&quot;</span>);</div><div class="line">std::cout &lt;&lt;  animals.join(sounds, {<span class="stringliteral">&quot;id&quot;</span>}, <span class="stringliteral">&quot;outer&quot;</span>);</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+----+-------+-------+</div><div class="line">| <span class="keywordtype">id</span> |  name | sound |</div><div class="line">+----+-------+-------+</div><div class="line">| 1  |  dog  |  woof |</div><div class="line">| 3  | sheep |  baa  |</div><div class="line">| 4  |  cow  |  moo  |</div><div class="line">+----+-------+-------+</div><div class="line">[3 rows x 3 columns]</div><div class="line"></div><div class="line">+----+-------+-------+</div><div class="line">| <span class="keywordtype">id</span> |  name | sound |</div><div class="line">+----+-------+-------+</div><div class="line">| 1  |  dog  |  woof |</div><div class="line">| 3  | sheep |  baa  |</div><div class="line">| 4  |  cow  |  moo  |</div><div class="line">| 2  |  cat  |  None |</div><div class="line">+----+-------+-------+</div><div class="line">[4 rows x 3 columns]</div><div class="line"></div><div class="line">+----+-------+-------+</div><div class="line">| <span class="keywordtype">id</span> |  name | sound |</div><div class="line">+----+-------+-------+</div><div class="line">| 1  |  dog  |  woof |</div><div class="line">| 3  | sheep |  baa  |</div><div class="line">| 4  |  cow  |  moo  |</div><div class="line">| 5  |  None |  oink |</div><div class="line">+----+-------+-------+</div><div class="line">[4 rows x 3 columns]</div><div class="line"></div><div class="line">+----+-------+-------+</div><div class="line">| <span class="keywordtype">id</span> |  name | sound |</div><div class="line">+----+-------+-------+</div><div class="line">| 1  |  dog  |  woof |</div><div class="line">| 3  | sheep |  baa  |</div><div class="line">| 4  |  cow  |  moo  |</div><div class="line">| 5  |  None |  oink |</div><div class="line">| 2  |  cat  |  None |</div><div class="line">+----+-------+-------+</div><div class="line">[5 rows x 3 columns]</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa6ac4fb73c8b27c06338a02c1c0b1100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>joinkeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;inner&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Joins two <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> objects. Merges the current (left) <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> with the given (right) <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> using a SQL-style equi-join operation by columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">right</td><td>The <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> to join.</td></tr>
    <tr><td class="paramname">on</td><td>The column name(s) representing a map of join keys from left to right. Each key is taken as a column name on the left <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> and each value is taken as the column name in the right <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</td></tr>
    <tr><td class="paramname">how</td><td>Optional. The type of join to perform. "inner" is default.<ul>
<li><b>"inner"</b> : Equivalent to a SQL inner join. Result consists of the rows from the two frames whose join key values match exactly, merged together into one <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</li>
<li><b>"left"</b> : Equivalent to a SQL left outer join. Result is the union between the result of an inner join and the rest of the rows from the left <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, merged with missing values.</li>
<li><b>"right"</b> : Equivalent to a SQL right outer join. Result is the union between the result of an inner join and the rest of the rows from the right <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, merged with missing values.</li>
<li><b>"outer"</b> : Equivalent to a SQL full outer join. Result is the union between the result of a left outer join and a right outer join.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> animals = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 2, 3, 4}},</div><div class="line">                          {<span class="stringliteral">&quot;name&quot;</span>, {<span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;sheep&quot;</span>, <span class="stringliteral">&quot;cow&quot;</span>}}});</div><div class="line"><span class="keyword">auto</span> sounds = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 3, 4, 5}},</div><div class="line">                         {<span class="stringliteral">&quot;sound&quot;</span>, {<span class="stringliteral">&quot;woof&quot;</span>, <span class="stringliteral">&quot;baa&quot;</span>, <span class="stringliteral">&quot;moo&quot;</span>, <span class="stringliteral">&quot;oink&quot;</span>}}});</div><div class="line">std::cout &lt;&lt;  animals.join(sounds, {<span class="stringliteral">&quot;id&quot;</span>, <span class="stringliteral">&quot;id&quot;</span>});</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+----+-------+-------+</div><div class="line">| <span class="keywordtype">id</span> |  name | sound |</div><div class="line">+----+-------+-------+</div><div class="line">| 1  |  dog  |  woof |</div><div class="line">| 3  | sheep |  baa  |</div><div class="line">| 4  |  cow  |  moo  |</div><div class="line">+----+-------+-------+</div><div class="line">[3 rows x 3 columns]</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="adf487ad5b75b7cff5e0aef3cf54857fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::gl_sframe::materialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a SFrame that is lazily evaluated, force persist this sframe to disk, committing all lazy evaluated operations.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a25b8e24216433856d64126ab3b12b7c6">is_materialized</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9efaca3b4931004192bac3e7b10aaec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::gl_sframe::materialize_to_callback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(size_t, const std::shared_ptr&lt; <a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a> &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>(size_t)(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls a callback function passing each row of the SArray.</p>
<p>This does not materialize the array if not necessary.</p>
<p>The callback may be called in parallel in which case the argument provides a thread number. The function should return false, but may return true at anytime to quit the iteration process. It may also throw exceptions which will be forwarded to the caller of this function.</p>
<p>Each call to the callback passes:</p><ul>
<li>a thread id,</li>
<li>a shared_ptr to an <a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a> object</li>
</ul>
<p>The <a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a> object looks like a vector&lt;vector&lt;flexible_type&gt;&gt;. i.e. to look at all the rows, you need to write:</p>
<div class="fragment"><div class="line">sf.materalize_to_callback([&amp;](<span class="keywordtype">size_t</span>, <span class="keyword">const</span> std::shared_ptr&lt;sframe_rows&gt;&amp; rows) {</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; row: *rows) {</div><div class="line">     <span class="comment">// each row looks like an std::vector&lt;flexible_type&gt;</span></div><div class="line">     <span class="comment">// and can be casted to to a vector&lt;flexible_type&gt; if necessayr</span></div><div class="line">  }</div><div class="line">});</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to call </td></tr>
    <tr><td class="paramname">nthreads</td><td>Number of threads. If not specified, #cpus is used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e201949eec3ae44e18cdaecfee15ef5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t turi::gl_sframe::num_columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of columns of the SFrame. </p>

<p>Reimplemented in <a class="el" href="classturi_1_1gl__gframe.html#a3d51508fd3edad7acf8c6cdd18eccc49">turi::gl_gframe</a>.</p>

</div>
</div>
<a class="anchor" id="acb3d50c5d978bf53af08bbb041d1a0f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; turi::gl_sframe::operator[] </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value at a particular array index; generally inefficient.</p>
<p>This returns the value of the array at a particular index. Will raise an exception if the index is out of bounds. This operation is generally inefficient: the <a class="el" href="classturi_1_1gl__sframe.html#a628d77e61284ac2ab876fee7881136ad">range_iterator()</a> is prefered. </p>

</div>
</div>
<a class="anchor" id="a67a1f19c116316327bc11b6e621ac4a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; turi::gl_sframe::operator[] </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value at a particular array index; generally inefficient.</p>
<p>This returns the value of the array at a particular index. Will raise an exception if the index is out of bounds. This operation is generally inefficient: the <a class="el" href="classturi_1_1gl__sframe.html#a628d77e61284ac2ab876fee7881136ad">range_iterator()</a> is prefered. </p>

</div>
</div>
<a class="anchor" id="a31154a8ea5ebf5b7d50e223b46aa887f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a slice Python style.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>A list of 2 or 3 values. If 2 values, this is interpreted as {start, end} indices, with an implicit value of step = 1. If 3 values, this is interpreted as {start, step, end}. Values at the positions [start, start+step, start+2*start, ...] are returned until end (exclusive) is reached. Negative start and end values are interpreted as offsets from the end of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>Given a <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> </p><div class="fragment"><div class="line">gl_sarray a{1,2,3,4,5,6,7,8,9,10};</div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, a}}</div></div><!-- fragment --><p>Slicing a consecutive range: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ret = a[{1,4}];  <span class="comment">// start at index 1, end at index 4</span></div><div class="line"><span class="comment">// ret is a gl_sframe with one column a: [2,3,4]</span></div></div><!-- fragment --><p>Slicing a range with a step: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ret = a[{1,2,8}];  <span class="comment">// start at index 1, end at index 8 with step size 2</span></div><div class="line"><span class="comment">// ret is a gl_sframe with one column a: [2,4,6,8]</span></div></div><!-- fragment --><p>Using negative indexing: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ret = a[{-3,-1}];  <span class="comment">// start at end - 3, end at index end - 1</span></div><div class="line"><span class="comment">// ret a gl_sframe with one column a: [8,9]</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="acdeae8b0f02bf076ea79d404a765ae9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a slice Python style.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice</td><td>A list of 2 or 3 values. If 2 values, this is interpreted as {start, end} indices, with an implicit value of step = 1. If 3 values, this is interpreted as {start, step, end}. Values at the positions [start, start+step, start+2*start, ...] are returned until end (exclusive) is reached. Negative start and end values are interpreted as offsets from the end of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>Given a <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> </p><div class="fragment"><div class="line">gl_sarray a{1,2,3,4,5,6,7,8,9,10};</div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, a}}</div></div><!-- fragment --><p>Slicing a consecutive range: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ret = a[{1,4}];  <span class="comment">// start at index 1, end at index 4</span></div><div class="line"><span class="comment">// ret is a gl_sframe with one column a: [2,3,4]</span></div></div><!-- fragment --><p>Slicing a range with a step: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ret = a[{1,2,8}];  <span class="comment">// start at index 1, end at index 8 with step size 2</span></div><div class="line"><span class="comment">// ret is a gl_sframe with one column a: [2,4,6,8]</span></div></div><!-- fragment --><p>Using negative indexing: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ret = a[{-3,-1}];  <span class="comment">// start at end - 3, end at index end - 1</span></div><div class="line"><span class="comment">// ret a gl_sframe with one column a: [8,9]</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a258f8beb81645e5ae540fb2a702e5685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &amp;&#160;</td>
          <td class="paramname"><em>logical_filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a logical filter.</p>
<p>This function performs a logical filter: i.e. it subselects all the elements in this array where the corresponding value in the other array evaluates to true. </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}},</div><div class="line">             {<span class="stringliteral">&quot;c&quot;</span>, {1.0,2.0,3.0,4.0,5.0}}};</div><div class="line"><span class="keyword">auto</span> ret = sf[sf[<span class="stringliteral">&quot;a&quot;</span>] &gt; 1 &amp;&amp; sf[<span class="stringliteral">&quot;a&quot;</span>] &lt;= 4];</div><div class="line"></div><div class="line"><span class="comment">// ret is now the sframe with 3 columns:</span></div><div class="line"><span class="comment">// a: [2,3,4]</span></div><div class="line"><span class="comment">// b: [&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]</span></div><div class="line"><span class="comment">// c: [2.0,3.0,4.0]</span></div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad180a15f62085157698d0ac12b8dff58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::pack_columns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>dtype</em> = <code><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a298cb25408234de02baf2085803a464a">flex_type_enum::LIST</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td>
          <td class="paramname"><em>fill_na</em> = <code><a class="el" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Pack two or more columns of the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> into one single column. The result is a new <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> with the unaffected columns from the original <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> plus the newly created column.</p>
<p>The type of the resulting column is decided by the "dtype" parameter. Allowed values for "dtype" are <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ad7f73f951e7f6c4ed5e17c4204f4032e">flex_type_enum::DICT</a> , <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a87752381b583740610f1dfeb07fdad7e">flex_type_enum::VECTOR</a> or <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a298cb25408234de02baf2085803a464a">flex_type_enum::LIST</a></p>
<ul>
<li><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ad7f73f951e7f6c4ed5e17c4204f4032e">flex_type_enum::DICT</a> : pack to a dictionary <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> where column name becomes dictionary key and column value becomes dictionary value</li>
<li><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a87752381b583740610f1dfeb07fdad7e">flex_type_enum::VECTOR</a> : pack all values from the packing columns into an array</li>
<li><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a298cb25408234de02baf2085803a464a">flex_type_enum::LIST</a> : pack all values from the packing columns into a list.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columns</td><td>A list of column names to be packed. There must at least two columns to pack.</td></tr>
    <tr><td class="paramname">new_column_name</td><td>Packed column name.</td></tr>
    <tr><td class="paramname">dtype</td><td>Optional. The resulting packed column type. If not provided, dtype is list.</td></tr>
    <tr><td class="paramname">fill_na</td><td>Optional. Value to fill into packed column if missing value is encountered. If packing to dictionary, "fill_na" is only applicable to dictionary values; missing keys are not replaced.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: Suppose 'sf' is an an SFrame that maintains business category information. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;business&quot;</span>, {1,2,3,4}},</div><div class="line">                     {<span class="stringliteral">&quot;category.retail&quot;</span>, {1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, 1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>}},</div><div class="line">                     {<span class="stringliteral">&quot;category.food&quot;</span>, {1, 1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, FLEX_UNDEFINED}},</div><div class="line">                     {<span class="stringliteral">&quot;category.service&quot;</span>, {<a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, 1, 1, FLEX_UNDEFINED}},</div><div class="line">                     {<span class="stringliteral">&quot;category.shop&quot;</span>, {1, 1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, 1}}});</div><div class="line">std::cout &lt;&lt;  sf;</div></div><!-- fragment --> <div class="fragment"><div class="line">+----------+-----------------+---------------+------------------+---------------+</div><div class="line">| business | category.retail | category.food | category.service | category.shop |</div><div class="line">+----------+-----------------+---------------+------------------+---------------+</div><div class="line">|    1     |        1        |       1       |       None       |       1       |</div><div class="line">|    2     |       None      |       1       |        1         |       1       |</div><div class="line">|    3     |        1        |      None     |        1         |      None     |</div><div class="line">|    4     |       None      |       1       |       None       |       1       |</div><div class="line">+----------+-----------------+---------------+------------------+---------------+</div><div class="line">[4 rows x 5 columns]</div></div><!-- fragment --><p>To pack all category columns into a list: </p><div class="fragment"><div class="line">std::cout &lt;&lt;  sf.pack_columns({<span class="stringliteral">&quot;category.retail&quot;</span>, <span class="stringliteral">&quot;category.food&quot;</span>,</div><div class="line">                               <span class="stringliteral">&quot;category.service&quot;</span>, <span class="stringliteral">&quot;category.shop&quot;</span>},</div><div class="line">                               <span class="stringliteral">&quot;category&quot;</span>);</div></div><!-- fragment --> <div class="fragment"><div class="line">+----------+--------------------+</div><div class="line">| business |      category      |</div><div class="line">+----------+--------------------+</div><div class="line">|    1     |  [1, 1, None, 1]   |</div><div class="line">|    2     |  [None, 1, 1, 1]   |</div><div class="line">|    3     | [1, None, 1, None] |</div><div class="line">|    4     | [None, 1, None, 1] |</div><div class="line">+----------+--------------------+</div><div class="line">[4 rows x 2 columns]</div></div><!-- fragment --><p>To pack all category columns into a dictionary: </p><div class="fragment"><div class="line">std::cout &lt;&lt; sf.pack_columns({<span class="stringliteral">&quot;category.retail&quot;</span>, <span class="stringliteral">&quot;category.food&quot;</span>,</div><div class="line">                              <span class="stringliteral">&quot;category.service&quot;</span>, <span class="stringliteral">&quot;category.shop&quot;</span>},</div><div class="line">                              <span class="stringliteral">&quot;category&quot;</span>,</div><div class="line">                              <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ad7f73f951e7f6c4ed5e17c4204f4032e">flex_type_enum::DICT</a>);</div></div><!-- fragment --> <div class="fragment"><div class="line">+----------+--------------------------------+</div><div class="line">| business |               X2               |</div><div class="line">+----------+--------------------------------+</div><div class="line">|    1     | {<span class="stringliteral">&#39;category.retail&#39;</span>: 1, <span class="stringliteral">&#39;ca ... |</span></div><div class="line"><span class="stringliteral">|    2     | {&#39;</span>category.food<span class="stringliteral">&#39;: 1, &#39;</span>cate ... |</div><div class="line">|    3     | {<span class="stringliteral">&#39;category.retail&#39;</span>: 1, <span class="stringliteral">&#39;ca ... |</span></div><div class="line"><span class="stringliteral">|    4     | {&#39;</span>category.food<span class="stringliteral">&#39;: 1, &#39;</span>cate ... |</div><div class="line">+----------+--------------------------------+</div><div class="line">[4 rows x 2 columns]</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a317924b4743f3ff5a9710deee8052cfc">gl_sframe::unpack</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1523cf90a84cf5e98ae1c3bd437ce668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::pack_columns </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>dtype</em> = <code><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a298cb25408234de02baf2085803a464a">flex_type_enum::LIST</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td>
          <td class="paramname"><em>fill_na</em> = <code><a class="el" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pack two or more columns of the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> with a common column name prefix into one single column. The result is a new <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> with the unaffected columns from the original <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> plus the newly created column.</p>
<p>The type of the resulting column is decided by the "dtype" parameter. Allowed values for "dtype" are <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ad7f73f951e7f6c4ed5e17c4204f4032e">flex_type_enum::DICT</a> , <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a87752381b583740610f1dfeb07fdad7e">flex_type_enum::VECTOR</a> or <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a298cb25408234de02baf2085803a464a">flex_type_enum::LIST</a></p>
<ul>
<li><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ad7f73f951e7f6c4ed5e17c4204f4032e">flex_type_enum::DICT</a> : pack to a dictionary <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> where column name becomes dictionary key and column value becomes dictionary value</li>
<li><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a87752381b583740610f1dfeb07fdad7e">flex_type_enum::VECTOR</a> : pack all values from the packing columns into an array</li>
<li><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a298cb25408234de02baf2085803a464a">flex_type_enum::LIST</a> : pack all values from the packing columns into a list.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_prefix</td><td>Packs all columns with the given prefix.</td></tr>
    <tr><td class="paramname">new_column_name</td><td>Packed column name.</td></tr>
    <tr><td class="paramname">dtype</td><td>Optional. The resulting packed column type. If not provided, dtype is list.</td></tr>
    <tr><td class="paramname">fill_na</td><td>Optional. Value to fill into packed column if missing value is encountered. If packing to dictionary, "fill_na" is only applicable to dictionary values; missing keys are not replaced.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: Suppose 'sf' is an an SFrame that maintains business category information. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;business&quot;</span>, {1,2,3,4}},</div><div class="line">                     {<span class="stringliteral">&quot;category.retail&quot;</span>, {1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, 1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>}},</div><div class="line">                     {<span class="stringliteral">&quot;category.food&quot;</span>, {1, 1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, FLEX_UNDEFINED}},</div><div class="line">                     {<span class="stringliteral">&quot;category.service&quot;</span>, {<a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, 1, 1, FLEX_UNDEFINED}},</div><div class="line">                     {<span class="stringliteral">&quot;category.shop&quot;</span>, {1, 1, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, 1}}});</div><div class="line">std::cout &lt;&lt;  sf;</div></div><!-- fragment --> <div class="fragment"><div class="line">+----------+-----------------+---------------+------------------+---------------+</div><div class="line">| business | category.retail | category.food | category.service | category.shop |</div><div class="line">+----------+-----------------+---------------+------------------+---------------+</div><div class="line">|    1     |        1        |       1       |       None       |       1       |</div><div class="line">|    2     |       None      |       1       |        1         |       1       |</div><div class="line">|    3     |        1        |      None     |        1         |      None     |</div><div class="line">|    4     |       None      |       1       |       None       |       1       |</div><div class="line">+----------+-----------------+---------------+------------------+---------------+</div><div class="line">[4 rows x 5 columns]</div></div><!-- fragment --><p>To pack all category columns into a list: </p><div class="fragment"><div class="line">std::cout &lt;&lt;  sf.pack_columns(<span class="stringliteral">&quot;category&quot;</span>, <span class="stringliteral">&quot;category&quot;</span>);</div></div><!-- fragment --> <div class="fragment"><div class="line">+----------------+----------------+</div><div class="line">| business       | category       |</div><div class="line">+----------------+----------------+</div><div class="line">| 1              | [1,1,,1]       |</div><div class="line">| 2              | [,1,1,1]       |</div><div class="line">| 3              | [1,,1,]        |</div><div class="line">| 4              | [,,,1]         |</div><div class="line">+----------------+----------------+</div><div class="line">[4 rows x 2 columns]</div></div><!-- fragment --><p>To pack all category columns into a dictionary: </p><div class="fragment"><div class="line">std::cout &lt;&lt; sf.pack_columns(<span class="stringliteral">&quot;category&quot;</span>,</div><div class="line">                             <span class="stringliteral">&quot;category&quot;</span>,</div><div class="line">                             <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ad7f73f951e7f6c4ed5e17c4204f4032e">flex_type_enum::DICT</a>);</div></div><!-- fragment --> <div class="fragment"><div class="line">+----------+--------------------------------+</div><div class="line">| business |               X2               |</div><div class="line">+----------+--------------------------------+</div><div class="line">|    1     | {<span class="stringliteral">&#39;category.retail&#39;</span>: 1, <span class="stringliteral">&#39;ca ... |</span></div><div class="line"><span class="stringliteral">|    2     | {&#39;</span>category.food<span class="stringliteral">&#39;: 1, &#39;</span>cate ... |</div><div class="line">|    3     | {<span class="stringliteral">&#39;category.retail&#39;</span>: 1, <span class="stringliteral">&#39;ca ... |</span></div><div class="line"><span class="stringliteral">|    4     | {&#39;</span>category.food<span class="stringliteral">&#39;: 1, &#39;</span>cate ... |</div><div class="line">+----------+--------------------------------+</div><div class="line">[4 rows x 2 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a317924b4743f3ff5a9710deee8052cfc">gl_sframe::unpack</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeb517440b96be7d81a8da8ffdf68b406"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1model__base.html">model_base</a>&gt; turi::gl_sframe::plot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a plot object of the SFrame (same visualization as <code>show</code>) </p>

</div>
</div>
<a class="anchor" id="a88f9a2f546932b5a2d39a66f6986baf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&gt; turi::gl_sframe::random_split </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fraction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Randomly split the rows of an <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> into two <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> objects. The first <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> contains <b>M</b> rows, sampled uniformly (without replacement) from the original <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. <b>M</b> is approximately the fraction times the original number of rows. The second <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> contains the remaining rows of the original <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fraction</td><td>Approximate fraction of the rows to fetch for the first returned <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. Must be between 0 and 1.</td></tr>
    <tr><td class="paramname">seed</td><td>Optional. Seed for the random number generator used to split.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, <a class="code" href="classturi_1_1gl__sarray.html#a902f16b58fbdde7e6125f4ed63189095">gl_sarray::from_sequence</a>(0, 1024)}});</div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf_train, sf_test;</div><div class="line">std::tie(sf_train, sf_test) = sf.random_split(.95);</div><div class="line">std::cout &lt;&lt;  sf_test.size() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sf_train.size() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">102 922</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a92825d8fcd0c9d8d0df0e8a57d7f5150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>&gt; turi::gl_sframe::random_split </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Randomly split the rows of an <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> into two <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> objects. The first <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> contains <b>M</b> rows, sampled uniformly (without replacement) from the original <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. <b>M</b> is approximately the fraction times the original number of rows. The second <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> contains the remaining rows of the original <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fraction</td><td>Approximate fraction of the rows to fetch for the first returned <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. Must be between 0 and 1.</td></tr>
    <tr><td class="paramname">seed</td><td>The random seed for the random number generator. Deterministic output is obtained if this is set to a constant.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, <a class="code" href="classturi_1_1gl__sarray.html#a902f16b58fbdde7e6125f4ed63189095">gl_sarray::from_sequence</a>(0, 1024)}});</div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf_train, sf_test;</div><div class="line">std::tie(sf_train, sf_test) = sf.random_split(.95, 12345);</div><div class="line">std::cout &lt;&lt;  sf_test.size() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sf_train.size() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">44 980</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a628d77e61284ac2ab876fee7881136ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe__range.html">gl_sframe_range</a> turi::gl_sframe::range_iterator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>(size_t)(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a one pass range object with begin() and end() iterators.</p>
<p>This will materialize the array.</p>
<p>See <a class="el" href="classturi_1_1gl__sframe.html#a9efaca3b4931004192bac3e7b10aaec9">materialize_to_callback</a> for a lazy version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting index of the range </td></tr>
    <tr><td class="paramname">end</td><td>The ending index of the range</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// create an SFrame</span></div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>}},</div><div class="line">             {<span class="stringliteral">&quot;c&quot;</span>, {1.0,2.0,3.0,4.0,5.0}}};</div><div class="line"></div><div class="line"><span class="comment">// get a range over the entire frame</span></div><div class="line"><span class="keyword">auto</span> ra = sa.range_iterator();</div><div class="line"><span class="keyword">auto</span> iter = ra.begin();</div><div class="line"><span class="keywordflow">while</span> (iter != ra.end()) {</div><div class="line">  std::vector&lt;flexible_type&gt; val = *iter;</div><div class="line">  <span class="comment">// do something to val</span></div><div class="line">}</div></div><!-- fragment --><p>Or more compactly with C++11 syntax: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val: sa.range_iterator()) {</div><div class="line">  std::cout &lt;&lt; val[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; val[1] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; val[2] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p>The range returned only supports one pass. The outcome of a second call to begin() is undefined after any iterator is advanced.</p>
<p>When iterating over a <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> with many columns, if only a small number of columns are needed, there is a performance benefit to subselecting just those columns first before iterating.</p>
<p>i.e. if I only need columns "a" and "b" from the SFrame above: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val: sa[{<span class="stringliteral">&quot;a&quot;</span>,<span class="stringliteral">&quot;b&quot;</span>}].range_iterator()) {</div><div class="line">  std::cout &lt;&lt; val[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; val[1] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe__range.html">gl_sframe_range</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1d4703483f47a91e780d50f27eda68dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void turi::gl_sframe::remove_column </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove a column from this <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. This operation modifies the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> in place. Raises an exception if the column does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the column to remove.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 2, 3}},</div><div class="line">                     {<span class="stringliteral">&quot;val&quot;</span>, {<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>}}});</div><div class="line">sf.remove(<span class="stringliteral">&quot;val&quot;</span>);</div><div class="line">std::cout &lt;&lt; sf;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+----+</div><div class="line">| <span class="keywordtype">id</span> |</div><div class="line">+----+</div><div class="line">| 1  |</div><div class="line">| 2  |</div><div class="line">| 3  |</div><div class="line">+----+</div><div class="line">[3 rows x 1 columns]</div></div><!-- fragment --> 
<p>Reimplemented in <a class="el" href="classturi_1_1gl__gframe.html#a81a8c1571ac5c931f10dd8dd109b8503">turi::gl_gframe</a>.</p>

</div>
</div>
<a class="anchor" id="a209c96048dd921d8cfe58cc5d269bef9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void turi::gl_sframe::rename </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>old_to_new_names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rename the given columns. "names" is expected to be a dictionary mapping old names to new names. This changes the names of the columns given as the keys and replaces them with the names given as the values. This operation modifies the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>a map {old-name, new-name} pairs</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = SFrame({{<span class="stringliteral">&quot;X1&quot;</span>, {<span class="stringliteral">&quot;Alice&quot;</span>,<span class="stringliteral">&quot;Bob&quot;</span>}},</div><div class="line">                  {<span class="stringliteral">&quot;X2&quot;</span>, {<span class="stringliteral">&quot;123 Fake Street&quot;</span>,<span class="stringliteral">&quot;456 Fake Street&quot;</span>}}});</div><div class="line">sf.rename({{<span class="stringliteral">&quot;X1&quot;</span>, <span class="stringliteral">&quot;name&quot;</span>},{ <span class="stringliteral">&quot;X2&quot;</span>,<span class="stringliteral">&quot;address&quot;</span>}});</div><div class="line">std::cout &lt;&lt; sf;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+-------+-----------------+</div><div class="line">|  name |     address     |</div><div class="line">+-------+-----------------+</div><div class="line">| Alice | 123 Fake Street |</div><div class="line">|  Bob  | 456 Fake Street |</div><div class="line">+-------+-----------------+</div><div class="line">[2 rows x 2 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a60ec072e385fe36c6c26905847d6d8a4">column_names</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classturi_1_1gl__gframe.html#a4dc78e9fa1ad87729f06bac618e826ae">turi::gl_gframe</a>.</p>

</div>
</div>
<a class="anchor" id="aba874d1a42ffcf07c73a759b1be2f600"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void turi::gl_sframe::replace_add_column </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a column to this <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>, replacing a column with the same name already exists. The number of elements in the data given must match the length of every other column of the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. This operation modifies the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> in place. If no name is given, a default name is chosen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The column of data to add.</td></tr>
    <tr><td class="paramname">name</td><td>Optional. The name of the column. If no name is given, a default name is chosen.</td></tr>
  </table>
  </dd>
</dl>
<p>This is equivalent to using <a class="el" href="classturi_1_1gl__sframe.html#column_indexing">operator[]</a> for column assignment. </p><div class="fragment"><div class="line">sf[name] = data;</div></div><!-- fragment --><p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 2, 3}},</div><div class="line">                     {<span class="stringliteral">&quot;val&quot;</span>, {<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>}}});</div><div class="line"><span class="keyword">auto</span> sa = gl_sarray({<span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;fossa&quot;</span>});</div><div class="line">sf.replace_add_column(sa, <span class="stringliteral">&quot;species&quot;</span>);</div><div class="line">std::cout &lt;&lt;  sf;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+----+-----+---------+</div><div class="line">| <span class="keywordtype">id</span> | val | species |</div><div class="line">+----+-----+---------+</div><div class="line">| 1  |  A  |   cat   |</div><div class="line">| 2  |  B  |   dog   |</div><div class="line">| 3  |  C  |  fossa  |</div><div class="line">+----+-----+---------+</div><div class="line">[3 rows x 3 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#ae3751ba842c96411b5dd845f1294a5bd">add_column(const gl_sarray&amp;, const std::string&amp;)</a>, </dd></dl>

</div>
</div>
<a class="anchor" id="a65e4c4f7bf5d52ecbdfb0d2728e54298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::sample </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fraction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> which contains a subsample of the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fraction</td><td>The fraction of the rows to fetch. Must be between 0 and 1.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {1.0,2.0,3.0,4.0,5.0}}};</div><div class="line">std::cout &lt;&lt;  sf.sample(.3);</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">Columns:</div><div class="line">    a  integer</div><div class="line">    b  <span class="keywordtype">float</span></div><div class="line">Rows: ?</div><div class="line">Data:</div><div class="line">+----------------+----------------+</div><div class="line">| a              | b              |</div><div class="line">+----------------+----------------+</div><div class="line">| 4              | 4              |</div><div class="line">| 5              | 5              |</div><div class="line">+----------------+----------------+</div><div class="line">? rows x 2 columns]</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0f8611489111164e4e3712f18069b2fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::sample </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> which contains a subsample of the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fraction</td><td>The fraction of the rows to fetch. Must be between 0 and 1.</td></tr>
    <tr><td class="paramname">seed</td><td>The random seed for the random number generator. Deterministic output is obtained if this is set to a constant.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{{<span class="stringliteral">&quot;a&quot;</span>, {1,2,3,4,5}},</div><div class="line">             {<span class="stringliteral">&quot;b&quot;</span>, {1.0,2.0,3.0,4.0,5.0}}};</div><div class="line">std::cout &lt;&lt;  sf.sample(.3, 12345);</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">Columns:</div><div class="line">    a  integer</div><div class="line">    b  <span class="keywordtype">float</span></div><div class="line">Rows: ?</div><div class="line">Data:</div><div class="line">+----------------+----------------+</div><div class="line">| a              | b              |</div><div class="line">+----------------+----------------+</div><div class="line">| 4              | 4              |</div><div class="line">| 5              | 5              |</div><div class="line">+----------------+----------------+</div><div class="line">? rows x 2 columns]</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7c9148b0602a4c59730c6c0e6b77ddbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::gl_sframe::save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves the SFrame to file.</p>
<p>When format is "binary", the saved SArray will be in a directory named with the <code>targetfile</code> parameter. When format is "text" or "csv", it is saved as a single human readable text file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A local path or a remote URL. If format is 'text', it will be saved as a text file. If format is 'binary', a directory will be created at the location which will contain the SArray.</td></tr>
    <tr><td class="paramname">format</td><td>Optional. Either "binary", "csv" or "". Defaults to "". Format in which to save the SFrame. Binary saved SArrays can be loaded much faster and without any format conversion losses. If "csv", Each row will be written as a single line in an output text file. If format is an empty string (default), we will try to infer the format from filename given. If file name ends with "csv", or ".csv.gz", then the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> is saved as "csv" format, otherwise the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> is saved as 'binary' format. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab406e6e4714b58b82bbe0b821db4fff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::gl_sframe::save_reference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an incomplete save of an existing SFrame into a directory. This saved SFrame may reference SFrames in other locations <em>in the same filesystem</em> for certain columns/segments/etc.</p>
<p>Does not modify the current sframe. </p>

</div>
</div>
<a class="anchor" id="a2db73f6ccb38e1cc3de7086ed1d067ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> turi::gl_sframe::select_column </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts one column of the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</p>
<p>This is equivalent to using <a class="el" href="classturi_1_1gl__sframe.html#column_indexing">operator[]</a> for column indexing.</p>
<p>Equivalent to: </p><div class="fragment"><div class="line">sf[colname];</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#af14a0eec9d6e00e0215c0be86bc253c4">select_columns</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af14a0eec9d6e00e0215c0be86bc253c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::select_columns </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>colnames</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts a collection of columns of the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</p>
<p>This is equivalent to using <a class="el" href="classturi_1_1gl__sframe.html#multi_column_indexing">operator[]</a> for selecting multiple columns </p><div class="fragment"><div class="line">sf[colnames];</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a2db73f6ccb38e1cc3de7086ed1d067ec">select_column</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af540e300aebd52885b5f20fcfb446e3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::gl_sframe::show </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_to_client</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Show a visualization of the SFrame. </p>

</div>
</div>
<a class="anchor" id="a996a165e932c322c003d3be275e32b6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t turi::gl_sframe::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of rows of the SFrame.</p>
<p>This may trigger materialization in situations in which the size of the SFrame is not known. For instance after a logical filter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#ab8e5666b09b30317ec397b5266c2f4be">has_size</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classturi_1_1gl__gframe.html#ae152bba7d8fd64743c20f2bd62ca6c63">turi::gl_gframe</a>.</p>

</div>
</div>
<a class="anchor" id="ac3e77d1b853f16abcb7b17159640ed57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::sort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascending</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> by a single column, using the given sort order.</p>
<p>Only columns that are type of str, int and float can be sorted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>The name of the column to be sorted.</td></tr>
    <tr><td class="paramname">ascending</td><td>Optional. Sort all columns in the given order.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{ {<span class="stringliteral">&quot;a&quot;</span>, {1,3,2,1}},</div><div class="line">              {<span class="stringliteral">&quot;b&quot;</span>, {<span class="stringliteral">&quot;a&quot;</span>,<span class="stringliteral">&quot;c&quot;</span>,<span class="stringliteral">&quot;b&quot;</span>,<span class="stringliteral">&quot;b&quot;</span>}},</div><div class="line">              {<span class="stringliteral">&quot;c&quot;</span>, {<span class="stringliteral">&quot;x&quot;</span>,<span class="stringliteral">&quot;y&quot;</span>,<span class="stringliteral">&quot;z&quot;</span>,<span class="stringliteral">&quot;y&quot;</span>}} };</div><div class="line">std::cout &lt;&lt; sf.sort(<span class="stringliteral">&quot;a&quot;</span>) &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+---+---+---+</div><div class="line">| a | b | c |</div><div class="line">+---+---+---+</div><div class="line">| 1 | a | x |</div><div class="line">| 1 | b | y |</div><div class="line">| 2 | b | z |</div><div class="line">| 3 | c | y |</div><div class="line">+---+---+---+</div><div class="line">[4 rows x 3 columns]</div></div><!-- fragment --><p>Example: </p><div class="fragment"><div class="line"><span class="comment">// To sort by column &quot;a&quot;, descending</span></div><div class="line">std::cout &lt;&lt; sf.sort(<span class="stringliteral">&quot;a&quot;</span>, <span class="keyword">false</span>) &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+---+---+---+</div><div class="line">| a | b | c |</div><div class="line">+---+---+---+</div><div class="line">| 3 | c | y |</div><div class="line">| 2 | b | z |</div><div class="line">| 1 | a | x |</div><div class="line">| 1 | b | y |</div><div class="line">+---+---+---+</div><div class="line">[4 rows x 3 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#af70f5158431f9d55ab56494272c21199">topk</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f7b9d0c17924489767cb47875e6721f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::sort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascending</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Sort current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> by a multiple columns, using the given sort order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">columns</td><td>The names of the columns to be sorted.</td></tr>
    <tr><td class="paramname">ascending</td><td>Optional. Sort all columns in the given order.</td></tr>
  </table>
  </dd>
</dl>
<p>The result will be sorted first by first column, followed by second column, and so on. All columns will be sorted in the same order as governed by the "ascending" parameter.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// To sort by column &quot;a&quot; and &quot;b&quot;, all ascending</span></div><div class="line">std::cout &lt;&lt; sf.sort({<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>}) &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+---+---+---+</div><div class="line">| a | b | c |</div><div class="line">+---+---+---+</div><div class="line">| 1 | a | x |</div><div class="line">| 1 | b | y |</div><div class="line">| 2 | b | z |</div><div class="line">| 3 | c | y |</div><div class="line">+---+---+---+</div><div class="line">[4 rows x 3 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#af70f5158431f9d55ab56494272c21199">topk</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad93367d33f564e183ae29420d9468737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::sort </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascending</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a6c95fee095834645fb33eb879d40b48e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::sort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>column_and_ascending</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Sort current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> by a multiple columns, using different sort order for each column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_and_ascending</td><td>A map from column name to sort order (ascending is true)</td></tr>
  </table>
  </dd>
</dl>
<p>To sort by column "a" ascending, and then by column "c" descending To control the sort ordering for each column individually, "sort_columns" must be a list of (str, bool) pairs. Given this case, the first value is the column name and the second value is a boolean indicating whether the sort order is ascending.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// To sort by column &quot;a&quot; ascending, and then by column &quot;c&quot; descending</span></div><div class="line">std::cout &lt;&lt; sf.sort({{<span class="stringliteral">&quot;a&quot;</span>, <span class="keyword">true</span>}, {<span class="stringliteral">&quot;c&quot;</span>, <span class="keyword">false</span>}}) &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+---+---+---+</div><div class="line">| a | b | c |</div><div class="line">+---+---+---+</div><div class="line">| 1 | b | y |</div><div class="line">| 1 | a | x |</div><div class="line">| 2 | b | z |</div><div class="line">| 3 | c | y |</div><div class="line">+---+---+---+</div><div class="line">[4 rows x 3 columns]</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3837285fdecdcbd8c5f3d4b897760426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::split_datetime </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expand_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name_prefix</em> = <code>&quot;X&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tzone</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits a datetime column of <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> to multiple columns, with each value in a separate column. Returns a new <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> with the column replaced with a list of new columns. The expanded column must be of datetime type. For more details regarding name generation and other, refer to <a class="el" href="classturi_1_1gl__sarray.html#a8c93a105035c20c1a00d496b2957d5b3">gl_sarray::split_datetime</a></p>
<p>This function is a convenience function which is equivalent to calling <a class="el" href="classturi_1_1gl__sarray.html#a8c93a105035c20c1a00d496b2957d5b3">gl_sarray::split_datetime</a> on the column, deleting the column and adding the expanded columns back to the sframe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expand_column</td><td>Name of the column to expand.</td></tr>
    <tr><td class="paramname">column_name_prefix</td><td>Optional. If provided, expanded column names would start with the given prefix. If not provided, the default value is the name of the expanded column.</td></tr>
    <tr><td class="paramname">limit</td><td>Optional. Limits the set of datetime elements to expand. Elements are 'year','month','day','hour','minute', and 'second'.</td></tr>
    <tr><td class="paramname">tzone</td><td>Optional. A boolean parameter that determines whether to show the timezone column or not. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sa = gl_sarray({<span class="stringliteral">&quot;20-Oct-2011&quot;</span>, <span class="stringliteral">&quot;10-Jan-2012&quot;</span>});</div><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf;</div><div class="line">sf[<span class="stringliteral">&quot;date&quot;</span>] = sa.str_to_datetime(<span class="stringliteral">&quot;%d-%b-%Y&quot;</span>);</div><div class="line"><span class="keyword">auto</span> split_sf = sf.split_datetime(<span class="stringliteral">&quot;date&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, {<span class="stringliteral">&quot;day&quot;</span>,<span class="stringliteral">&quot;year&quot;</span>});</div><div class="line">std::cout &lt;&lt; split_sf;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">Columns:</div><div class="line">    day  integer</div><div class="line">    year integer</div><div class="line">+----------------+----------------+</div><div class="line">| day            | year           |</div><div class="line">+----------------+----------------+</div><div class="line">| 20             | 2011           |</div><div class="line">| 10             | 2012           |</div><div class="line">+----------------+----------------+</div><div class="line">[2 rows x 2 columns]</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a80e67a97288ecbac0b1a0dfa4ae71764"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::stack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drop_na</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a "wide" column of an <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> to one or two "tall" columns by stacking all values.</p>
<p>The stack works only for columns of list, or array type (for the dict type, see the <a class="el" href="classturi_1_1gl__sframe.html#a532c17f03b896064dc7d2c2afc472e5f">overload</a>). One new column is created as a result of stacking, where each row holds one element of the array or list value, and the rest columns from the same original row repeated.</p>
<p>The new <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> includes the newly created column and all columns other than the one that is stacked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_names</td><td>The column(s) to stack. This column must be of dict/list/array type</td></tr>
    <tr><td class="paramname">new_column_name</td><td>Optional. The new column name. If not given, column names are generated automatically.</td></tr>
    <tr><td class="paramname">drop_na</td><td>Optional. Defaults to false. If true, missing values and empty list/array/dict are all dropped from the resulting column(s). If false, missing values are maintained in stacked column(s).</td></tr>
  </table>
  </dd>
</dl>
<p>Suppose 'sf' is an SFrame that contains a user and his/her friends, where 'friends' columns is an array type. Stack on 'friends' column would create a user/friend list for each user/friend pair: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>  sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;topic&quot;</span>,{1,2,3}},</div><div class="line">                      {<span class="stringliteral">&quot;friends&quot;</span>,{{2,3,4}, {5,6}, {4,5,10,<a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>}}}</div><div class="line">                     });</div><div class="line">std::cout &lt;&lt;  sf;</div><div class="line">std::cout &lt;&lt;  sf.stack(<span class="stringliteral">&quot;friends&quot;</span>, <span class="stringliteral">&quot;friend&quot;</span>);</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+------+------------------+</div><div class="line">| user |     friends      |</div><div class="line">+------+------------------+</div><div class="line">|  1   |     [2, 3, 4]    |</div><div class="line">|  2   |      [5, 6]      |</div><div class="line">|  3   | [4, 5, 10, None] |</div><div class="line">+------+------------------+</div><div class="line">[3 rows x 2 columns]</div><div class="line"></div><div class="line">+------+--------+</div><div class="line">| user | <span class="keyword">friend</span> |</div><div class="line">+------+--------+</div><div class="line">|  1   |  2     |</div><div class="line">|  1   |  3     |</div><div class="line">|  1   |  4     |</div><div class="line">|  2   |  5     |</div><div class="line">|  2   |  6     |</div><div class="line">|  3   |  4     |</div><div class="line">|  3   |  5     |</div><div class="line">|  3   |  1     |</div><div class="line">|  3   |  None  |</div><div class="line">+------+--------+</div><div class="line">[9 rows x 2 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a03ed60b99a17669a732012a4607fd3fd">gl_sframe::unstack(const std::vector&lt;std::string&gt;&amp;, const std::string&amp;) const</a> </dd>
<dd>
<a class="el" href="classturi_1_1gl__sframe.html#a532c17f03b896064dc7d2c2afc472e5f">stack(const std::string&amp;, const std::vector&lt;std::string&gt;&amp;, bool)const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a532c17f03b896064dc7d2c2afc472e5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::stack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drop_na</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a "wide" column of an <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> to one or two "tall" columns by stacking all values.</p>
<p>The stack works only for columns of dictionary type (for the list or array types, see the <a class="el" href="classturi_1_1gl__sframe.html#a80e67a97288ecbac0b1a0dfa4ae71764">overload</a>). Two new columns are created as a result of stacking: one column holds the key and another column holds the value. The rest of the columns are repeated for each key/value pair.</p>
<p>The new <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> includes the newly created columns and all columns other than the one that is stacked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_names</td><td>The column(s) to stack. This column must be of dict/list/array type</td></tr>
    <tr><td class="paramname">new_column_names</td><td>Optional. The new column names. Must be an vector of 2 values corresponding to the "key" column and the "value" column. If not given, column names are generated automatically.</td></tr>
    <tr><td class="paramname">drop_na</td><td>Optional. Defaults to false. If true, missing values and empty list/array/dict are all dropped from the resulting column(s). If false, missing values are maintained in stacked column(s).</td></tr>
  </table>
  </dd>
</dl>
<p>Suppose 'sf' is an SFrame that contains a column of dict type. Stack would stack all keys in one column and all values in another column: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>  sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;topic&quot;</span>,{1,2,3,4}},</div><div class="line">                      {<span class="stringliteral">&quot;words&quot;</span>, {<a class="code" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a>{{<span class="stringliteral">&quot;a&quot;</span>,3},{<span class="stringliteral">&quot;cat&quot;</span>,2}},</div><div class="line">                                 <a class="code" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a>{{<span class="stringliteral">&quot;a&quot;</span>,1},{<span class="stringliteral">&quot;the&quot;</span>,2}},</div><div class="line">                                 <a class="code" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a>{{<span class="stringliteral">&quot;the&quot;</span>,1},{<span class="stringliteral">&quot;dog&quot;</span>,3}},</div><div class="line">                                 <a class="code" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a>()}</div><div class="line">                       }});</div><div class="line">std::cout &lt;&lt;  sf.stack(<span class="stringliteral">&quot;words&quot;</span>, new_column_name={<span class="stringliteral">&quot;word&quot;</span>, <span class="stringliteral">&quot;count&quot;</span>});</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+-------+----------------------+</div><div class="line">| topic |        words         |</div><div class="line">+-------+----------------------+</div><div class="line">|   1   |  {<span class="charliteral">&#39;a&#39;</span>: 3, <span class="stringliteral">&#39;cat&#39;</span>: 2}  |</div><div class="line">|   2   |  {<span class="charliteral">&#39;a&#39;</span>: 1, <span class="stringliteral">&#39;the&#39;</span>: 2}  |</div><div class="line">|   3   | {<span class="stringliteral">&#39;the&#39;</span>: 1, <span class="stringliteral">&#39;dog&#39;</span>: 3} |</div><div class="line">|   4   |          {}          |</div><div class="line">+-------+----------------------+</div><div class="line">[4 rows x 2 columns]</div><div class="line"></div><div class="line">+-------+------+-------+</div><div class="line">| topic | word | count |</div><div class="line">+-------+------+-------+</div><div class="line">|   1   |  a   |   3   |</div><div class="line">|   1   | cat  |   2   |</div><div class="line">|   2   |  a   |   1   |</div><div class="line">|   2   | the  |   2   |</div><div class="line">|   3   | the  |   1   |</div><div class="line">|   3   | dog  |   3   |</div><div class="line">|   4   | None |  None |</div><div class="line">+-------+------+-------+</div><div class="line">[7 rows x 3 columns]</div><div class="line"></div><div class="line">Observe that since topic 4 had no words, an <a class="code" href="classturi_1_1gl__sframe.html#aedcbec920508d8cbab095a9e308331f7">empty</a> row is inserted.</div><div class="line">To drop that row, <span class="keyword">set</span> dropna=True in the parameters to <a class="code" href="classturi_1_1gl__sframe.html#a80e67a97288ecbac0b1a0dfa4ae71764">stack</a>.</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#ac0c871590042d94c5486278296814e4d">unstack(const std::string&amp;, const std::string&amp;) const</a> </dd>
<dd>
<a class="el" href="classturi_1_1gl__sframe.html#a80e67a97288ecbac0b1a0dfa4ae71764">stack(const std::string&amp;, const std::string&amp;, bool)const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a37e0b9ab9d94a78cb554056350e4b22f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void turi::gl_sframe::swap_columns </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the columns with the given names. This operation modifies the current <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> in place. Raises an exception if the columns do not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_1</td><td>Name of column to swap</td></tr>
    <tr><td class="paramname">column_2</td><td>Name of other column to swap</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1, 2, 3}},</div><div class="line">                     { <span class="stringliteral">&quot;val&quot;</span>, {<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>}}});</div><div class="line">sf.swap_columns(<span class="stringliteral">&quot;id&quot;</span>, <span class="stringliteral">&quot;val&quot;</span>);</div><div class="line">std::cout &lt;&lt; sf;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+-----+-----+</div><div class="line">| val | <span class="keywordtype">id</span>  |</div><div class="line">+-----+-----+</div><div class="line">|  A  |  1  |</div><div class="line">|  B  |  2  |</div><div class="line">|  C  |  3  |</div><div class="line">+----+-----+</div><div class="line">[3 rows x 2 columns]</div></div><!-- fragment --> 
<p>Reimplemented in <a class="el" href="classturi_1_1gl__gframe.html#a5da13b7887a811e40caff2bf02626832">turi::gl_gframe</a>.</p>

</div>
</div>
<a class="anchor" id="ad2647e8daca2846e317eef54bb2eeae1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::tail </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> which contains the last n rows of this <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of rows to fetch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af70f5158431f9d55ab56494272c21199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::topk </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get top k rows according to the given column. Result is according to and sorted by "column_name" in the given order (default is descending). When "k" is small, "topk" is more efficient than "sort".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_name</td><td>The column to sort on</td></tr>
    <tr><td class="paramname">k</td><td>Optional. Defaults to 10 The number of rows to return.</td></tr>
    <tr><td class="paramname">reverse</td><td>Optional. Defaults to False. If true, return the top k rows in ascending order, otherwise, in descending order.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, <a class="code" href="classturi_1_1gl__sarray.html#a902f16b58fbdde7e6125f4ed63189095">gl_sarray::from_sequence</a>(1000)}});</div><div class="line"><span class="keyword">auto</span> sf[<span class="stringliteral">&quot;value&quot;</span>] = 0 - sf[<span class="stringliteral">&quot;id&quot;</span>];</div><div class="line">std::cout &lt;&lt;  sf.topk(<span class="stringliteral">&quot;id&quot;</span>, k=3);</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+--------+--------+</div><div class="line">|   <span class="keywordtype">id</span>   |  value |</div><div class="line">+--------+--------+</div><div class="line">|   999  |  -999  |</div><div class="line">|   998  |  -998  |</div><div class="line">|   997  |  -997  |</div><div class="line">+--------+--------+</div><div class="line">[3 rows x 2 columns]</div></div><!-- fragment --><p>Example: </p><div class="fragment"><div class="line">std::cout &lt;&lt; sf.topk(<span class="stringliteral">&quot;value&quot;</span>, k=3);</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+--------+--------+</div><div class="line">|   <span class="keywordtype">id</span>   |  value |</div><div class="line">+--------+--------+</div><div class="line">|   1    |  -1    |</div><div class="line">|   2    |  -2    |</div><div class="line">|   3    |  -3    |</div><div class="line">+--------+--------+</div><div class="line">[3 rows x 2 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#ac3e77d1b853f16abcb7b17159640ed57">sort</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4330bbe2e6276fcf0c94dca0405ddc48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove duplicate rows of the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. Will not necessarily preserve the order of the given <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> in the new <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a> sf{ {<span class="stringliteral">&quot;id&quot;</span>, {1,2,3,3,4}},</div><div class="line">              {<span class="stringliteral">&quot;value&quot;</span>, {1,2,3,3,4}} };</div><div class="line">std::cout &lt;&lt; sf.unique() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+----+-------+</div><div class="line">| <span class="keywordtype">id</span> | value |</div><div class="line">+----+-------+</div><div class="line">| 2  |   2   |</div><div class="line">| 4  |   4   |</div><div class="line">| 3  |   3   |</div><div class="line">| 1  |   1   |</div><div class="line">+----+-------+</div><div class="line">[4 rows x 2 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sarray.html#a34984b913250f0fe75cf59c3f53aa2be">gl_sarray::unique</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a317924b4743f3ff5a9710deee8052cfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::unpack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unpack_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name_prefix</em> = <code>&quot;X&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_types</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>na_value</em> = <code><a class="el" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::vector&lt;&#160;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand one column of this <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> to multiple columns with each value in a separate column. Returns a new <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> with the unpacked column replaced with a list of new columns. The column must be of list/array/dict type. For more details regarding name generation, missing value handling and other, refer to <a class="el" href="classturi_1_1gl__sarray.html#a3a4d9591eb619e62ede1144c005379f1">gl_sarray::unpack</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unpack_column</td><td>Name of the unpacked column</td></tr>
    <tr><td class="paramname">column_name_prefix</td><td>Optional. If provided, unpacked column names would start with the given prefix. Defaults to "X". If the empty string is used, no prefix is used.</td></tr>
    <tr><td class="paramname">column_types</td><td>Optional. Column types for the unpacked columns. If not provided, column types are automatically inferred from first 100 rows. Defaults to FLEX_UNDEFINED.</td></tr>
    <tr><td class="paramname">na_value</td><td>Optional. Convert all values that are equal to "na_value" to missing value if specified.</td></tr>
    <tr><td class="paramname">limit</td><td>optional limits in the set of list/vector/dict keys to unpack. For list/vector gl_sarrays, "limit" must contain integer indices. For dict gl_sarrays, "limit" must contain dictionary keys.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line">sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;id&quot;</span>, {1,2,3}},</div><div class="line">                {<span class="stringliteral">&quot;wc&quot;</span>: {<a class="code" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a>{{<span class="stringliteral">&quot;a&quot;</span>, 1}},</div><div class="line">                        <a class="code" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a>{{<span class="stringliteral">&quot;b&quot;</span>, 2}},</div><div class="line">                        <a class="code" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a>{{<span class="stringliteral">&quot;a&quot;</span>, 1},{<span class="stringliteral">&quot;b&quot;</span>, 2}}</div><div class="line">                        }</div><div class="line">                }});</div><div class="line">std::cout &lt;&lt; sf;</div></div><!-- fragment --> <div class="fragment"><div class="line">+----+------------------+</div><div class="line">| <span class="keywordtype">id</span> |        wc        |</div><div class="line">+----+------------------+</div><div class="line">| 1  |     {<span class="charliteral">&#39;a&#39;</span>: 1}     |</div><div class="line">| 2  |     {<span class="charliteral">&#39;b&#39;</span>: 2}     |</div><div class="line">| 3  | {<span class="charliteral">&#39;a&#39;</span>: 1, <span class="charliteral">&#39;b&#39;</span>: 2} |</div><div class="line">+----+------------------+</div><div class="line">[3 rows x 2 columns]</div></div><!-- fragment --><p>To unpack: </p><div class="fragment"><div class="line">std::cout &lt;&lt; sf.unpack(<span class="stringliteral">&quot;wc&quot;</span>);</div></div><!-- fragment --> <div class="fragment"><div class="line">+----+------+------+</div><div class="line">| <span class="keywordtype">id</span> | wc.a | wc.b |</div><div class="line">+----+------+------+</div><div class="line">| 1  |  1   | None |</div><div class="line">| 2  | None |  2   |</div><div class="line">| 3  |  1   |  2   |</div><div class="line">+----+------+------+</div><div class="line">[3 rows x 3 columns]</div></div><!-- fragment --><p>To not have prefix in the generated column name:: </p><div class="fragment"><div class="line">std::cout &lt;&lt; sf.unpack(<span class="stringliteral">&quot;wc&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment --> <div class="fragment"><div class="line">+----+------+------+</div><div class="line">| <span class="keywordtype">id</span> | wc.a | wc.b |</div><div class="line">+----+------+------+</div><div class="line">| 1  |  1   | None |</div><div class="line">| 2  | None |  2   |</div><div class="line">| 3  |  1   |  2   |</div><div class="line">+----+------+------+</div><div class="line">[3 rows x 3 columns]</div></div><!-- fragment --><p>To limit subset of keys to unpack: </p><div class="fragment"><div class="line">std::cout &lt;&lt; sf.unpack(<span class="stringliteral">&quot;wc&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, {}, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>, {<span class="stringliteral">&quot;b&quot;</span>});</div></div><!-- fragment --> <div class="fragment"><div class="line">+----+------+</div><div class="line">| <span class="keywordtype">id</span> |   b  |</div><div class="line">+----+------+</div><div class="line">| 1  | None |</div><div class="line">| 2  |  2   |</div><div class="line">| 3  |  2   |</div><div class="line">+----+------+</div><div class="line">[3 rows x 3 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#ad180a15f62085157698d0ac12b8dff58">gl_sframe::pack_columns</a> </dd>
<dd>
<a class="el" href="classturi_1_1gl__sarray.html#a3a4d9591eb619e62ede1144c005379f1">gl_sarray::unpack</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac0c871590042d94c5486278296814e4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::unstack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_column_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate values from one columns into one column, grouping by all other columns. The resulting column could be of type list or array. If "column" is a numeric column, the result will be of vector type. If "column" is a non-numeric column, the new column will be of list type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>The column that is to be concatenated. If str, then collapsed column type is either array or list.</td></tr>
    <tr><td class="paramname">new_column_name</td><td>Optional. New column name. If not given, a name is generated automatically.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>  sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;friend&quot;</span>, {2, 3, 4, 5, 6, 4, 5, 2, 3}},</div><div class="line">                      {<span class="stringliteral">&quot;user&quot;</span>, {1, 1, 1, 2, 2, 2, 3, 4, 4}}});</div><div class="line">std::cout &lt;&lt;  sf.unstack(<span class="stringliteral">&quot;friend&quot;</span>, <span class="stringliteral">&quot;friends&quot;</span>);</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+------+-----------------------------+</div><div class="line">| user |           friends           |</div><div class="line">+------+-----------------------------+</div><div class="line">|  3   |            [5.0]            |</div><div class="line">|  1   |       [2.0, 4.0, 3.0]       |</div><div class="line">|  2   |       [5.0, 6.0, 4.0]       |</div><div class="line">|  4   |          [2.0, 3.0]         |</div><div class="line">+------+-----------------------------+</div><div class="line">[4 rows x 2 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a80e67a97288ecbac0b1a0dfa4ae71764">stack(const std::string&amp;, const std::string&amp;, bool)const</a> </dd>
<dd>
<a class="el" href="classturi_1_1gl__sframe.html#a9762ca4858f7422616f48e05e4247ef4">groupby</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a03ed60b99a17669a732012a4607fd3fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> turi::gl_sframe::unstack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>new_column_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate values two columns into one column, grouping by all other columns. The new column will be of dict type where the keys are taken from the first column in the list, and the values taken from the second column in the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>The columns that are to be concatenated.</td></tr>
    <tr><td class="paramname">new_column_name</td><td>Optional. New column name. If not given, a name is generated automatically.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span>  sf = <a class="code" href="classturi_1_1gl__sframe.html#a78e4306bd76ecfa597bde4244dee49aa">gl_sframe</a>({{<span class="stringliteral">&quot;count&quot;</span>,{4, 2, 1, 1, 2, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>}},</div><div class="line">                      {<span class="stringliteral">&quot;topic&quot;</span>,{<span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;elephant&quot;</span>, <span class="stringliteral">&quot;elephant&quot;</span>, <span class="stringliteral">&quot;fish&quot;</span>}},</div><div class="line">                      {<span class="stringliteral">&quot;word&quot;</span>, {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>}}});</div><div class="line">std::cout &lt;&lt;  sf.unstack({<span class="stringliteral">&quot;word&quot;</span>, <span class="stringliteral">&quot;count&quot;</span>}, <span class="stringliteral">&quot;words&quot;</span>);</div></div><!-- fragment --><p>Produces output: </p><div class="fragment"><div class="line">+----------+------------------+</div><div class="line">|  topic   |      words       |</div><div class="line">+----------+------------------+</div><div class="line">| elephant | {<span class="charliteral">&#39;a&#39;</span>: 1, <span class="charliteral">&#39;b&#39;</span>: 2} |</div><div class="line">|   dog    |     {<span class="charliteral">&#39;c&#39;</span>: 1}     |</div><div class="line">|   cat    | {<span class="charliteral">&#39;a&#39;</span>: 4, <span class="charliteral">&#39;c&#39;</span>: 2} |</div><div class="line">|   fish   |       None       |</div><div class="line">+----------+------------------+</div><div class="line">[4 rows x 2 columns]</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1gl__sframe.html#a80e67a97288ecbac0b1a0dfa4ae71764">stack</a> </dd>
<dd>
<a class="el" href="classturi_1_1gl__sframe.html#a9762ca4858f7422616f48e05e4247ef4">groupby</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="afe7a7f882ece2d394a9465430b9bd7d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provides printing of the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/data/sframe/<a class="el" href="gl__sframe_8hpp_source.html">gl_sframe.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
