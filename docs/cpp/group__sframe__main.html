<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: Main SFrame Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__sframe__main.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Main SFrame Objects<div class="ingroups"><a class="el" href="group__sframe__physical.html">SFrame : Physical</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceturi_1_1sframe__config"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sframe__config.html">turi::sframe_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray.html">turi::sarray&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__block__iterator.html">turi::sarray_block_iterator&lt; DataType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__iterator.html">turi::sarray_iterator&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__reader.html">turi::sarray_reader&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__reader__buffer.html">turi::sarray_reader_buffer&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html">turi::sframe</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1sframe__index__file__information.html">turi::sframe_index_file_information</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1parallel__sframe__iterator__initializer.html">turi::parallel_sframe_iterator_initializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1parallel__sframe__iterator.html">turi::parallel_sframe_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__iterator.html">turi::sframe_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html">turi::sframe_reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader__buffer.html">turi::sframe_reader_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__rows.html">turi::sframe_rows</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga25f23d791bd1d986c61cd39748ff2a09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga25f23d791bd1d986c61cd39748ff2a09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sarray__block__iterator.html">sarray_block_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga25f23d791bd1d986c61cd39748ff2a09">turi::make_sarray_block_iterator</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt; &gt; &amp;data)</td></tr>
<tr class="separator:ga25f23d791bd1d986c61cd39748ff2a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf172c11fbe7e659f98d883fdc0385c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaf172c11fbe7e659f98d883fdc0385c33">turi::read_sframe_index_file</a> (std::string index_file)</td></tr>
<tr class="separator:gaf172c11fbe7e659f98d883fdc0385c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c729f5d7f2ff91f18a07fb3a2461f21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga0c729f5d7f2ff91f18a07fb3a2461f21">turi::write_sframe_index_file</a> (std::string index_file, const <a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a> &amp;info)</td></tr>
<tr class="separator:ga0c729f5d7f2ff91f18a07fb3a2461f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e670aefa314e5d8c485de2c9e898a4b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga0e670aefa314e5d8c485de2c9e898a4b">turi::sframe_row_to_csv</a> (const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;row, char *buf, size_t buflen)</td></tr>
<tr class="separator:ga0e670aefa314e5d8c485de2c9e898a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f05872e737224f8a66cfb9c12dff5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaf4f05872e737224f8a66cfb9c12dff5b">turi::sframe_row_to_json</a> (const std::vector&lt; std::string &gt; &amp;column_names, const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;column_values, JSONNode &amp;node)</td></tr>
<tr class="separator:gaf4f05872e737224f8a66cfb9c12dff5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a3099662541190a08f5960a6758b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga83a3099662541190a08f5960a6758b01">turi::sframe_save_naive</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;sf, std::string index_file)</td></tr>
<tr class="separator:ga83a3099662541190a08f5960a6758b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6169fd1854357f44ad1495dd02042a6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga6169fd1854357f44ad1495dd02042a6e">turi::sframe_save_blockwise</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;sf, std::string index_file)</td></tr>
<tr class="separator:ga6169fd1854357f44ad1495dd02042a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c67fe18486ede18477e1c2edf4c9b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga3c67fe18486ede18477e1c2edf4c9b6d">turi::sframe_save</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;sf, std::string index_file)</td></tr>
<tr class="separator:ga3c67fe18486ede18477e1c2edf4c9b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab39ab3d51730ade54ff39d465cd088a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gab39ab3d51730ade54ff39d465cd088a9">turi::sframe_save_weak_reference</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;sf, std::string index_file)</td></tr>
<tr class="separator:gab39ab3d51730ade54ff39d465cd088a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6274ff53e5e6cdee836ea44e9524003a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga6274ff53e5e6cdee836ea44e9524003a">turi::shuffle</a> (<a class="el" href="classturi_1_1sframe.html">sframe</a> sframe_in, size_t n, std::function&lt; size_t(const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;)&gt; hash_fn, std::function&lt; void(const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;, size_t)&gt; emit_call_back=std::function&lt; void(const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;, size_t)&gt;())</td></tr>
<tr class="separator:ga6274ff53e5e6cdee836ea44e9524003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ddbb41a214072f11fb354542c3fea81"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga7ddbb41a214072f11fb354542c3fea81">turi::sarray_reader&lt; T &gt;::read_rows</a> (size_t row_start, size_t row_end, <a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a> &amp;out_obj)</td></tr>
<tr class="separator:ga7ddbb41a214072f11fb354542c3fea81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3ffefdd48a3de34aae904c2ce91ff3"><td class="memItemLeft" align="right" valign="top">value_type &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaba3ffefdd48a3de34aae904c2ce91ff3">turi::sarray_reader_buffer&lt; T &gt;::next</a> ()</td></tr>
<tr class="memdesc:gaba3ffefdd48a3de34aae904c2ce91ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next element in the reader.  <a href="#gaba3ffefdd48a3de34aae904c2ce91ff3">More...</a><br /></td></tr>
<tr class="separator:gaba3ffefdd48a3de34aae904c2ce91ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0a14c814ad647a718e7ff20ef2999653"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga0a14c814ad647a718e7ff20ef2999653">turi::SFRAME_DEFAULT_NUM_SEGMENTS</a></td></tr>
<tr class="separator:ga0a14c814ad647a718e7ff20ef2999653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga147c13dd9ac3f4bb564fcacaea1a62be"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga147c13dd9ac3f4bb564fcacaea1a62be">turi::DEFAULT_SARRAY_READER_BUFFER_SIZE</a></td></tr>
<tr class="separator:ga147c13dd9ac3f4bb564fcacaea1a62be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4060e1d00eabb1bf74af3ecaef1751e"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gab4060e1d00eabb1bf74af3ecaef1751e">turi::SARRAY_FROM_FILE_BATCH_SIZE</a></td></tr>
<tr class="separator:gab4060e1d00eabb1bf74af3ecaef1751e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafbbdb0b7e14990e3abf78a1b0ae97bb"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaafbbdb0b7e14990e3abf78a1b0ae97bb">turi::MIN_SEGMENT_LENGTH</a></td></tr>
<tr class="separator:gaafbbdb0b7e14990e3abf78a1b0ae97bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf080605fa1c42e579713cada9700010d"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaf080605fa1c42e579713cada9700010d">turi::SFRAME_WRITER_BUFFER_HARD_LIMIT</a></td></tr>
<tr class="separator:gaf080605fa1c42e579713cada9700010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d679053bcafb2d07b4bd63fc78ea174"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga5d679053bcafb2d07b4bd63fc78ea174">turi::SFRAME_FILE_HANDLE_POOL_SIZE</a></td></tr>
<tr class="separator:ga5d679053bcafb2d07b4bd63fc78ea174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257d1eac7da7cc34d1b09b4ad4a449c7"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga257d1eac7da7cc34d1b09b4ad4a449c7">turi::SFRAME_BLOCK_MANAGER_BLOCK_BUFFER_COUNT</a></td></tr>
<tr class="separator:ga257d1eac7da7cc34d1b09b4ad4a449c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b7d344bc4cb3d49e53eb022da16599"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga24b7d344bc4cb3d49e53eb022da16599">turi::COMPRESSION_DISABLE_THRESHOLD</a></td></tr>
<tr class="separator:ga24b7d344bc4cb3d49e53eb022da16599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga113eafeb25d60f776d0c163bab66fc75"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga113eafeb25d60f776d0c163bab66fc75">turi::SFRAME_DEFAULT_BLOCK_SIZE</a></td></tr>
<tr class="separator:ga113eafeb25d60f776d0c163bab66fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71cf727dd3ad628263a73b11c6ad6528"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga71cf727dd3ad628263a73b11c6ad6528">turi::SARRAY_WRITER_INITAL_ELEMENTS_PER_BLOCK</a></td></tr>
<tr class="separator:ga71cf727dd3ad628263a73b11c6ad6528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7281e1bb0446ea33004e78d51ea8c6a7"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga7281e1bb0446ea33004e78d51ea8c6a7">turi::SARRAY_WRITER_MIN_ELEMENTS_PER_BLOCK</a></td></tr>
<tr class="separator:ga7281e1bb0446ea33004e78d51ea8c6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2819cfa91c11a627de6d70fd495e0c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga4c2819cfa91c11a627de6d70fd495e0c">turi::SFRAME_WRITER_MAX_BUFFERED_CELLS_PER_BLOCK</a></td></tr>
<tr class="separator:ga4c2819cfa91c11a627de6d70fd495e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga729ab9b4f8306e0ef9680da74c255edb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga729ab9b4f8306e0ef9680da74c255edb">turi::SFRAME_WRITER_MAX_BUFFERED_CELLS</a></td></tr>
<tr class="separator:ga729ab9b4f8306e0ef9680da74c255edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11bc6cff209078df4dd9481be5a83733"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga11bc6cff209078df4dd9481be5a83733">turi::SFRAME_MAX_BLOCKS_IN_CACHE</a></td></tr>
<tr class="separator:ga11bc6cff209078df4dd9481be5a83733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdaf1bdee34727191c837f382bd50e1e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gacdaf1bdee34727191c837f382bd50e1e">turi::SFRAME_CSV_PARSER_READ_SIZE</a></td></tr>
<tr class="separator:gacdaf1bdee34727191c837f382bd50e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff6a4d5002d4a34ebd125418f019ef9f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaff6a4d5002d4a34ebd125418f019ef9f">turi::SFRAME_GROUPBY_BUFFER_NUM_ROWS</a></td></tr>
<tr class="separator:gaff6a4d5002d4a34ebd125418f019ef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5db85f6ab9cbc4112c4c5297bd3d32"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaac5db85f6ab9cbc4112c4c5297bd3d32">turi::SFRAME_SHUFFLE_BUCKET_SIZE</a></td></tr>
<tr class="separator:gaac5db85f6ab9cbc4112c4c5297bd3d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072fdea3589d0e65e0f0c71380864190"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga072fdea3589d0e65e0f0c71380864190">turi::SFRAME_JOIN_BUFFER_NUM_CELLS</a></td></tr>
<tr class="separator:ga072fdea3589d0e65e0f0c71380864190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8df491acb63b1cf8e7f8ab0d719eda8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gad8df491acb63b1cf8e7f8ab0d719eda8">turi::SFRAME_IO_READ_LOCK</a></td></tr>
<tr class="separator:gad8df491acb63b1cf8e7f8ab0d719eda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62082f167c51467e2e6842214d89070a"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga62082f167c51467e2e6842214d89070a">turi::SFRAME_IO_LOCK_FILE_SIZE_THRESHOLD</a></td></tr>
<tr class="separator:ga62082f167c51467e2e6842214d89070a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae18272fca6572c6d7515da8e8470e68a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gae18272fca6572c6d7515da8e8470e68a">turi::SFRAME_SORT_PIVOT_ESTIMATION_SAMPLE_SIZE</a></td></tr>
<tr class="separator:gae18272fca6572c6d7515da8e8470e68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83377e8db5ff62da684b96411aaebc08"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga83377e8db5ff62da684b96411aaebc08">turi::SFRAME_SORT_MAX_SEGMENTS</a></td></tr>
<tr class="separator:ga83377e8db5ff62da684b96411aaebc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be7965a1407dd92f588ccfc23a15ade"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga2be7965a1407dd92f588ccfc23a15ade">turi::SFRAME_COMPACTION_THRESHOLD</a></td></tr>
<tr class="separator:ga2be7965a1407dd92f588ccfc23a15ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada49853579a049f753b1e39ce1669315"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gada49853579a049f753b1e39ce1669315">turi::FAST_COMPACT_BLOCKS_IN_SMALL_SEGMENT</a></td></tr>
<tr class="separator:gada49853579a049f753b1e39ce1669315"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga25f23d791bd1d986c61cd39748ff2a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25f23d791bd1d986c61cd39748ff2a09">&#9670;&nbsp;</a></span>make_sarray_block_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sarray__block__iterator.html">sarray_block_iterator</a>&lt;T&gt; turi::make_sarray_block_iterator </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a sarray block iterator; convenience function using automatic template matching. </p>

<p class="definition">Definition at line <a class="el" href="sarray__iterators_8hpp_source.html#l00245">245</a> of file <a class="el" href="sarray__iterators_8hpp_source.html">sarray_iterators.hpp</a>.</p>

</div>
</div>
<a id="gaba3ffefdd48a3de34aae904c2ce91ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba3ffefdd48a3de34aae904c2ce91ff3">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp;&amp; <a class="el" href="classturi_1_1sarray__reader__buffer.html">turi::sarray_reader_buffer</a>&lt; T &gt;::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next element in the reader. </p>
<p>Return the next element in the chunk. </p>

<p class="definition">Definition at line <a class="el" href="sarray__reader__buffer_8hpp_source.html#l00146">146</a> of file <a class="el" href="sarray__reader__buffer_8hpp_source.html">sarray_reader_buffer.hpp</a>.</p>

</div>
</div>
<a id="ga7ddbb41a214072f11fb354542c3fea81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ddbb41a214072f11fb354542c3fea81">&#9670;&nbsp;</a></span>read_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classturi_1_1sarray__reader.html">turi::sarray_reader</a>&lt; T &gt;::read_rows </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a> &amp;&#160;</td>
          <td class="paramname"><em>out_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads a collection of rows, storing the result in out_obj. This function is independent of the open_segment/read_segment/close_segment functions, and can be called anytime. This function is also fully concurrent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_start</td><td>First row to read </td></tr>
    <tr><td class="paramname">row_end</td><td>one past the last row to read (i.e. EXCLUSIVE). row_end can be beyond the end of the array, in which case, fewer rows will be read. </td></tr>
    <tr><td class="paramname">out_obj</td><td>The output array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual number of rows read. Return (size_t)(-1) on failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not always efficient. Different file formats implementations will have different characteristics. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sarray__reader_8hpp_source.html#l00574">574</a> of file <a class="el" href="sarray__reader_8hpp_source.html">sarray_reader.hpp</a>.</p>

</div>
</div>
<a id="gaf172c11fbe7e659f98d883fdc0385c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf172c11fbe7e659f98d883fdc0385c33">&#9670;&nbsp;</a></span>read_sframe_index_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a> turi::read_sframe_index_file </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>index_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an sframe index file from disk. Raises an exception on failure.</p>
<p>This function will also automatically de-relativize the <a class="el" href="structturi_1_1sframe__index__file__information.html#a7198889333d7ee562bfd6fb774a1c98e">sframe_index_file_information::column_files</a> to get absolute paths </p>

</div>
</div>
<a id="ga0e670aefa314e5d8c485de2c9e898a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e670aefa314e5d8c485de2c9e898a4b">&#9670;&nbsp;</a></span>sframe_row_to_csv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::sframe_row_to_csv </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a csv string of a vector of flexible_types (as a row in the sframe) to buffer. Return the number of bytes written. </p>

</div>
</div>
<a id="gaf4f05872e737224f8a66cfb9c12dff5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4f05872e737224f8a66cfb9c12dff5b">&#9670;&nbsp;</a></span>sframe_row_to_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe_row_to_json </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">JSONNode &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write column_names and column_values (as a row in the sframe) to JSONNode. </p>

</div>
</div>
<a id="ga3c67fe18486ede18477e1c2edf4c9b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c67fe18486ede18477e1c2edf4c9b6d">&#9670;&nbsp;</a></span>sframe_save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe_save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>index_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Automatically determines the optimal strategy to save an sframe </p>

</div>
</div>
<a id="ga6169fd1854357f44ad1495dd02042a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6169fd1854357f44ad1495dd02042a6e">&#9670;&nbsp;</a></span>sframe_save_blockwise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe_save_blockwise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>index_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves an SFrame to another index file location using a more efficient method, block by block. </p>

</div>
</div>
<a id="ga83a3099662541190a08f5960a6758b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83a3099662541190a08f5960a6758b01">&#9670;&nbsp;</a></span>sframe_save_naive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe_save_naive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>index_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves an SFrame to another index file location using the most naive method: decode rows, and write them </p>

</div>
</div>
<a id="gab39ab3d51730ade54ff39d465cd088a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab39ab3d51730ade54ff39d465cd088a9">&#9670;&nbsp;</a></span>sframe_save_weak_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe_save_weak_reference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>index_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an "incomplete save" to a target index file location. All this ensures is that the sframe's contents are located on the same "file-system" (protocol) as the index file. Essentially the reference save is guaranteed to be valid for only as long as no other SFrame files are deleted.</p>
<p>Essentially this can be used to build a "delta" SFrame.</p><ul>
<li>You already have an SFrame on disk somewhere. Say... /data/a</li>
<li>You open it and add a column</li>
<li>Calling sframe_save_weak_reference to save it to /data/b</li>
<li>The saved SFrame in /data/b will include just the new column, but reference /data/a for the remaining columns.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sf</td><td>The SFrame to save </td></tr>
    <tr><td class="paramname">index_file</td><td>The output file location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6274ff53e5e6cdee836ea44e9524003a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6274ff53e5e6cdee836ea44e9524003a">&#9670;&nbsp;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classturi_1_1sframe.html">sframe</a>&gt; turi::shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td>
          <td class="paramname"><em>sframe_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; size_t(const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>hash_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;, size_t)&gt;&#160;</td>
          <td class="paramname"><em>emit_call_back</em> = <code>std::function&lt;&#160;void(const&#160;std::vector&lt;&#160;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;&gt;&#160;&amp;,&#160;size_t)&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shuffle the rows in one sframe into a collection of n sframes. Each output SFrame contains one segment.</p>
<div class="fragment"><div class="line">std::vector&lt;sframe&gt; ret(n);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; sf : ret) {</div><div class="line">  INIT_WITH_NAMES_COLUMNS_AND_ONE_SEG(sframe_in.column_names(), sframe_in.column_types());</div><div class="line">}</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; row : sframe_in) {</div><div class="line">  <span class="keywordtype">size_t</span> idx = hash_fn(row) % n;</div><div class="line">  add_row_to_sframe(ret[idx], row); <span class="comment">// the order of addition is not guaranteed.</span></div><div class="line">}</div></div><!-- fragment --><p>The result sframes have the same column names and types (including empty sframes). A result sframe can have 0 rows if non of the rows in the input sframe is hashed to it. (If n is greater than the size of input sframe, there will be at (n - sframe_in.size()) empty sframes in the return vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of output sframe. </td></tr>
    <tr><td class="paramname">hash_fn</td><td>the hash function for each row in the input sframe.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of n sframes. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_2build_2src_2core_2storage_2sframe_interface_2unity_sframe_8hpp-example.html#a4">/build/src/core/storage/sframe_interface/unity_sframe.hpp</a>.</dd>
</dl>
</div>
</div>
<a id="ga0c729f5d7f2ff91f18a07fb3a2461f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c729f5d7f2ff91f18a07fb3a2461f21">&#9670;&nbsp;</a></span>write_sframe_index_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::write_sframe_index_file </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>index_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes an sframe index file to disk. Raises an exception on failure.</p>
<p>This function will also automatically relativize the <a class="el" href="structturi_1_1sframe__index__file__information.html#a7198889333d7ee562bfd6fb774a1c98e">sframe_index_file_information::column_files</a> to get relative paths when writing to disk </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga24b7d344bc4cb3d49e53eb022da16599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24b7d344bc4cb3d49e53eb022da16599">&#9670;&nbsp;</a></span>COMPRESSION_DISABLE_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float turi::COMPRESSION_DISABLE_THRESHOLD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the post compression size is less than this fraction of the pre-compression size. compression is disabled. </p>

</div>
</div>
<a id="ga147c13dd9ac3f4bb564fcacaea1a62be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga147c13dd9ac3f4bb564fcacaea1a62be">&#9670;&nbsp;</a></span>DEFAULT_SARRAY_READER_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t turi::DEFAULT_SARRAY_READER_BUFFER_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default parsed buffer size used in the <a class="el" href="classturi_1_1sarray__reader__buffer.html">sarray_reader_buffer</a>. The iterators returned by <a class="el" href="classturi_1_1sarray__reader.html#afc04529106917fa5d3f6ba43356e9717">sarray_reader::begin()</a> , <a class="el" href="classturi_1_1sarray__reader.html#a66a87ee67862f28e20de555f6338566c">sarray_reader::end()</a>, <a class="el" href="classturi_1_1sframe__reader.html#adc103218ae977ee3fa3b46d47700d613">sframe_reader::begin()</a> and <a class="el" href="classturi_1_1sframe__reader.html#a5f729f51083abcef27827d57851385a7">sframe_reader::end()</a> also use this as the default parsed buffer size. </p>

</div>
</div>
<a id="gada49853579a049f753b1e39ce1669315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada49853579a049f753b1e39ce1669315">&#9670;&nbsp;</a></span>FAST_COMPACT_BLOCKS_IN_SMALL_SEGMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::FAST_COMPACT_BLOCKS_IN_SMALL_SEGMENT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a segment contains less than this number of blocks, it is considered a small segment. </p>

</div>
</div>
<a id="gaafbbdb0b7e14990e3abf78a1b0ae97bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafbbdb0b7e14990e3abf78a1b0ae97bb">&#9670;&nbsp;</a></span>MIN_SEGMENT_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t turi::MIN_SEGMENT_LENGTH</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The minimum number of entries we want inside a segment (only used by join right now). </p>

</div>
</div>
<a id="gab4060e1d00eabb1bf74af3ecaef1751e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4060e1d00eabb1bf74af3ecaef1751e">&#9670;&nbsp;</a></span>SARRAY_FROM_FILE_BATCH_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t turi::SARRAY_FROM_FILE_BATCH_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of rows read from a file in a batch when loading a file into an SArray. (a single column. NOT an sframe). </p>

</div>
</div>
<a id="ga71cf727dd3ad628263a73b11c6ad6528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71cf727dd3ad628263a73b11c6ad6528">&#9670;&nbsp;</a></span>SARRAY_WRITER_INITAL_ELEMENTS_PER_BLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t turi::SARRAY_WRITER_INITAL_ELEMENTS_PER_BLOCK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The initial number of elements in a block. This is used in <a class="el" href="classturi_1_1sarray__group__format__writer__v2.html">sarray_group_format_writer_v2</a>. This is the number of rows the writer will buffer at the start before issuing the first block write. After which, it will use the actual number of bytes written to try to estimate the number of rows to buffer before the next write. (essentially SFRAME_DEFAULT_BLOCK_SIZE / (average bytes per element)). </p>

</div>
</div>
<a id="ga7281e1bb0446ea33004e78d51ea8c6a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7281e1bb0446ea33004e78d51ea8c6a7">&#9670;&nbsp;</a></span>SARRAY_WRITER_MIN_ELEMENTS_PER_BLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t turi::SARRAY_WRITER_MIN_ELEMENTS_PER_BLOCK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The minimum number of elements per block. Used in <a class="el" href="classturi_1_1sarray__group__format__writer__v2.html">sarray_group_format_writer_v2</a>. It will never write less than this number of elements into a block. </p>

</div>
</div>
<a id="ga257d1eac7da7cc34d1b09b4ad4a449c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga257d1eac7da7cc34d1b09b4ad4a449c7">&#9670;&nbsp;</a></span>SFRAME_BLOCK_MANAGER_BLOCK_BUFFER_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t turi::SFRAME_BLOCK_MANAGER_BLOCK_BUFFER_COUNT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default number of block buffers in the v0 block manager pool. </p>

</div>
</div>
<a id="ga2be7965a1407dd92f588ccfc23a15ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2be7965a1407dd92f588ccfc23a15ade">&#9670;&nbsp;</a></span>SFRAME_COMPACTION_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_COMPACTION_THRESHOLD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of segments an SFrame can have after which compaction will be attempted </p>

</div>
</div>
<a id="gacdaf1bdee34727191c837f382bd50e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdaf1bdee34727191c837f382bd50e1e">&#9670;&nbsp;</a></span>SFRAME_CSV_PARSER_READ_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_CSV_PARSER_READ_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The amount to read from the file each time by the CSV parser. (this block is then parsed in parallel by a collection of threads) </p>

</div>
</div>
<a id="ga113eafeb25d60f776d0c163bab66fc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga113eafeb25d60f776d0c163bab66fc75">&#9670;&nbsp;</a></span>SFRAME_DEFAULT_BLOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_DEFAULT_BLOCK_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default size of each block in the file. This is not strict. the <a class="el" href="classturi_1_1sarray__group__format__writer__v2.html">sarray_group_format_writer_v2</a> will try to target blocks to be of this size, but the actual sizes may vary. </p>

</div>
</div>
<a id="ga0a14c814ad647a718e7ff20ef2999653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a14c814ad647a718e7ff20ef2999653">&#9670;&nbsp;</a></span>SFRAME_DEFAULT_NUM_SEGMENTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_DEFAULT_NUM_SEGMENTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default number of segments created when an SFrame/SArray is opened for write. (i.e. <a class="el" href="classturi_1_1sarray.html#a8cd438df8c7117125b00cf8d43e17a2d">sarray::open_for_write</a> and <a class="el" href="classturi_1_1sframe.html#af6fdd0cca31cb1c4b44e60b554db28ad">sframe::open_for_write</a>). This is default is used in numerous places. For instance the default number of output segments from the sframe_csv_parser, and the dataframe to sframe converter. </p>

</div>
</div>
<a id="ga5d679053bcafb2d07b4bd63fc78ea174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d679053bcafb2d07b4bd63fc78ea174">&#9670;&nbsp;</a></span>SFRAME_FILE_HANDLE_POOL_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_FILE_HANDLE_POOL_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default number of handles in the v2 block manager pool. </p>

</div>
</div>
<a id="gaff6a4d5002d4a34ebd125418f019ef9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff6a4d5002d4a34ebd125418f019ef9f">&#9670;&nbsp;</a></span>SFRAME_GROUPBY_BUFFER_NUM_ROWS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_GROUPBY_BUFFER_NUM_ROWS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of elements to accumulate in a groupby batch until it has to flush. </p>

</div>
</div>
<a id="ga62082f167c51467e2e6842214d89070a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62082f167c51467e2e6842214d89070a">&#9670;&nbsp;</a></span>SFRAME_IO_LOCK_FILE_SIZE_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t turi::SFRAME_IO_LOCK_FILE_SIZE_THRESHOLD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If SFRAME_IO_READ_LOCK is set, then the IO LOCK is only used when the file size is greater than this value. </p>

</div>
</div>
<a id="gad8df491acb63b1cf8e7f8ab0d719eda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8df491acb63b1cf8e7f8ab0d719eda8">&#9670;&nbsp;</a></span>SFRAME_IO_READ_LOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_IO_READ_LOCK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether locks are used when reading from SFrames on local storage. Good for spinning disks, bad for SSDs. </p>

</div>
</div>
<a id="ga072fdea3589d0e65e0f0c71380864190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga072fdea3589d0e65e0f0c71380864190">&#9670;&nbsp;</a></span>SFRAME_JOIN_BUFFER_NUM_CELLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_JOIN_BUFFER_NUM_CELLS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of bytes that a join algorithm is allowed to use during execution. </p>

</div>
</div>
<a id="ga11bc6cff209078df4dd9481be5a83733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11bc6cff209078df4dd9481be5a83733">&#9670;&nbsp;</a></span>SFRAME_MAX_BLOCKS_IN_CACHE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_MAX_BLOCKS_IN_CACHE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of data blocks that can be maintained in a reader's decoded cache </p>

</div>
</div>
<a id="gaac5db85f6ab9cbc4112c4c5297bd3d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac5db85f6ab9cbc4112c4c5297bd3d32">&#9670;&nbsp;</a></span>SFRAME_SHUFFLE_BUCKET_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_SHUFFLE_BUCKET_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of elements per bucket when performing a shuffle operation. </p>

</div>
</div>
<a id="ga83377e8db5ff62da684b96411aaebc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83377e8db5ff62da684b96411aaebc08">&#9670;&nbsp;</a></span>SFRAME_SORT_MAX_SEGMENTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_SORT_MAX_SEGMENTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of segments we will try to partition the input SFrame into for external sort. Number kept low initially to be sensitive of open file handle limits. </p>

</div>
</div>
<a id="gae18272fca6572c6d7515da8e8470e68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae18272fca6572c6d7515da8e8470e68a">&#9670;&nbsp;</a></span>SFRAME_SORT_PIVOT_ESTIMATION_SAMPLE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_SORT_PIVOT_ESTIMATION_SAMPLE_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of samples used to estimate the pivot positions to partition the data for sorting. </p>

</div>
</div>
<a id="gaf080605fa1c42e579713cada9700010d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf080605fa1c42e579713cada9700010d">&#9670;&nbsp;</a></span>SFRAME_WRITER_BUFFER_HARD_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t turi::SFRAME_WRITER_BUFFER_HARD_LIMIT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The number of rows to buffer before forcing to flush the buffer to disk. Used in shuffle operation. </p>

</div>
</div>
<a id="ga729ab9b4f8306e0ef9680da74c255edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga729ab9b4f8306e0ef9680da74c255edb">&#9670;&nbsp;</a></span>SFRAME_WRITER_MAX_BUFFERED_CELLS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_WRITER_MAX_BUFFERED_CELLS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of elements cached across all columns of the sarray_group writer. Once this is exceeded, flushes will happen even if the block size is still too small. This is maintained approximately. Essentially, this has the effect of setting SFRAME_WRITER_MAX_BUFFERED_CELLS_PER_BLOCK to SFRAME_WRITER_MAX_BUFFERED_CELLS / (#columns * #segments) </p>

</div>
</div>
<a id="ga4c2819cfa91c11a627de6d70fd495e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c2819cfa91c11a627de6d70fd495e0c">&#9670;&nbsp;</a></span>SFRAME_WRITER_MAX_BUFFERED_CELLS_PER_BLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::SFRAME_WRITER_MAX_BUFFERED_CELLS_PER_BLOCK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum number of elements per block. Used in <a class="el" href="classturi_1_1sarray__group__format__writer__v2.html">sarray_group_format_writer_v2</a>. It will never write more than this number of elements into a block. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
