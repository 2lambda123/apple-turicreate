<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Algorithms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms<div class="ingroups"><a class="el" href="group__sframe__query__engine.html">SFrame Logical Query Engine</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1query__eval_1_1less__than__full__function.html">turi::query_eval::less_than_full_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1query__eval_1_1less__than__partial__function.html">turi::query_eval::less_than_partial_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga754996c00d639a002403bfffe69f06a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithms.html#ga754996c00d639a002403bfffe69f06a6">turi::query_eval::permute_sframe</a> (<a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;values_sframe, std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; forward_map)</td></tr>
<tr class="separator:ga754996c00d639a002403bfffe69f06a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ec1516f214a6774c08743e9c9116133"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithms.html#ga7ec1516f214a6774c08743e9c9116133">turi::query_eval::ec_sort</a> (std::shared_ptr&lt; <a class="el" href="structturi_1_1query__eval_1_1planner__node.html">planner_node</a> &gt; sframe_planner_node, const std::vector&lt; std::string &gt; column_names, const std::vector&lt; size_t &gt; &amp;key_column_indices, const std::vector&lt; bool &gt; &amp;sort_orders)</td></tr>
<tr class="separator:ga7ec1516f214a6774c08743e9c9116133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be2c0cf706409ad52264ae255698e37"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithms.html#ga2be2c0cf706409ad52264ae255698e37">turi::query_eval::groupby_aggregate</a> (const std::shared_ptr&lt; <a class="el" href="structturi_1_1query__eval_1_1planner__node.html">planner_node</a> &gt; &amp;source, const std::vector&lt; std::string &gt; &amp;source_column_names, const std::vector&lt; std::string &gt; &amp;<a class="el" href="group__set__and__map.html#ga918b8235a3af13f02053fdf76c17ae83">keys</a>, const std::vector&lt; std::string &gt; &amp;output_column_names, const std::vector&lt; std::pair&lt; std::vector&lt; std::string &gt;, std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt;&gt;&gt; &amp;groups)</td></tr>
<tr class="separator:ga2be2c0cf706409ad52264ae255698e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5108f8e913f72a22cf8dedf9879e70"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithms.html#gabd5108f8e913f72a22cf8dedf9879e70">turi::query_eval::sort</a> (std::shared_ptr&lt; <a class="el" href="structturi_1_1query__eval_1_1planner__node.html">planner_node</a> &gt; sframe_planner_node, const std::vector&lt; std::string &gt; column_names, const std::vector&lt; size_t &gt; &amp;sort_column_indices, const std::vector&lt; bool &gt; &amp;sort_orders)</td></tr>
<tr class="separator:gabd5108f8e913f72a22cf8dedf9879e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21ef897cb5dd4c200c3852dca3c4ab3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithms.html#gaa21ef897cb5dd4c200c3852dca3c4ab3">turi::query_eval::sort_and_merge</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; std::pair&lt; <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a>, std::string &gt;&gt;&gt; &amp;partition_array, const std::vector&lt; bool &gt; &amp;partition_sorted, const std::vector&lt; size_t &gt; &amp;partition_sizes, const std::vector&lt; bool &gt; &amp;sort_orders, const std::vector&lt; size_t &gt; &amp;permute_order, const std::vector&lt; std::string &gt; &amp;column_names, const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;column_types)</td></tr>
<tr class="separator:gaa21ef897cb5dd4c200c3852dca3c4ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Sort, Groupby algorithms that take a lazy input. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7ec1516f214a6774c08743e9c9116133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ec1516f214a6774c08743e9c9116133">&#9670;&nbsp;</a></span>ec_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sframe.html">sframe</a>&gt; turi::query_eval::ec_sort </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structturi_1_1query__eval_1_1planner__node.html">planner_node</a> &gt;&#160;</td>
          <td class="paramname"><em>sframe_planner_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>key_column_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>sort_orders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External Memory Columnar Sort. See <a class="el" href="group__Algorithms.html#ga7ec1516f214a6774c08743e9c9116133">ec_sort</a> for details.</p>
<p>The current sort algorithm (in <a class="el" href="group__Algorithms.html#gabd5108f8e913f72a22cf8dedf9879e70">turi::query_eval::sort</a>) implementation has lasted us a while and it is time to think about something better.</p>
<h1>A brief overview of the old sort algorithm </h1>
<p>The old algorithm implemented in <a class="el" href="group__Algorithms.html#gabd5108f8e913f72a22cf8dedf9879e70">sort</a> essentially a bucket sort.</p>
<h2>Pivot generation </h2>
<ul>
<li>A fraction of random elements is selected on the key column filling a quantile sketch</li>
<li>The quantile sketch is used to select a set of K-1 pivots (hence K buckets)</li>
<li>Each bucket is associated with an output file</li>
</ul>
<h2>Scatter </h2>
<ul>
<li>The entire sframe is materialized to a stream which consumes the sframe row by row.</li>
<li>For each row, the key is compared to the pivots, and the row is written row-wise into the bucket.</li>
<li>This process can be done in parallel</li>
</ul>
<h2>Sort </h2>
<ul>
<li>Each bucket is loaded into memory and an in memory quicksort is performed.</li>
<li>This process can be done in parallel</li>
</ul>
<h2>Advantages </h2>
<ol type="1">
<li>Exactly 2x write amplification. Every tuple is only written exactly twice. (But see Issue 1)</li>
<li>Works with Lazy sframe sources</li>
</ol>
<h2>Issues </h2>
<ol type="1">
<li>Much more than 2x write amplification.Though the buckets are not that well compressed since they are done row-wise. So while every tuple is written exactly twice, the effective #bytes written can be <em>much much</em> larger.</li>
<li>Wide reads of SFrames are slow. If the SFrame to be sorted has a few hundred columns on disk, things break.</li>
<li>Memory limits are hard to control. Image columns or very big dictionaries / lists are problematic.</li>
</ol>
<h1>The Proposed algorithm </h1>
<p>Firstly, we assume that the sframe is read one value at a time, i.e. we get a stream of *(column_number, row_number, value)*. With the assumption that the data is at least, sequential within the column. I.e. if I just received *(c, r, v) : r &gt; 0*, Â  I must have already received *(c, r-1, v)*</p>
<p>The the algorithm proceeds as such:</p>
<h2>Forward Map Generation </h2>
<ul>
<li>A set of row numbers are added to the key columns, and the key columns are sorted. And then dropped. This gives the inverse map. (i.e. x[i] = j implies output row i is read from input row j)</li>
<li>Row numbers are added again, and its sorted again by the first set of row numbers. This gives the forward map (i.e. y[i] = j implies input row i is written to output row j)</li>
<li><p class="startli">(In SFrame pseudocode:</p>
<p class="startli">B = A[['key']].add_row_number('r1').sort('key') inverse_map = B['r1'] # we don't need this C = B.add_row_number('r2').sort('r1') foward_map = C['r2']</p>
</li>
</ul>
<p>The forward map is held as an SArray of integers.</p>
<h2>Pivot Generation </h2>
<ul>
<li>Now we have a forward map, we can get exact buckets. Of N/K length. I.e. row r is written to bucket <code>Floor(K \ forward_map(r) / N)</code></li>
</ul>
<h2>Scatter </h2>
<ul>
<li>For each (c,r,v) in data: Write (c,v) to bucket <code>Floor(K \ forward_map(r) / N)</code></li>
</ul>
<p>This requires a little modification to the sframe writer to allow single columns writes (really it already does this internally. It transposes written rows to turn it to columns). This exploits the property that if (c,r-1,v) must be read before (c,r,v). Hence the rows are written in the correct order. (though how to do this in parallel is a question.)</p>
<p>We will also have to generate a per-bucket forward_map using the same scatter procedure.</p>
<p>This requires a little bit of intelligence in the caching of the forward map SArray. If the forward map is small, we can keep it all in memory. If it is large, need a bit more work. Some intelligence needed in this datastructure.</p>
<h2>Sort </h2>
<pre class="fragment">For each Bucket b:
    Allocate Output vector of (Length of bucket) * (#columns)
    Let S be the starting index of bucket b (i.e. b*N/k)
    Let T be the ending index of bucket b (i.e. (b+1)*N/k)
    Load forward_map[S:T] into memory
    For each (c,r,v) in bucket b
        Output[per_bucket_forward_map(r) - S][c] = v
    Dump Output to an SFrame
</pre><h2>Advantages </h2>
<ol type="1">
<li>Only sequential sweeps on the input SFrames, block-wise.</li>
<li>Does not matter if there are a large number of columns.</li>
<li>Memory limits can be easier to control. a. Scatter has little memory requirements (apart from the write buffer stage). b. The forward map is all integers. c. The Sort stage can happen a few columns at a time.</li>
</ol>
<h2>Issues </h2>
<ol type="1">
<li>The block-wise reads do not work well on lazy SFrames. In theory this is possible, since the algorithm is technically more general and will work even if the (c,r,v) tuples are generated one row at a time (i.e. wide reads). However, executing this on a lazy Sframe, means that we <em>actually</em> perform the wide reads which are slow. (Example: if I have a really wide SFrame on disk. And I perform the read through the query execution pipeline, the query execution pipeline performs the wide read and that is slow. Whereas if I go to the disk SFrame directly, I can completely avoid the wide read).</li>
<li>Due to (1) it is better to materialize the SFrame and operate on the physical SFrame. Hence we get up to 3x write amplification. However, every intermediate bucket is fully compressed.</li>
</ol>
<h2>Optimizations And implementation Details </h2>
<ul>
<li>One key aspect is the construction of the forward map. We still need to have a second sort algorithm to make that work. We could use our current sorting algo, or try to make something simpler since the 'value' is always a single integer. As a start, I would just use our current sort implementation. And look for something better in the future.</li>
<li>We really need almost random seeks on the forward map. I.e. it is mostly sequential due to the column ordering. Some intelligence is needed to decide how much of the forward map to hold in memory, and how much to keep on disk.</li>
<li>Particular excessively heavy columns (like super big dictionaries, lists, images) , we store the row number instead during the scatter phase. And we use seeks against the original input to transfer it straight from input to output. We could take a guess about the column data size and use the seek strategy if it is too large.</li>
<li>There are 2 optimizations possible.<ul>
<li>One is the above: we write row number into the bucket, and we go back to the original input SFrame for data. We can put a threshold size here of say ... 256 KB. about 100MBps * 2ms.</li>
<li>The second is optimization in the final sort of the bucket. We can perform seeks to fetch elements from the bucket. Unlike the above, we pay for an additional write + seek of the element, but it IS a smaller file.</li>
</ul>
</li>
<li>Minimize full decode of dictionary/list type. We should be able to read/write dict/list columns in the input SFrame as strings. (Annoyingly this is actually quite hard to achieve at the moment)</li>
</ul>
<h2>Notes on the current implementation </h2>
<ul>
<li>The current implementation uses the old sort algorithm for the backward map generation, and the forward map generation. A faster algorithm could be used for the forward map sort since it now very small. A dedicated sort around just sorting integers could be nice.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sframe_planner_node</td><td>The lazy sframe to be sorted </td></tr>
    <tr><td class="paramname">sort_column_names</td><td>The columns to be sorted </td></tr>
    <tr><td class="paramname">sort_orders</td><td>The order for each column to be sorted, true is ascending</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sorted sframe </dd></dl>

</div>
</div>
<a id="ga2be2c0cf706409ad52264ae255698e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2be2c0cf706409ad52264ae255698e37">&#9670;&nbsp;</a></span>groupby_aggregate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sframe.html">sframe</a>&gt; turi::query_eval::groupby_aggregate </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structturi_1_1query__eval_1_1planner__node.html">planner_node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>source_column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::vector&lt; std::string &gt;, std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Groupby aggregate algorithm that operates on lazy input.</p>
<p>Identical to <a class="el" href="group__groupby__aggregate.html#ga8c719d63eb3444a673e8899c33c8496e">turi::groupby_aggregate</a> but can take a lazy input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The lazy input node </td></tr>
    <tr><td class="paramname">source_column_names</td><td>The column names of the input source </td></tr>
    <tr><td class="paramname">keys</td><td>An array of column names to generate the group on </td></tr>
    <tr><td class="paramname">output_column_names</td><td>The output column names for each aggregate. This must be the same length as the 'groups' parameter. Output column names must be unique and must not share similar column names as keys. If there are any empty entries, their values will be automatically assigned. </td></tr>
    <tr><td class="paramname">groups</td><td>A collection of {column_names, group operator} pairs describing the aggregates to generate. You can have multiple aggregators for each set of columns. You do not need every column in the source to be represented. This must be the same length as the 'group_output_columns' parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_2build_2src_2core_2storage_2sframe_interface_2unity_sframe_8hpp-example.html#a4">/build/src/core/storage/sframe_interface/unity_sframe.hpp</a>.</dd>
</dl>
</div>
</div>
<a id="ga754996c00d639a002403bfffe69f06a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga754996c00d639a002403bfffe69f06a6">&#9670;&nbsp;</a></span>permute_sframe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a> turi::query_eval::permute_sframe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>values_sframe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>forward_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Permutes an sframe by a forward map. forward_map has the same length as the sframe and must be a permutation of all the integers [0, len-1].</p>
<p>The input sframe is then permuted so that sframe row i is written to row forward_map[i] of the returned sframe.</p>
<dl class="section note"><dt>Note</dt><dd>The forward_map is not checked that it is a valid permutation If the constraints is not met, either an exception will be thrown, or the result is ill-defined. </dd></dl>

</div>
</div>
<a id="gabd5108f8e913f72a22cf8dedf9879e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd5108f8e913f72a22cf8dedf9879e70">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sframe.html">sframe</a>&gt; turi::query_eval::sort </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structturi_1_1query__eval_1_1planner__node.html">planner_node</a> &gt;&#160;</td>
          <td class="paramname"><em>sframe_planner_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>sort_column_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>sort_orders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort given SFrame.</p>
<p>The algorithm is like the following:</p><ul>
<li>First do a quantile sketch over all sort columns and use the quantile sketch to figure out the partition keys that we will use to split the sframe rows into small chunks so that each chunk is realtively sorted. Each chunk is small enough so that we could sort in memory</li>
<li>Scatter partition the sframe according to above partition keys. The resulting value is persisted. Each partition is stored as one segment in a sarray.</li>
<li>The sorting resulting is then lazily materialized through le_sort operator</li>
</ul>
<p>There are a few optimizations along the way:</p><ul>
<li>if all sorting keys are the same, then no need to sort</li>
<li>if the sframe is small enough to fit into memory, then we simply do a in memory sort</li>
<li>if some partitions of the sframe have the same sorting key, then that partition will not be sorted</li>
</ul>
<p>Also see <a class="el" href="group__Algorithms.html#ga7ec1516f214a6774c08743e9c9116133">ec_sort</a> for another sort implementation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sframe_planner_node</td><td>The lazy sframe to be sorted </td></tr>
    <tr><td class="paramname">sort_column_names</td><td>The columns to be sorted </td></tr>
    <tr><td class="paramname">sort_orders</td><td>The order for each column to be sorted, true is ascending </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sorted sframe </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_2build_2src_2core_2storage_2sframe_interface_2unity_sframe_8hpp-example.html#a5">/build/src/core/storage/sframe_interface/unity_sframe.hpp</a>.</dd>
</dl>
</div>
</div>
<a id="gaa21ef897cb5dd4c200c3852dca3c4ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa21ef897cb5dd4c200c3852dca3c4ab3">&#9670;&nbsp;</a></span>sort_and_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sframe.html">sframe</a>&gt; turi::query_eval::sort_and_merge </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; std::pair&lt; <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a>, std::string &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>partition_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition_sorted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>partition_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>sort_orders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>permute_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The merge stage of <a class="el" href="group__Algorithms.html#gabd5108f8e913f72a22cf8dedf9879e70">sort</a>.</p>
<p>The input is a partially sorted(partitioned) sframe, represented by an sarray&lt;string&gt; with N segments. Each segment is a partitioned key range, and segments are ordered by the key orders.</p>
<p>Given the partially sorted sframe, this function will in parallel sort each partition, and concat the result into final sframe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition_array</td><td>the serialized input sframe, partially sorted </td></tr>
    <tr><td class="paramname">partition_sorted</td><td>flag whether the partition is already sorted </td></tr>
    <tr><td class="paramname">partition_sizes</td><td>the estimate size of each partition </td></tr>
    <tr><td class="paramname">sort_orders</td><td>sort order of the keys </td></tr>
    <tr><td class="paramname">permute_order</td><td>The output order of the keys. column {permute_order[i]} will be stored in column i of the final SFrame </td></tr>
    <tr><td class="paramname">column_names</td><td>column names of the final sframe </td></tr>
    <tr><td class="paramname">column_types</td><td>column types of the final sframe</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sorted sframe. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
