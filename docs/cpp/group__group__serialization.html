<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: Serialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__serialization.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Serialization</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__technical__details__serialization"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__technical__details__serialization.html">Technical Details: Serialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1dir__archive.html">turi::dir_archive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1iarchive.html">turi::iarchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The serialization input archive object which, provided with a reference to an istream, will read from the istream, providing deserialization capabilities.  <a href="classturi_1_1iarchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1iarchive__soft__fail.html">turi::iarchive_soft_fail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this archive is used to deserialize an object, and the object does not support serialization, failure will only occur at runtime. Otherwise equivalent to <a class="el" href="classturi_1_1iarchive.html" title="The serialization input archive object which, provided with a reference to an istream, will read from the istream, providing deserialization capabilities. ">turi::iarchive</a>.  <a href="classturi_1_1iarchive__soft__fail.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1IS__POD__TYPE.html">turi::IS_POD_TYPE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheriting from this type will force the serializer to treat the derived type as a POD type.  <a href="structturi_1_1IS__POD__TYPE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1gl__is__pod.html">turi::gl_is_pod&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if T is a POD type.  <a href="structturi_1_1gl__is__pod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1oarchive.html">turi::oarchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The serialization output archive object which, provided with a reference to an ostream, will write to the ostream, providing serialization capabilities.  <a href="classturi_1_1oarchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1oarchive__soft__fail.html">turi::oarchive_soft_fail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this archive is used to serialize an object, and the object does not support serialization, failure will only occur at runtime. Otherwise equivalent to <a class="el" href="classturi_1_1oarchive.html" title="The serialization output archive object which, provided with a reference to an ostream, will write to the ostream, providing serialization capabilities. ">turi::oarchive</a>.  <a href="classturi_1_1oarchive__soft__fail.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1unsupported__serialize.html">turi::unsupported_serialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritting from this class will prevent the serialization of the derived class. Used for debugging purposes.  <a href="structturi_1_1unsupported__serialize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa04ff6a2c8c9873467c864201cf24f02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#gaa04ff6a2c8c9873467c864201cf24f02">BEGIN_OUT_OF_PLACE_LOAD</a>(arc,  tname,  tval)</td></tr>
<tr class="memdesc:gaa04ff6a2c8c9873467c864201cf24f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to make it easy to define out-of-place loads.  <a href="#gaa04ff6a2c8c9873467c864201cf24f02">More...</a><br /></td></tr>
<tr class="separator:gaa04ff6a2c8c9873467c864201cf24f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga623af22fb4db85b09484dd7bfa280f76"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#ga623af22fb4db85b09484dd7bfa280f76">BEGIN_OUT_OF_PLACE_SAVE</a>(arc,  tname,  tval)</td></tr>
<tr class="memdesc:ga623af22fb4db85b09484dd7bfa280f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to make it easy to define out-of-place saves.  <a href="#ga623af22fb4db85b09484dd7bfa280f76">More...</a><br /></td></tr>
<tr class="separator:ga623af22fb4db85b09484dd7bfa280f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57de99194a197bf248868f9f8fe56932"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#ga57de99194a197bf248868f9f8fe56932">TURI_UNSERIALIZABLE</a>(tname)</td></tr>
<tr class="memdesc:ga57de99194a197bf248868f9f8fe56932"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro which disables the serialization of type so that it will fault at runtime.  <a href="#ga57de99194a197bf248868f9f8fe56932">More...</a><br /></td></tr>
<tr class="separator:ga57de99194a197bf248868f9f8fe56932"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga28d9fd43fcb1100a7727348c160ee618"><td class="memTemplParams" colspan="2">template&lt;typename OutArcType , typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga28d9fd43fcb1100a7727348c160ee618"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#ga28d9fd43fcb1100a7727348c160ee618">turi::serialize_iterator</a> (OutArcType &amp;oarc, RandomAccessIterator begin, RandomAccessIterator end)</td></tr>
<tr class="memdesc:ga28d9fd43fcb1100a7727348c160ee618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the contents between the iterators begin and end.  <a href="group__group__serialization.html#ga28d9fd43fcb1100a7727348c160ee618">More...</a><br /></td></tr>
<tr class="separator:ga28d9fd43fcb1100a7727348c160ee618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadddae6e8816fdec445adc5b3d1814a31"><td class="memTemplParams" colspan="2">template&lt;typename OutArcType , typename InputIterator &gt; </td></tr>
<tr class="memitem:gadddae6e8816fdec445adc5b3d1814a31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#gadddae6e8816fdec445adc5b3d1814a31">turi::serialize_iterator</a> (OutArcType &amp;oarc, InputIterator begin, InputIterator end, size_t vsize)</td></tr>
<tr class="memdesc:gadddae6e8816fdec445adc5b3d1814a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the contents between the iterators begin and end.  <a href="group__group__serialization.html#gadddae6e8816fdec445adc5b3d1814a31">More...</a><br /></td></tr>
<tr class="separator:gadddae6e8816fdec445adc5b3d1814a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02a0b56eec87ca656509579520c36b9c"><td class="memTemplParams" colspan="2">template&lt;typename InArcType , typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga02a0b56eec87ca656509579520c36b9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#ga02a0b56eec87ca656509579520c36b9c">turi::deserialize_iterator</a> (InArcType &amp;iarc, OutputIterator result)</td></tr>
<tr class="memdesc:ga02a0b56eec87ca656509579520c36b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accompanying function to <a class="el" href="group__group__serialization.html#ga28d9fd43fcb1100a7727348c160ee618" title="Serializes the contents between the iterators begin and end. ">serialize_iterator()</a> Reads elements from the stream and writes it to the output iterator.  <a href="group__group__serialization.html#ga02a0b56eec87ca656509579520c36b9c">More...</a><br /></td></tr>
<tr class="separator:ga02a0b56eec87ca656509579520c36b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ff5a70d5a9b9c65a94eb432c2b5ee33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8ff5a70d5a9b9c65a94eb432c2b5ee33"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#ga8ff5a70d5a9b9c65a94eb432c2b5ee33">turi::serialize_to_string</a> (const T &amp;t)</td></tr>
<tr class="memdesc:ga8ff5a70d5a9b9c65a94eb432c2b5ee33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a object to a string.  <a href="group__group__serialization.html#ga8ff5a70d5a9b9c65a94eb432c2b5ee33">More...</a><br /></td></tr>
<tr class="separator:ga8ff5a70d5a9b9c65a94eb432c2b5ee33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa7b3064bbe1c7b3cd195d1063760aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadfa7b3064bbe1c7b3cd195d1063760aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#gadfa7b3064bbe1c7b3cd195d1063760aa">turi::deserialize_from_string</a> (const std::string &amp;s, T &amp;t)</td></tr>
<tr class="memdesc:gadfa7b3064bbe1c7b3cd195d1063760aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes a object from a string.  <a href="group__group__serialization.html#gadfa7b3064bbe1c7b3cd195d1063760aa">More...</a><br /></td></tr>
<tr class="separator:gadfa7b3064bbe1c7b3cd195d1063760aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>We have a custom serialization scheme which is designed for performance rather than compatibility. It does not perform type checking, It does not perform pointer tracking, and has only limited support across platforms. It has been tested, and should be compatible across x86 platforms.</p>
<p>For a summary of all serialization functionality see <a class="el" href="group__group__serialization.html">Serialization</a> For more technical details, see <a class="el" href="group__technical__details__serialization.html">Technical Details: Serialization</a> .</p>
<p>There are two serialization classes <a class="el" href="classturi_1_1oarchive.html">turi::oarchive</a> and <a class="el" href="classturi_1_1iarchive.html">turi::iarchive</a>. The former does output, while the latter does input. To include all serialization headers, #include &lt;turicreate/serialization/serialization_includes.hpp&gt;.</p>
<h1><a class="anchor" id="sec_basic_serialize"></a>
Basic serialize/deserialize</h1>
<p>To serialize data to disk, you just create an output archive, and associate it wiith an output stream.</p>
<p>For instance, to serialize to a file called "file.bin": </p><div class="fragment"><div class="line">std::ofstream fout(<span class="stringliteral">&quot;file.bin&quot;</span>, std::fstream::binary);</div><div class="line"><a class="code" href="classturi_1_1oarchive.html">turi::oarchive</a> oarc(fout);</div></div><!-- fragment --><p>The &lt;&lt; stream operators are then used to write data into the archive.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 10;</div><div class="line"><span class="keywordtype">double</span> j = 20;</div><div class="line">std::vector&lt;float&gt; v(10,1.0); <span class="comment">// create a vector of 10 &quot;1.0&quot; values</span></div><div class="line">oarc &lt;&lt; i &lt;&lt; j &lt;&lt; v;</div></div><!-- fragment --><p>To read back, you use the iarchive with an input stream, and read back the variables in the same order:</p>
<div class="fragment"><div class="line">std::ifstream fin(<span class="stringliteral">&quot;file.bin&quot;</span>, std::fstream::binary);</div><div class="line"><a class="code" href="classturi_1_1iarchive.html">turi::iarchive</a> iarc(fout);</div><div class="line"><span class="keywordtype">int</span> i;</div><div class="line"><span class="keywordtype">double</span> j;</div><div class="line">std::vector&lt;float&gt; v;</div><div class="line">iarc &gt;&gt; i &gt;&gt; j &gt;&gt; v;</div></div><!-- fragment --><h1><a class="anchor" id="sec_serializable"></a>
Serializable</h1>
<p>So what type of data is serializable?</p>
<h2><a class="anchor" id="sec_serializable_integers"></a>
Integer Types</h2>
<p>All integer datatypes are serializable. </p><ul>
<li><code> bool </code> </li>
<li><code> char </code> and <code> unsigned char </code> </li>
<li><code> short </code>and <code> unsigned short</code> </li>
<li><code> int </code>and <code> unsigned int</code> </li>
<li><code> long </code>and <code> unsigned long </code> </li>
<li><code> long long </code>and <code> unsigned long long</code></li>
</ul>
<p>Since all fixed width integer types from stdint (int16_t, int32_t, etc) are derived from these basic types, all fixed width integer types are also serializable.</p>
<ul>
<li><code> int16_t </code> and <code> uint16_t </code> </li>
<li><code> int32_t </code> and <code> uint32_t </code> </li>
<li><code> int64_t </code> and <code> uint64_t </code></li>
</ul>
<p>All integer types are saved in their raw binary form without any additional re-encoding. It is therefore important to deserialize with the same integer width as what was serialized.</p>
<p>The following code will fail in dramatic ways: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div><div class="line">oarc &lt;&lt; i; <span class="comment">// write some integer to a file</span></div><div class="line"></div><div class="line">...</div><div class="line"><span class="comment">// some time later we need to read back the integer.</span></div><div class="line">long j;</div><div class="line">iarc &gt;&gt; j; <span class="comment">// this will fail</span></div></div><!-- fragment --><h2><a class="anchor" id="sec_serializable_floats"></a>
Floating Point Types</h2>
<p>All floating point data types are serializable. </p><ul>
<li><code>float</code> </li>
<li><code>double</code> </li>
<li><code>long double</code> if your compiler supports quad precision.</li>
</ul>
<p>Similar to integer types, all floating types are saved in raw binary form without re-encoding. You must deserialize with the same floating point width as what was serialized. (i.e. if you serialize a double, you <b>must</b> deserialize a double.</p>
<h2><a class="anchor" id="sec_serializable_containers"></a>
Containers</h2>
<p>The following template containers are serializable as long as the contained types are all serializable. This can be recursively applied. </p><ul>
<li><code>std::vector</code> </li>
<li><code>std::list</code> </li>
<li><code>std::set</code> </li>
<li><code>std::map</code> </li>
<li><code>boost::unordered_set</code> </li>
<li><code>boost::unordered_map</code></li>
</ul>
<p>For instance, a <code>std::vector&lt;int&gt;</code> is serializable. A <code>std::list&lt;std::vector&lt;int&gt; &gt; </code> is therefore also serializable.</p>
<p>There is special handling for the std::vector&lt;T&gt; for performance in the event that T is a simple POD (Plain Old Data) data type. POD types are data types which occupy a contiguous region in memory. For instance, basic types (double, int, etc), or structs which contains only basic types. Such types can be copied or replicated using a simple mem-copy operation and can be greatly acceleration during serialization / deserialization. All basic data types are automatically POD types. We will discuss structs and other user types in the next section.</p>
<h1><a class="anchor" id="sec_serializable_user"></a>
User Structs and Classes</h1>
<p>To serialize a struct/class, all you need to do is to define a public load/save function. For instance:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TestClass{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">int</span> i, j;</div><div class="line">    std::vector&lt;int&gt; k;</div><div class="line">    <span class="keywordtype">void</span> save(<a class="code" href="classturi_1_1oarchive.html">turi::oarchive</a>&amp; oarc)<span class="keyword"> const </span>{</div><div class="line">      oarc &lt;&lt; i &lt;&lt; j &lt;&lt; k;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">void</span> load(<a class="code" href="classturi_1_1iarchive.html">turi::iarchive</a>&amp; iarc) {</div><div class="line">      iarc &gt;&gt; i &gt;&gt; j &gt;&gt; k;</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> The save() and load() function prototypes must match <b>exactly</b>. Other conditions are that the class must be Default Constructible: </p><div class="fragment"><div class="line"><span class="comment">// it must be possible to create a variable of TestClass type like this</span></div><div class="line">TestClass a;</div></div><!-- fragment --><p>And that the class must be Assignable: </p><div class="fragment"><div class="line">TestClass a, b;</div><div class="line"><span class="comment">// it must be possible to assign one variable of TestClass to another</span></div><div class="line">b = a;</div></div><!-- fragment --><p>After which, <code>TestClass</code> becomes serializable, and can be stored and read from an archive:</p>
<div class="fragment"><div class="line">TestClass t;</div><div class="line"><span class="comment">// set values to t</span></div><div class="line">oarc &lt;&lt; t;  <span class="comment">// write it to a file</span></div><div class="line"></div><div class="line">... some time afterwords...</div><div class="line"></div><div class="line">TestClass t2;</div><div class="line">iarc &gt;&gt; t2; <span class="comment">// read it to a file</span></div></div><!-- fragment --><p>Since <code>TestClass</code> is now serializable, containers of TestClass listed in <a class="el" href="group__group__serialization.html#sec_serializable_containers">Containers</a> are also serializable.</p>
<h1><a class="anchor" id="sec_serializable_pod"></a>
POD Serialization</h1>
<p>As mentioned in <a class="el" href="group__group__serialization.html#sec_serializable_containers">Containers</a>, POD data types occupy a contiguous region in memory and hence can be serialized and deserialized very quickly. Ideally, determination of whether a data type is POD or not should be handled by the compiler. However, this capability is only available in C++11 and not all compilers support it yet. We therefore implemented a simple workaround which will allow you to identify to the serializer that a class is POD, and avoid writing a save/load function.</p>
<p>We consider the following Coordinate struct. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Coordinate{</div><div class="line">  <span class="keywordtype">int</span> x, y, z;</div><div class="line">};</div></div><!-- fragment --><p>This struct can be defined to be a POD type using an accelerated serializer by simply inheriting from <a class="el" href="structturi_1_1IS__POD__TYPE.html" title="Inheriting from this type will force the serializer to treat the derived type as a POD type...">turi::IS_POD_TYPE</a></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Coordinate: <span class="keyword">public</span> <a class="code" href="structturi_1_1IS__POD__TYPE.html">turi::IS_POD_TYPE</a>{</div><div class="line">  <span class="keywordtype">int</span> x, y, z;</div><div class="line">};</div></div><!-- fragment --><p>Now, Coordinate variables, or even vector&lt;Coordinate&gt; variables will serialize/deserialize faster. Also, you avoid writing a save() and load() function.</p>
<dl class="section note"><dt>Note</dt><dd>Currently POD detection is performed through the boost type traits library. When compilers implement std::is_pod (in C++11), POD detection will improve, increasing the scope of types which can be serialized quickly and automatically. A minor concern is that the scope of POD types is still slightly too large, since technically pointer types are POD, and those cannot not be serialized automatically.</dd></dl>
<h1><a class="anchor" id="sec_serializable_out_of_place"></a>
Out of Place Serialization</h1>
<p>In some situations, you may find that you need to make a data type serializable, but the data type is implemented by someone else, in a different library, making it impossible to extend and write a member save() and load() function as described in <a class="el" href="group__group__serialization.html#sec_serializable_user">User Structs and Classes</a>.</p>
<p>In this situation, it is necessary to implement an "Out of place" serializer. This is unfortunately somewhat more complicated.</p>
<p>For instance, if there is an external type implemented by some other library called Matrix which I would like to make serializable. The following code will have to be written in the <b>global namespace</b></p>
<div class="fragment"><div class="line"><a class="code" href="group__group__serialization.html#ga623af22fb4db85b09484dd7bfa280f76">BEGIN_OUT_OF_PLACE_SAVE</a>(oarc, Matrix, mat)</div><div class="line">  <span class="comment">// write the &quot;mat&quot; variable which is of the type Matrix</span></div><div class="line">  <span class="comment">// into the output archive oarc</span></div><div class="line">END_OUT_OF_PLACE_SAVE()</div><div class="line"></div><div class="line"><a class="code" href="group__group__serialization.html#gaa04ff6a2c8c9873467c864201cf24f02">BEGIN_OUT_OF_PLACE_LOAD</a>(iarc, Matrix, mat)</div><div class="line">  <span class="comment">// read the &quot;mat&quot; variable which is of the type Matrix</span></div><div class="line">  <span class="comment">// from the input archive iarc</span></div><div class="line">END_OUT_OF_PLACE_LOAD()</div></div><!-- fragment --><p>To facilitate reading and writing of data from the archives, the output oarchive object provides an <a class="el" href="classturi_1_1oarchive.html#a82f4cc4ab96df84b06d0319121c26c17">turi::oarchive::write()</a> oarchive::write() function which directly writes a sequence of bytes to the stream. Similarly, the input iarchive object provides a <a class="el" href="classturi_1_1iarchive.html#a70a008d200ba9bd3a18b68cc036d49b7">turi::iarchive::read()</a> iarchive::read() function which directly reads a sequence of bytes from the stream.</p>
<p>For instance, if the Matrix type example above is defined in the following way:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Matrix {</div><div class="line">  <span class="keywordtype">int</span> width;  <span class="comment">// width of the matrix</span></div><div class="line">  <span class="keywordtype">int</span> height; <span class="comment">// height of the matrix</span></div><div class="line">  <span class="keywordtype">double</span>* data; <span class="comment">// an array containing all the values in the matrix</span></div><div class="line">  <span class="keywordtype">int</span> datalen; <span class="comment">// the number of elements in the &quot;data&quot; array.</span></div><div class="line">}</div></div><!-- fragment --><p>An "out of place" serializer could be implemented the following way: </p><div class="fragment"><div class="line"><a class="code" href="group__group__serialization.html#ga623af22fb4db85b09484dd7bfa280f76">BEGIN_OUT_OF_PLACE_SAVE</a>(oarc, Matrix, mat)</div><div class="line">  <span class="comment">// store the dimensions of the matrix</span></div><div class="line">  oarc &lt;&lt; mat.width &lt;&lt; mat.height;</div><div class="line"></div><div class="line">  <span class="comment">// store the length of the data array</span></div><div class="line">  oarc &lt;&lt; mat.datalen;</div><div class="line"></div><div class="line">  <span class="comment">// write the double array</span></div><div class="line">  oarc.write((<span class="keywordtype">char</span>*)(mat.data), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * mat.datalen);</div><div class="line">END_OUT_OF_PLACE_SAVE()</div><div class="line"></div><div class="line"><a class="code" href="group__group__serialization.html#gaa04ff6a2c8c9873467c864201cf24f02">BEGIN_OUT_OF_PLACE_LOAD</a>(iarc, Matrix, mat)</div><div class="line">  <span class="comment">// clear the matrix data if there is any</span></div><div class="line">  if (mat.data != NULL) delete [] mat.data;</div><div class="line"></div><div class="line">  <span class="comment">// read the dimensions of the matrix</span></div><div class="line">  iarc &gt;&gt; mat.width &gt;&gt; mat.height;</div><div class="line"></div><div class="line">  <span class="comment">// read the length of the data array</span></div><div class="line">  iarc &gt;&gt; mat.datalen;</div><div class="line"></div><div class="line">  <span class="comment">// allocate sufficient storage for the array</span></div><div class="line">  mat.data = new <span class="keywordtype">double</span>[mat.datalen];</div><div class="line"></div><div class="line">  <span class="comment">// read the double array</span></div><div class="line">  iarc.read((<span class="keywordtype">char</span>*)(mat.data), sizeof(<span class="keywordtype">double</span>) * mat.datalen);</div><div class="line"></div><div class="line">END_OUT_OF_PLACE_LOAD()</div></div><!-- fragment --> <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa04ff6a2c8c9873467c864201cf24f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa04ff6a2c8c9873467c864201cf24f02">&#9670;&nbsp;</a></span>BEGIN_OUT_OF_PLACE_LOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BEGIN_OUT_OF_PLACE_LOAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tval&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceturi.html">turi</a>{ <span class="keyword">namespace </span>archive_detail {        \</div><div class="line">  template &lt;typename InArcType&gt;                           \</div><div class="line">  struct deserialize_impl&lt;InArcType, tname, false&gt;{       \</div><div class="line">  static <span class="keywordtype">void</span> exec(InArcType&amp; arc, tname &amp; tval) {</div><div class="ttc" id="namespaceturi_html"><div class="ttname"><a href="namespaceturi.html">turi</a></div><div class="ttdoc">SKD. </div><div class="ttdef"><b>Definition:</b> <a href="capi__initialization_8hpp_source.html#l00011">capi_initialization.hpp:11</a></div></div>
</div><!-- fragment -->
<p>Macro to make it easy to define out-of-place loads. </p>
<p>In the event that it is impractical to implement a save() and load() function in the class one wnats to serialize, it is necessary to define an "out of save" save and load.</p>
<p>See <a class="el" href="group__group__serialization.html#sec_serializable_out_of_place">Out of Place Serialization</a> for an example</p>
<dl class="section note"><dt>Note</dt><dd>important! this must be defined in the global namespace! </dd></dl>

<p class="definition">Definition at line <a class="el" href="iarchive_8hpp_source.html#l00314">314</a> of file <a class="el" href="iarchive_8hpp_source.html">iarchive.hpp</a>.</p>

</div>
</div>
<a id="ga623af22fb4db85b09484dd7bfa280f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga623af22fb4db85b09484dd7bfa280f76">&#9670;&nbsp;</a></span>BEGIN_OUT_OF_PLACE_SAVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BEGIN_OUT_OF_PLACE_SAVE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tval&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceturi.html">turi</a>{ <span class="keyword">namespace </span>archive_detail {                        \</div><div class="line">  template &lt;typename OutArcType&gt; <span class="keyword">struct </span>serialize_impl&lt;OutArcType, tname, false&gt; { \</div><div class="line">  static <span class="keywordtype">void</span> exec(OutArcType&amp; arc, <span class="keyword">const</span> tname &amp; tval) {</div><div class="ttc" id="namespaceturi_html"><div class="ttname"><a href="namespaceturi.html">turi</a></div><div class="ttdoc">SKD. </div><div class="ttdef"><b>Definition:</b> <a href="capi__initialization_8hpp_source.html#l00011">capi_initialization.hpp:11</a></div></div>
</div><!-- fragment -->
<p>Macro to make it easy to define out-of-place saves. </p>
<p>In the event that it is impractical to implement a save() and load() function in the class one wnats to serialize, it is necessary to define an "out of save" save and load.</p>
<p>See <a class="el" href="group__group__serialization.html#sec_serializable_out_of_place">Out of Place Serialization</a> for an example</p>
<dl class="section note"><dt>Note</dt><dd>important! this must be defined in the global namespace! </dd></dl>

<p class="definition">Definition at line <a class="el" href="oarchive_8hpp_source.html#l00346">346</a> of file <a class="el" href="oarchive_8hpp_source.html">oarchive.hpp</a>.</p>

</div>
</div>
<a id="ga57de99194a197bf248868f9f8fe56932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57de99194a197bf248868f9f8fe56932">&#9670;&nbsp;</a></span>TURI_UNSERIALIZABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TURI_UNSERIALIZABLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tname</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__group__serialization.html#gaa04ff6a2c8c9873467c864201cf24f02">BEGIN_OUT_OF_PLACE_LOAD</a>(arc, tname, tval) \</div><div class="line">    ASSERT_MSG(<span class="keyword">false</span>, <span class="stringliteral">&quot;trying to deserialize an unserializable object&quot;</span>); \</div><div class="line">  END_OUT_OF_PLACE_LOAD()                                           <a class="code" href="group__group__serialization.html#ga623af22fb4db85b09484dd7bfa280f76">\</a></div><div class="line"><a class="code" href="group__group__serialization.html#ga623af22fb4db85b09484dd7bfa280f76">  \</a></div><div class="line"><a class="code" href="group__group__serialization.html#ga623af22fb4db85b09484dd7bfa280f76">  BEGIN_OUT_OF_PLACE_SAVE</a>(arc, tname, tval) \</div><div class="line">    ASSERT_MSG(<span class="keyword">false</span>, <span class="stringliteral">&quot;trying to serialize an unserializable object&quot;</span>); \</div><div class="line">  END_OUT_OF_PLACE_SAVE()                                           \</div><div class="ttc" id="group__group__serialization_html_gaa04ff6a2c8c9873467c864201cf24f02"><div class="ttname"><a href="group__group__serialization.html#gaa04ff6a2c8c9873467c864201cf24f02">BEGIN_OUT_OF_PLACE_LOAD</a></div><div class="ttdeci">#define BEGIN_OUT_OF_PLACE_LOAD(arc, tname, tval)</div><div class="ttdoc">Macro to make it easy to define out-of-place loads. </div><div class="ttdef"><b>Definition:</b> <a href="iarchive_8hpp_source.html#l00314">iarchive.hpp:314</a></div></div>
<div class="ttc" id="group__group__serialization_html_ga623af22fb4db85b09484dd7bfa280f76"><div class="ttname"><a href="group__group__serialization.html#ga623af22fb4db85b09484dd7bfa280f76">BEGIN_OUT_OF_PLACE_SAVE</a></div><div class="ttdeci">#define BEGIN_OUT_OF_PLACE_SAVE(arc, tname, tval)</div><div class="ttdoc">Macro to make it easy to define out-of-place saves. </div><div class="ttdef"><b>Definition:</b> <a href="oarchive_8hpp_source.html#l00346">oarchive.hpp:346</a></div></div>
</div><!-- fragment -->
<p>A macro which disables the serialization of type so that it will fault at runtime. </p>
<p>Writing <a class="el" href="group__group__serialization.html#ga57de99194a197bf248868f9f8fe56932" title="A macro which disables the serialization of type so that it will fault at runtime. ">TURI_UNSERIALIZABLE(T)</a> for some typename T in the global namespace will result in an assertion failure if any attempt is made to serialize or deserialize the type T. This is largely used for debugging purposes to enforce that certain types are never serialized. </p>

<p class="definition">Definition at line <a class="el" href="unsupported__serialize_8hpp_source.html#l00046">46</a> of file <a class="el" href="unsupported__serialize_8hpp_source.html">unsupported_serialize.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadfa7b3064bbe1c7b3cd195d1063760aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfa7b3064bbe1c7b3cd195d1063760aa">&#9670;&nbsp;</a></span>deserialize_from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void turi::deserialize_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializes a object from a string. </p>
<p>Deserializes a serializable object t from a string using the deserializer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of object to deserialize. Typically will be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to deserialize </td></tr>
    <tr><td class="paramname">t</td><td>A reference to the object which will contain the deserialized object when the function returns</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>serialize_from_string() </dd></dl>

<p class="definition">Definition at line <a class="el" href="serialize__to__from__string_8hpp_source.html#l00054">54</a> of file <a class="el" href="serialize__to__from__string_8hpp_source.html">serialize_to_from_string.hpp</a>.</p>

</div>
</div>
<a id="ga02a0b56eec87ca656509579520c36b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02a0b56eec87ca656509579520c36b9c">&#9670;&nbsp;</a></span>deserialize_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InArcType , typename T , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::deserialize_iterator </td>
          <td>(</td>
          <td class="paramtype">InArcType &amp;&#160;</td>
          <td class="paramname"><em>iarc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The accompanying function to <a class="el" href="group__group__serialization.html#ga28d9fd43fcb1100a7727348c160ee618" title="Serializes the contents between the iterators begin and end. ">serialize_iterator()</a> Reads elements from the stream and writes it to the output iterator. </p>
<p>Note that this requires an additional template parameter T which is the "type of object to deserialize" This is necessary for instance for the map type. The <code>map&lt;T,U&gt;::value_type</code> is <code>pair&lt;const T,U&gt;</code>which is not useful since I cannot assign to it. In this case, <code>T=pair&lt;T,U&gt;</code></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutArcType</td><td>The output archive type. </td></tr>
    <tr><td class="paramname">T</td><td>The type of values to deserialize </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>The type of the output iterator to be written to. This should not need to be specified. The compiler will typically infer this correctly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iarc</td><td>A reference to the input archive </td></tr>
    <tr><td class="paramname">result</td><td>The output iterator to write to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iterator_8hpp_source.html#l00100">100</a> of file <a class="el" href="iterator_8hpp_source.html">iterator.hpp</a>.</p>

</div>
</div>
<a id="ga28d9fd43fcb1100a7727348c160ee618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28d9fd43fcb1100a7727348c160ee618">&#9670;&nbsp;</a></span>serialize_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutArcType , typename RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::serialize_iterator </td>
          <td>(</td>
          <td class="paramtype">OutArcType &amp;&#160;</td>
          <td class="paramname"><em>oarc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes the contents between the iterators begin and end. </p>
<p>This function prefers random access iterators since it needs a distance between the begin and end iterator. This function as implemented will work for other input iterators but is extremely inefficient.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutArcType</td><td>The output archive type. This should not need to be specified. The compiler will typically infer this correctly. </td></tr>
    <tr><td class="paramname">RandomAccessIterator</td><td>The iterator type. This should not need to be specified. The compiler will typically infer this correctly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oarc</td><td>A reference to the output archive to write to. </td></tr>
    <tr><td class="paramname">begin</td><td>The start of the iterator range to write. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the iterator range to write. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iterator_8hpp_source.html#l00036">36</a> of file <a class="el" href="iterator_8hpp_source.html">iterator.hpp</a>.</p>

</div>
</div>
<a id="gadddae6e8816fdec445adc5b3d1814a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadddae6e8816fdec445adc5b3d1814a31">&#9670;&nbsp;</a></span>serialize_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutArcType , typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::serialize_iterator </td>
          <td>(</td>
          <td class="paramtype">OutArcType &amp;&#160;</td>
          <td class="paramname"><em>oarc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes the contents between the iterators begin and end. </p>
<p>This functions takes all iterator types, but takes a "count" for efficiency. This count is checked and will return failure if the number of elements serialized does not match the count</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutArcType</td><td>The output archive type. This should not need to be specified. The compiler will typically infer this correctly. </td></tr>
    <tr><td class="paramname">InputIterator</td><td>The iterator type. This should not need to be specified. The compiler will typically infer this correctly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oarc</td><td>A reference to the output archive to write to. </td></tr>
    <tr><td class="paramname">begin</td><td>The start of the iterator range to write. </td></tr>
    <tr><td class="paramname">end</td><td>The end of the iterator range to write. </td></tr>
    <tr><td class="paramname">vsize</td><td>The distance between the iterators begin and end. Must match std::distance(begin, end); </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="iterator_8hpp_source.html#l00067">67</a> of file <a class="el" href="iterator_8hpp_source.html">iterator.hpp</a>.</p>

</div>
</div>
<a id="ga8ff5a70d5a9b9c65a94eb432c2b5ee33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ff5a70d5a9b9c65a94eb432c2b5ee33">&#9670;&nbsp;</a></span>serialize_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::serialize_to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializes a object to a string. </p>
<p>Converts a serializable object t to a string using the serializer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of object to serialize. Typically will be inferred by the compiler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The object to serializer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing a serialized form of t</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__serialization.html#gadfa7b3064bbe1c7b3cd195d1063760aa" title="Deserializes a object from a string. ">deserialize_from_string()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="serialize__to__from__string_8hpp_source.html#l00028">28</a> of file <a class="el" href="serialize__to__from__string_8hpp_source.html">serialize_to_from_string.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
