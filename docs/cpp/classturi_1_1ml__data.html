<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: turi::ml_data Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1ml__data.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classturi_1_1ml__data-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::ml_data Class Reference<div class="ingroups"><a class="el" href="group__mldata.html">ML Data</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml/ml_data/ml_data.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a094512e66230c908e93f9cb28b71da24"><td class="memItemLeft" align="right" valign="top"><a id="a094512e66230c908e93f9cb28b71da24"></a>
typedef std::map&lt; std::string, <a class="el" href="group__mldata.html#ga7beaf7388ecc8bb34821c4a0b38b292f">ml_column_mode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a094512e66230c908e93f9cb28b71da24">column_mode_map</a></td></tr>
<tr class="memdesc:a094512e66230c908e93f9cb28b71da24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is here to get around 2 clang bugs! <br /></td></tr>
<tr class="separator:a094512e66230c908e93f9cb28b71da24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb59cbec74175ad3cdf33937ebfcab70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#afb59cbec74175ad3cdf33937ebfcab70">ml_data</a> ()</td></tr>
<tr class="separator:afb59cbec74175ad3cdf33937ebfcab70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8801e26729767be00f49c6c04fde5ebc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a8801e26729767be00f49c6c04fde5ebc">ml_data</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;<a class="el" href="classturi_1_1ml__data.html#a69d1daf369b9d9aecc039faf0b33f322">metadata</a>)</td></tr>
<tr class="separator:a8801e26729767be00f49c6c04fde5ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d10aedde64688599c748fdf63c06340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a5d10aedde64688599c748fdf63c06340">fill</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;data, const std::string &amp;target_column=&quot;&quot;, const <a class="el" href="classturi_1_1ml__data.html#a094512e66230c908e93f9cb28b71da24">column_mode_map</a> mode_overrides=<a class="el" href="classturi_1_1ml__data.html#a094512e66230c908e93f9cb28b71da24">column_mode_map</a>(), bool immutable_metadata=false, <a class="el" href="group__mldata.html#gaf63b6ae12f1d3be45226d113d0ed1114">ml_missing_value_action</a> mva=ml_missing_value_action::ERROR)</td></tr>
<tr class="separator:a5d10aedde64688599c748fdf63c06340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b8223f076c3e877462f14a7ab33239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a56b8223f076c3e877462f14a7ab33239">fill</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;data, const std::pair&lt; size_t, size_t &gt; &amp;row_bounds, const std::string &amp;target_column=&quot;&quot;, const <a class="el" href="classturi_1_1ml__data.html#a094512e66230c908e93f9cb28b71da24">column_mode_map</a> mode_overrides=<a class="el" href="classturi_1_1ml__data.html#a094512e66230c908e93f9cb28b71da24">column_mode_map</a>(), bool immutable_metadata=false, <a class="el" href="group__mldata.html#gaf63b6ae12f1d3be45226d113d0ed1114">ml_missing_value_action</a> _mva=ml_missing_value_action::ERROR)</td></tr>
<tr class="separator:a56b8223f076c3e877462f14a7ab33239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d1daf369b9d9aecc039faf0b33f322"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a69d1daf369b9d9aecc039faf0b33f322">metadata</a> () const</td></tr>
<tr class="separator:a69d1daf369b9d9aecc039faf0b33f322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76820689577cc37a1aedc34d457e4ffa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a76820689577cc37a1aedc34d457e4ffa">num_columns</a> () const</td></tr>
<tr class="separator:a76820689577cc37a1aedc34d457e4ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b7e393ca9d65453f9cac6549749910"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#af9b7e393ca9d65453f9cac6549749910">num_rows</a> () const</td></tr>
<tr class="separator:af9b7e393ca9d65453f9cac6549749910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac783e841a559ff06254d46cb9dccc5af"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#ac783e841a559ff06254d46cb9dccc5af">size</a> () const</td></tr>
<tr class="separator:ac783e841a559ff06254d46cb9dccc5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049e481e67aa4c8604e9686da19ff6e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a049e481e67aa4c8604e9686da19ff6e2">empty</a> () const</td></tr>
<tr class="separator:a049e481e67aa4c8604e9686da19ff6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad2c1d5dfda53d380e0ccd6c0527827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1ml__data__iterator.html">ml_data_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a5ad2c1d5dfda53d380e0ccd6c0527827">get_iterator</a> (size_t thread_idx=0, size_t num_threads=1) const</td></tr>
<tr class="separator:a5ad2c1d5dfda53d380e0ccd6c0527827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c5786a448a92206efee6cf829132d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a38c5786a448a92206efee6cf829132d2">has_target</a> () const</td></tr>
<tr class="separator:a38c5786a448a92206efee6cf829132d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c372d0e80ae48f6e316bf255f6b8944"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a6c372d0e80ae48f6e316bf255f6b8944">has_untranslated_columns</a> () const</td></tr>
<tr class="separator:a6c372d0e80ae48f6e316bf255f6b8944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac574e48d11ce92b35515b7deb0d36c5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#ac574e48d11ce92b35515b7deb0d36c5f">has_translated_columns</a> () const</td></tr>
<tr class="separator:ac574e48d11ce92b35515b7deb0d36c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465729fe8f3df99c92db122e1ff3a70d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a465729fe8f3df99c92db122e1ff3a70d">max_row_size</a> () const</td></tr>
<tr class="separator:a465729fe8f3df99c92db122e1ff3a70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53dc3c7a41658d3ce68cdc273722983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1ml__data.html">ml_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#aa53dc3c7a41658d3ce68cdc273722983">create_subsampled_copy</a> (size_t n_rows, size_t random_seed) const</td></tr>
<tr class="separator:aa53dc3c7a41658d3ce68cdc273722983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae298e11ca44dcdc61fe2da5119c15043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1ml__data.html">ml_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#ae298e11ca44dcdc61fe2da5119c15043">select_rows</a> (const std::vector&lt; size_t &gt; &amp;selection_indices) const</td></tr>
<tr class="separator:ae298e11ca44dcdc61fe2da5119c15043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b0d055c42cf5927de75ab137d6fec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1ml__data.html">ml_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#af9b0d055c42cf5927de75ab137d6fec9">slice</a> (size_t start_row, size_t end_row) const</td></tr>
<tr class="separator:af9b0d055c42cf5927de75ab137d6fec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a70d122dc962dc91098c1260e2167a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a32a70d122dc962dc91098c1260e2167a">get_version</a> () const</td></tr>
<tr class="separator:a32a70d122dc962dc91098c1260e2167a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b63524fa4aae7346c83ea7e67b7b9aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html#a1b63524fa4aae7346c83ea7e67b7b9aa">_reindex_blocks</a> (const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;reindex_maps)</td></tr>
<tr class="separator:a1b63524fa4aae7346c83ea7e67b7b9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Row based, SFrame-Like Data storage for Learning and Optimization tasks.</p>
<p><code><a class="el" href="classturi_1_1ml__data.html">ml_data</a></code> is a data normalization datastructure that translates user input tables (which can contain arbitrary types like strings, lists, dictionaries, etc) into sparse and dense numeric vectors. This allows toolkits to be implemented in a way that operates on fully mathematical, numeric assumptions, but support a much richer surface area outside.</p>
<p>To support this, <code><a class="el" href="classturi_1_1ml__data.html">ml_data</a></code> is kind of a complicated datastructure that performs several things.</p><ul>
<li>interpret string columns as categorical onto a sparse vector representation, using either one-hot encoding or reference encoding.</li>
<li>map list columns onto a sparse vector representation.</li>
<li>map dictionary columns onto a sparse vector representation.</li>
<li>map dense numeric arrays onto a dense vector representation.</li>
<li>etc. Each row of a user input table is hence translated into a mixed dense-sparse vector. This vector then has to be materialized as an SFrame (allowing it to scale to datasets larger than memory).</li>
</ul>
<p>This can then be used to train other Machine Learning models with.</p>
<p>Finally, the <code><a class="el" href="classturi_1_1ml__data.html">ml_data</a></code> datastructure has to remember and store the translation mappings so that the exact procedure can be performed later on new data (when using the trained model)</p>
<p>Additionally <code><a class="el" href="classturi_1_1ml__data.html">ml_data</a></code> also implement strategies for automatic imputation of missing data. For instance, missing numeric columns can be imputed with the mean, missing categorical columns can be imputed with the most common value, etc.</p>
<p><a class="el" href="classturi_1_1ml__data.html">ml_data</a> loads data from an existing sframe, indexes it by mapping all categorical values to unique indices in 0, 1,2,...,n, and records statistics about the values. It then puts it into an efficient row-based data storage structure for use in learning algorithms that need fast row-wise iteration through the features and target. The row based storage structure is designed for fast iteration through the rows and target. <a class="el" href="classturi_1_1ml__data.html">ml_data</a> also speeds up data access via caching and a compact layout.</p>
<h1>Illustration of the API </h1>
<h2>Using <a class="el" href="classturi_1_1ml__data.html">ml_data</a> </h2>
<p>There are a number of use cases for <a class="el" href="classturi_1_1ml__data.html">ml_data</a>. The following should address the current use cases.</p>
<p>### To construct the data at train time: </p><div class="fragment"><div class="line"><span class="comment">// Constructs an empty ml_data object</span></div><div class="line"><a class="code" href="classturi_1_1ml__data.html#afb59cbec74175ad3cdf33937ebfcab70">ml_data</a> data;</div><div class="line"></div><div class="line"><span class="comment">// Sets the data source from X, with target_column_name being the</span></div><div class="line"><span class="comment">// target column.  (Alternatively, target_column_name may be a</span></div><div class="line"><span class="comment">// single-column SFrame giving the target.  &quot;&quot; denotes no target</span></div><div class="line"><span class="comment">// column present).</span></div><div class="line">data.fill(X, target_column_name);</div><div class="line"></div><div class="line"><span class="comment">// After filling, a serializable shared pointer to the metadata</span></div><div class="line"><span class="comment">// can be saved for the predict stage.  this-&gt;metadata is of type</span></div><div class="line"><span class="comment">// std::shared_ptr&lt;ml_metadata&gt;.</span></div><div class="line">this-&gt;<a class="code" href="classturi_1_1ml__data.html#a69d1daf369b9d9aecc039faf0b33f322">metadata</a> = data.metadata();</div></div><!-- fragment --><p>### To iterate through the data, single threaded. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> it = data.get_iterator(); !it.done(); ++it) {</div><div class="line">   ....</div><div class="line">   it-&gt;target_value();</div><div class="line">   it-&gt;fill(...);</div><div class="line">}</div></div><!-- fragment --><h3>To iterate through the data, threaded.</h3>
<div class="fragment"><div class="line"><a class="code" href="group__threading.html#ga1e5d72eafe277424284997a198212730">in_parallel</a>([&amp;](<span class="keywordtype">size_t</span> thread_idx, <span class="keywordtype">size_t</span> num_threads) {</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = data.get_iterator(thread_idx, num_threads); !it.done(); ++it) {</div><div class="line">     ....</div><div class="line">     it-&gt;target_value();</div><div class="line">     it-&gt;fill(...);</div><div class="line">  }</div><div class="line">});</div></div><!-- fragment --><h3>To construct the data at predict time:</h3>
<div class="fragment"><div class="line"><span class="comment">// Constructs an empty ml_data object, takes construction options</span></div><div class="line"><span class="comment">// from original ml_data.</span></div><div class="line"><a class="code" href="classturi_1_1ml__data.html#afb59cbec74175ad3cdf33937ebfcab70">ml_data</a> data(this-&gt;<a class="code" href="classturi_1_1ml__data.html#a69d1daf369b9d9aecc039faf0b33f322">metadata</a>);</div><div class="line"></div><div class="line"><span class="comment">// Sets the data source from X, with no target column.</span></div><div class="line">data.fill(X);</div></div><!-- fragment --><h3>To serialize the metadata for model serialization</h3>
<div class="fragment"><div class="line"><span class="comment">// Type std::shared_ptr&lt;ml_metadata&gt; is fully serializable.</span></div><div class="line">oarc &lt;&lt; this-&gt;<a class="code" href="classturi_1_1ml__data.html#a69d1daf369b9d9aecc039faf0b33f322">metadata</a>;</div><div class="line"></div><div class="line">iarc &gt;&gt; this-&gt;<a class="code" href="classturi_1_1ml__data.html#a69d1daf369b9d9aecc039faf0b33f322">metadata</a>;</div></div><!-- fragment --><h3>To access statistics at train/predict time.</h3>
<p>Statistics about each of the columns is fully accessible at any point after training time, and does not change. This is stored with the metadata.</p>
<div class="fragment"><div class="line"><span class="comment">// The number of columns.  column_index</span></div><div class="line"><span class="comment">// below is between 0 and this value.</span></div><div class="line">this-&gt;metadata-&gt;num_columns();</div><div class="line"></div><div class="line"><span class="comment">// This gives the number of index value at train time.  Will never</span></div><div class="line"><span class="comment">// change after training time.  For categorical types, it gives</span></div><div class="line"><span class="comment">// the number of categories at train time.  For numerical it is 1</span></div><div class="line"><span class="comment">// if scalar and the width of the vector if numeric.  feature_idx</span></div><div class="line"><span class="comment">// below is between 0 and this value.</span></div><div class="line">this-&gt;metadata-&gt;index_size(column_index);</div><div class="line"></div><div class="line"><span class="comment">// The number of rows having this feature.</span></div><div class="line">this-&gt;metadata-&gt;statistics(column_index)-&gt;count(feature_idx);</div><div class="line"></div><div class="line"><span class="comment">// The mean of this feature.  Missing is counted as 0.</span></div><div class="line">this-&gt;metadata-&gt;statistics(column_index)-&gt;mean(idx);</div><div class="line"></div><div class="line"><span class="comment">// The std dev of this feature.  Missing is counted as 0.</span></div><div class="line">this-&gt;metadata-&gt;statistics(column_index)-&gt;stdev(idx);</div><div class="line"></div><div class="line"><span class="comment">// The number of rows in which the value of this feature is</span></div><div class="line"><span class="comment">// strictly greater than 0.</span></div><div class="line">this-&gt;metadata-&gt;statistics(column_index)-&gt;num_positive(idx);</div><div class="line"></div><div class="line"><span class="comment">// The same methods above, but for the target.</span></div><div class="line">this-&gt;metadata-&gt;target_statistics()-&gt;count();</div><div class="line">this-&gt;metadata-&gt;target_statistics()-&gt;mean();</div><div class="line">this-&gt;metadata-&gt;target_statistics()-&gt;stdev();</div></div><!-- fragment --><h3>Forcing certain column modes.</h3>
<p>The different column modes control the behavior of each column. These modes are defined in ml_data_column_modes as an enum and currently allow NUMERIC, NUMERIC_VECTOR, CATEGORICAL, CATEGORICAL_VECTOR, DICTIONARY.</p>
<p>In most cases, there is an obvious default. However, to force some columns to be set to a particular mode, a mode_override parameter is available to the set_data and add_side_data functions as a map from column name to column_mode. This overrides the default choice. The main use case for this is recsys, where user_id and item_id will always be categorical:</p>
<div class="fragment"><div class="line">data.fill(recsys_data, <span class="stringliteral">&quot;rating&quot;</span>,</div><div class="line">              {{<span class="stringliteral">&quot;user_id&quot;</span>, column_mode::CATEGORICAL},</div><div class="line">               {<span class="stringliteral">&quot;item_id&quot;</span>, column_mode::CATEGORICAL}});</div></div><!-- fragment --><h2>Untranslated Columns </h2>
<p>Untranslated columns can be specified with the set_data(...) method. The untranslated columns are tracked alongside the regular ones, but are not themselves translated, indexed, or even loaded until iteration. These additional columns are then available using the iterator's fill_untranslated_values function.</p>
<p>The way to mark a column as untranslated is to manually specify its type as ml_column_mode::UNTRANSLATED using the mode_overrides parameter in the set_data method. The example code below illustrates this:</p>
<div class="fragment"><div class="line">sframe X = make_integer_testing_sframe( {<span class="stringliteral">&quot;C1&quot;</span>, <span class="stringliteral">&quot;C2&quot;</span>}, { {0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4} } );</div><div class="line"></div><div class="line"><a class="code" href="classturi_1_1ml__data.html#afb59cbec74175ad3cdf33937ebfcab70">ml_data</a> data;</div><div class="line"></div><div class="line">data.set_data(X, <span class="stringliteral">&quot;&quot;</span>, {}, { {<span class="stringliteral">&quot;C2&quot;</span>, ml_column_mode::UNTRANSLATED} });</div><div class="line"></div><div class="line">data.fill();</div><div class="line"></div><div class="line"></div><div class="line">std::vector&lt;ml_data_entry&gt; x_d;</div><div class="line">std::vector&lt;flexible_type&gt; x_f;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">////////////////////////////////////////</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> it = data.get_iterator(); !it.done(); ++it) {</div><div class="line"></div><div class="line">  it-&gt;fill(x_d);</div><div class="line"></div><div class="line">  ASSERT_EQ(x_d.size(), 1);</div><div class="line">  ASSERT_EQ(x_d[0].column_index, 0);</div><div class="line">  ASSERT_EQ(x_d[0].index, 0);</div><div class="line">  ASSERT_EQ(x_d[0].value, it.row_index());</div><div class="line"></div><div class="line">  it-&gt;fill_untranslated(x_f);</div><div class="line"></div><div class="line">  ASSERT_EQ(x_f.size(), 1);</div><div class="line">  <a class="code" href="group__assertions.html#ga1656b25134a180161dcd61a11184cd12">ASSERT_TRUE</a>(x_f[0] == it.row_index());</div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html#l00257">257</a> of file <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afb59cbec74175ad3cdf33937ebfcab70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb59cbec74175ad3cdf33937ebfcab70">&#9670;&nbsp;</a></span>ml_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">turi::ml_data::ml_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an <a class="el" href="classturi_1_1ml__data.html">ml_data</a> object based current options. </p>

</div>
</div>
<a id="a8801e26729767be00f49c6c04fde5ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8801e26729767be00f49c6c04fde5ebc">&#9670;&nbsp;</a></span>ml_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">turi::ml_data::ml_data </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct an <a class="el" href="classturi_1_1ml__data.html">ml_data</a> object based on previous <a class="el" href="classturi_1_1ml__data.html">ml_data</a> metadata. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b63524fa4aae7346c83ea7e67b7b9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b63524fa4aae7346c83ea7e67b7b9aa">&#9670;&nbsp;</a></span>_reindex_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::ml_data::_reindex_blocks </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>reindex_maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remap all the block indices. </p>

</div>
</div>
<a id="aa53dc3c7a41658d3ce68cdc273722983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53dc3c7a41658d3ce68cdc273722983">&#9670;&nbsp;</a></span>create_subsampled_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1ml__data.html">ml_data</a> turi::ml_data::create_subsampled_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>random_seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a subsampled copy of the current <a class="el" href="classturi_1_1ml__data.html">ml_data</a> structure. This allows us quickly create a subset of the data to be used for things like sgd, etc.</p>
<p>If n_rows &lt; <a class="el" href="classturi_1_1ml__data.html#ac783e841a559ff06254d46cb9dccc5af">size()</a>, exactly n_rows are sampled IID from the dataset. Otherwise, a copy of the current <a class="el" href="classturi_1_1ml__data.html">ml_data</a> is returned. </p>

</div>
</div>
<a id="a049e481e67aa4c8604e9686da19ff6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049e481e67aa4c8604e9686da19ff6e2">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::ml_data::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if there is no data in the container. </p>

<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html#l00391">391</a> of file <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a>.</p>

</div>
</div>
<a id="a5d10aedde64688599c748fdf63c06340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d10aedde64688599c748fdf63c06340">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::ml_data::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target_column</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1ml__data.html#a094512e66230c908e93f9cb28b71da24">column_mode_map</a>&#160;</td>
          <td class="paramname"><em>mode_overrides</em> = <code><a class="el" href="classturi_1_1ml__data.html#a094512e66230c908e93f9cb28b71da24">column_mode_map</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>immutable_metadata</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mldata.html#gaf63b6ae12f1d3be45226d113d0ed1114">ml_missing_value_action</a>&#160;</td>
          <td class="paramname"><em>mva</em> = <code>ml_missing_value_action::ERROR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the data from an SFrame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data sframe.</td></tr>
    <tr><td class="paramname">target_column</td><td>If not reusing metadat, specifies the target column. If no target column is present, then use "".</td></tr>
    <tr><td class="paramname">mode_overrides</td><td>A dictionary of column-name to ml_column_mode mode overrides. These will be used instead of the default flex_type_enum -&gt; ml_column_mode mappings. The main use is to specify integers as categorical or designate some columns as untranslated.</td></tr>
    <tr><td class="paramname">immutable_metadata</td><td>If true, then any new values in categorical columns will be mapped to size_t(-1) and not indexed.</td></tr>
    <tr><td class="paramname">mva</td><td>The behavior when missing values are present. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56b8223f076c3e877462f14a7ab33239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b8223f076c3e877462f14a7ab33239">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::ml_data::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; size_t, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target_column</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1ml__data.html#a094512e66230c908e93f9cb28b71da24">column_mode_map</a>&#160;</td>
          <td class="paramname"><em>mode_overrides</em> = <code><a class="el" href="classturi_1_1ml__data.html#a094512e66230c908e93f9cb28b71da24">column_mode_map</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>immutable_metadata</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mldata.html#gaf63b6ae12f1d3be45226d113d0ed1114">ml_missing_value_action</a>&#160;</td>
          <td class="paramname"><em>_mva</em> = <code>ml_missing_value_action::ERROR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the data from an SFrame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data sframe.</td></tr>
    <tr><td class="paramname">row_bounds</td><td>The (lower, upper) bounds on which rows from the original data sframe are considered. It is as if the original sframe has only these rows.</td></tr>
    <tr><td class="paramname">target_column</td><td>If not reusing metadat, specifies the target column. If no target column is present, then use "".</td></tr>
    <tr><td class="paramname">mode_overrides</td><td>A dictionary of column-name to ml_column_mode mode overrides. These will be used instead of the default flex_type_enum -&gt; ml_column_mode mappings. The main use is to specify integers as categorical or designate some columns as untranslated.</td></tr>
    <tr><td class="paramname">immutable_metadata</td><td>If true, then any new values in categorical columns will be mapped to size_t(-1) and not indexed.</td></tr>
    <tr><td class="paramname">mva</td><td>The behavior when missing values are present. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ad2c1d5dfda53d380e0ccd6c0527827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad2c1d5dfda53d380e0ccd6c0527827">&#9670;&nbsp;</a></span>get_iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1ml__data__iterator.html">ml_data_iterator</a> turi::ml_data::get_iterator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_idx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator over part of the data. See <a class="el" href="toolkits_2ml__data__2_2iterators_2ml__data__iterator_8hpp_source.html">iterators/ml_data_iterator.hpp</a> for documentation on the returned iterator. </p>

</div>
</div>
<a id="a32a70d122dc962dc91098c1260e2167a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a70d122dc962dc91098c1260e2167a">&#9670;&nbsp;</a></span>get_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::ml_data::get_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current serialization format. </p>

<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html#l00477">477</a> of file <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a>.</p>

</div>
</div>
<a id="a38c5786a448a92206efee6cf829132d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c5786a448a92206efee6cf829132d2">&#9670;&nbsp;</a></span>has_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::ml_data::has_target </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if a target column is present, and false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html#l00410">410</a> of file <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a>.</p>

</div>
</div>
<a id="ac574e48d11ce92b35515b7deb0d36c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac574e48d11ce92b35515b7deb0d36c5f">&#9670;&nbsp;</a></span>has_translated_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::ml_data::has_translated_columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if any of the non-target columns are translated. </p>

<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html#l00423">423</a> of file <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a>.</p>

</div>
</div>
<a id="a6c372d0e80ae48f6e316bf255f6b8944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c372d0e80ae48f6e316bf255f6b8944">&#9670;&nbsp;</a></span>has_untranslated_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::ml_data::has_untranslated_columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if there are untranslated columns present, and false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html#l00417">417</a> of file <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a>.</p>

</div>
</div>
<a id="a465729fe8f3df99c92db122e1ff3a70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465729fe8f3df99c92db122e1ff3a70d">&#9670;&nbsp;</a></span>max_row_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::ml_data::max_row_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum row size present in the data. This information is calculated when the data is indexed and the <a class="el" href="classturi_1_1ml__data.html">ml_data</a> structure is filled. A buffer sized to this is guaranteed to hold any row encountered while iterating through the data. </p>

<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html#l00433">433</a> of file <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a>.</p>

</div>
</div>
<a id="a69d1daf369b9d9aecc039faf0b33f322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d1daf369b9d9aecc039faf0b33f322">&#9670;&nbsp;</a></span>metadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a>&gt;&amp; turi::ml_data::metadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Direct access to the metadata. </p>

<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html#l00367">367</a> of file <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a>.</p>

</div>
</div>
<a id="a76820689577cc37a1aedc34d457e4ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76820689577cc37a1aedc34d457e4ffa">&#9670;&nbsp;</a></span>num_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::ml_data::num_columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of columns present. </p>

<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html#l00373">373</a> of file <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a>.</p>

</div>
</div>
<a id="af9b7e393ca9d65453f9cac6549749910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b7e393ca9d65453f9cac6549749910">&#9670;&nbsp;</a></span>num_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::ml_data::num_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of rows present. </p>

<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html#l00379">379</a> of file <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a>.</p>

</div>
</div>
<a id="ae298e11ca44dcdc61fe2da5119c15043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae298e11ca44dcdc61fe2da5119c15043">&#9670;&nbsp;</a></span>select_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1ml__data.html">ml_data</a> turi::ml_data::select_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>selection_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a copy of the current <a class="el" href="classturi_1_1ml__data.html">ml_data</a> structure, selecting the rows given by selection_indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selection_indices</td><td>A vector of row indices that must be in sorted order. Duplicates are allowed. The returned <a class="el" href="classturi_1_1ml__data.html">ml_data</a> contains all the rows given by selection_indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classturi_1_1ml__data.html">ml_data</a> object with containing only the rows given by selection_indices. </dd></dl>

</div>
</div>
<a id="ac783e841a559ff06254d46cb9dccc5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac783e841a559ff06254d46cb9dccc5af">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::ml_data::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of rows present. </p>

<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html#l00385">385</a> of file <a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a>.</p>

</div>
</div>
<a id="af9b0d055c42cf5927de75ab137d6fec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b0d055c42cf5927de75ab137d6fec9">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1ml__data.html">ml_data</a> turi::ml_data::slice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a sliced copy of the current <a class="el" href="classturi_1_1ml__data.html">ml_data</a> structure. This copy is cheap. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ml/ml_data/<a class="el" href="ml_2ml__data_2ml__data_8hpp_source.html">ml_data.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="classturi_1_1ml__data.html">ml_data</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
