<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Turi Create: turi::value_container_mapper&lt; Value, ValueContainer &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1value__container__mapper.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classturi_1_1value__container__mapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::value_container_mapper&lt; Value, ValueContainer &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__util.html">Utility Classes and Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="value__container__mapper_8hpp_source.html">core/generics/value_container_mapper.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9ef0495205b2c7fdc32ce2845a28f384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html#a9ef0495205b2c7fdc32ce2845a28f384">reserve</a> (size_t n)</td></tr>
<tr class="separator:a9ef0495205b2c7fdc32ce2845a28f384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3cd4a4cd47c4cb435b95636565b938"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html#a4f3cd4a4cd47c4cb435b95636565b938">size</a> () const </td></tr>
<tr class="separator:a4f3cd4a4cd47c4cb435b95636565b938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e702742e5c6bc3aea91273ec506b98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html#a92e702742e5c6bc3aea91273ec506b98">clear</a> ()</td></tr>
<tr class="separator:a92e702742e5c6bc3aea91273ec506b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2c227f705d2edda53ebbdf1f67881b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html#a4a2c227f705d2edda53ebbdf1f67881b">insert</a> (const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey__and__value.html">hashkey_and_value</a> &amp;hv, ValueContainer *v_ptr) <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a></td></tr>
<tr class="separator:a4a2c227f705d2edda53ebbdf1f67881b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14031148d7efad0b07edf6bbe600e304"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html#a14031148d7efad0b07edf6bbe600e304">insert</a> (const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey.html">hashkey</a> &amp;hk, ValueContainer *v_ptr) <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a></td></tr>
<tr class="separator:a14031148d7efad0b07edf6bbe600e304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a7b19cdbee5c7ed6fc85472be80916"><td class="memItemLeft" align="right" valign="top">ValueContainer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html#a00a7b19cdbee5c7ed6fc85472be80916">find</a> (const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey__and__value.html">hashkey_and_value</a> &amp;hv) <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a></td></tr>
<tr class="separator:a00a7b19cdbee5c7ed6fc85472be80916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c1d1abe6e0f95e4c19ef25d2ca2616"><td class="memItemLeft" align="right" valign="top">ValueContainer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html#a93c1d1abe6e0f95e4c19ef25d2ca2616">find</a> (const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey.html">hashkey</a> &amp;key, const Value &amp;t) <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a></td></tr>
<tr class="separator:a93c1d1abe6e0f95e4c19ef25d2ca2616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9232b6f48e884ef18c136c763c8b789e"><td class="memItemLeft" align="right" valign="top">const ValueContainer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html#a9232b6f48e884ef18c136c763c8b789e">find</a> (const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey__and__value.html">hashkey_and_value</a> &amp;hv) const <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a></td></tr>
<tr class="separator:a9232b6f48e884ef18c136c763c8b789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf284eb344ead868eddc88d402017f1"><td class="memItemLeft" align="right" valign="top">const ValueContainer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html#afdf284eb344ead868eddc88d402017f1">find</a> (const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey.html">hashkey</a> &amp;key, const Value &amp;t) const <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a></td></tr>
<tr class="separator:afdf284eb344ead868eddc88d402017f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8a819e6175ef691d810e545759bfcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html#a2d8a819e6175ef691d810e545759bfcc">invalidate</a> (const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey__and__value.html">hashkey_and_value</a> &amp;hv, ValueContainer *v_ptr) <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a></td></tr>
<tr class="separator:a2d8a819e6175ef691d810e545759bfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2f1611e41d9b54f81312f5e0b213d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html#a6f2f1611e41d9b54f81312f5e0b213d9">invalidate</a> (const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey.html">hashkey</a> &amp;hk, ValueContainer *v_ptr) <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a></td></tr>
<tr class="separator:a6f2f1611e41d9b54f81312f5e0b213d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Value, typename ValueContainer&gt;<br />
class turi::value_container_mapper&lt; Value, ValueContainer &gt;</h3>

<p>A fast, specialized container to track lookups from a Value to a container holding that value (plus other things). Essentially, this is very optimized version of std::map&lt;Value, ValueContainer*&gt;, which adds the following assumptions on the API and the ValueContainer type in order to be really fast.</p>
<ol type="1">
<li>The hash, implemented using a custom hashkey class (see below), is tracked explicitly with the value, and it is up to the user to track this. This permits caching this value and more efficient storage.</li>
<li>The ValueContainer class must hold a hashkey_and_value container (see below); this is essentially a (hashkey, value) pair but with certain other optimizations. This must be accessible via a get_hashkey_and_value() method in the value container, which is then used by</li>
<li>Pointers to the ValueContainer are what is stored, and it is assumed that a Value -&gt; ValueContainer* mapping is valid if and only if the value container holds the same value. Otherwise the <a class="el" href="classturi_1_1value__container__mapper.html#a00a7b19cdbee5c7ed6fc85472be80916">find()</a> method returns a nullptr. (The invalidate function below sticks to this assumption; it just tracks things for lazy cleanup).</li>
</ol>
<p>For a usage example, see <a class="el" href="space__saving_8hpp_source.html">ml/sketches/space_saving.hpp</a>.</p>
<p>The value_container_mapper::hashkey class is initializable by value:</p>
<p>struct hashkey { hashkey(); hashkey(const Value&amp; v);</p>
<p>// A bunch of internal methods... };</p>
<p>The value_container_mapper::hashkey_and_value is initializable either by value (in which case the hashkey is created from a hash of the value), or by hashkey and value pair. It also implements key() and value() methods to return the hashkey() and value() respectively:</p>
<p>struct hashkey_and_value { hashkey_and_value(); hashkey_and_value(const Value&amp; v); hashkey_and_value(const hashkey&amp; hk, const Value&amp; v);</p>
<p>hashkey key() const; const Value&amp; value() const;</p>
<p>// A bunch of internal methods... }; </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00076">76</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a92e702742e5c6bc3aea91273ec506b98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename ValueContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1value__container__mapper.html">turi::value_container_mapper</a>&lt; Value, ValueContainer &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the hash table. </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00098">98</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00a7b19cdbee5c7ed6fc85472be80916"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename ValueContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueContainer* <a class="el" href="classturi_1_1value__container__mapper.html">turi::value_container_mapper</a>&lt; Value, ValueContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey__and__value.html">hashkey_and_value</a> &amp;&#160;</td>
          <td class="paramname"><em>hv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the container associated with this key and value. If it's not present or has been invalidated, returns nullptr. </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00121">121</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93c1d1abe6e0f95e4c19ef25d2ca2616"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename ValueContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueContainer* <a class="el" href="classturi_1_1value__container__mapper.html">turi::value_container_mapper</a>&lt; Value, ValueContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey.html">hashkey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but avoids a potential copy operation of the value if it is not stored in a hashkey_and_value instance already. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00130">130</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9232b6f48e884ef18c136c763c8b789e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename ValueContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ValueContainer* <a class="el" href="classturi_1_1value__container__mapper.html">turi::value_container_mapper</a>&lt; Value, ValueContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey__and__value.html">hashkey_and_value</a> &amp;&#160;</td>
          <td class="paramname"><em>hv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the container associated with this (key, value). If it's not present, returns nullptr. Const overload. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00138">138</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afdf284eb344ead868eddc88d402017f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename ValueContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ValueContainer* <a class="el" href="classturi_1_1value__container__mapper.html">turi::value_container_mapper</a>&lt; Value, ValueContainer &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey.html">hashkey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but avoids a potential copy operation of the value if it is not stored in a hashkey_and_value instance already. Const overload. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00147">147</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a2c227f705d2edda53ebbdf1f67881b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename ValueContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1value__container__mapper.html">turi::value_container_mapper</a>&lt; Value, ValueContainer &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey__and__value.html">hashkey_and_value</a> &amp;&#160;</td>
          <td class="paramname"><em>hv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueContainer *&#160;</td>
          <td class="paramname"><em>v_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a lookup index into the hash mapping. </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00104">104</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a14031148d7efad0b07edf6bbe600e304"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename ValueContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1value__container__mapper.html">turi::value_container_mapper</a>&lt; Value, ValueContainer &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey.html">hashkey</a> &amp;&#160;</td>
          <td class="paramname"><em>hk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueContainer *&#160;</td>
          <td class="paramname"><em>v_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a lookup index into the hash mapping. Overload that pulls the value from v_ptr. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00114">114</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d8a819e6175ef691d810e545759bfcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename ValueContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1value__container__mapper.html">turi::value_container_mapper</a>&lt; Value, ValueContainer &gt;::invalidate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey__and__value.html">hashkey_and_value</a> &amp;&#160;</td>
          <td class="paramname"><em>hv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueContainer *&#160;</td>
          <td class="paramname"><em>v_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Marks a particular value_container as invalid. It is assumed, however, that as long as ValueContainer* holds the value, it is a valid key; otherwise it is not. This function does some lazy cleanup, but may not erase the key. </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00156">156</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f2f1611e41d9b54f81312f5e0b213d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename ValueContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1value__container__mapper.html">turi::value_container_mapper</a>&lt; Value, ValueContainer &gt;::invalidate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1vc__internal_1_1vc__hashkey.html">hashkey</a> &amp;&#160;</td>
          <td class="paramname"><em>hk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueContainer *&#160;</td>
          <td class="paramname"><em>v_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Marks a particular value_container as invalid. It is assumed, however, that as long as ValueContainer* holds the value, it is a valid key; otherwise it is not. This function does some lazy cleanup, but may not erase the key.</p>
<p>Overload that pulls the value from v_ptr. This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00170">170</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ef0495205b2c7fdc32ce2845a28f384"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename ValueContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classturi_1_1value__container__mapper.html">turi::value_container_mapper</a>&lt; Value, ValueContainer &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reserves internal storage for n elements. </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00088">88</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f3cd4a4cd47c4cb435b95636565b938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value, typename ValueContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classturi_1_1value__container__mapper.html">turi::value_container_mapper</a>&lt; Value, ValueContainer &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current size of the hash table. </p>

<p>Definition at line <a class="el" href="value__container__mapper_8hpp_source.html#l00092">92</a> of file <a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/generics/<a class="el" href="value__container__mapper_8hpp_source.html">value_container_mapper.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="classturi_1_1value__container__mapper.html">value_container_mapper</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
