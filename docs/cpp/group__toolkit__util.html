<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: Toolkit Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__toolkit__util.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Toolkit Utilities</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1option__handling_1_1option__info.html">turi::option_handling::option_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1option__manager.html">turi::option_manager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1recsys_1_1lm__data__generator.html">turi::recsys::lm_data_generator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1indexed__column__groupby.html">turi::indexed_column_groupby</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspmat.html">spmat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0ad3530418c9bcd52e3cec371f245a8b"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename ComparisonFunction , typename AccumulateFunction &gt; </td></tr>
<tr class="memitem:ga0ad3530418c9bcd52e3cec371f245a8b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga0ad3530418c9bcd52e3cec371f245a8b">turi::accumulate_intersection</a> (InputIterator1 first1, const InputIterator1 &amp;last1, InputIterator2 first2, const InputIterator2 &amp;last2, const ComparisonFunction &amp;less_than_operator, const AccumulateFunction &amp;accumulate_matching_pair)</td></tr>
<tr class="separator:ga0ad3530418c9bcd52e3cec371f245a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a245b6f97ff63864fcad59c40c1b47f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename AccumulateFunction &gt; </td></tr>
<tr class="memitem:ga1a245b6f97ff63864fcad59c40c1b47f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga1a245b6f97ff63864fcad59c40c1b47f">turi::accumulate_intersection</a> (InputIterator1 first1, const InputIterator1 &amp;last1, InputIterator2 first2, const InputIterator2 &amp;last2, const AccumulateFunction &amp;accumulate_matching_pair)</td></tr>
<tr class="separator:ga1a245b6f97ff63864fcad59c40c1b47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ea40acb9aa1c215739d74870dca949"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 &gt; </td></tr>
<tr class="memitem:ga42ea40acb9aa1c215739d74870dca949"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga42ea40acb9aa1c215739d74870dca949">turi::count_intersection</a> (InputIterator1 first1, const InputIterator1 &amp;last1, InputIterator2 first2, const InputIterator2 &amp;last2)</td></tr>
<tr class="separator:ga42ea40acb9aa1c215739d74870dca949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d7dc2175a0f5f56d4b297c3b1a0009"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename ComparisonFunction &gt; </td></tr>
<tr class="memitem:ga89d7dc2175a0f5f56d4b297c3b1a0009"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga89d7dc2175a0f5f56d4b297c3b1a0009">turi::count_intersection</a> (InputIterator1 first1, const InputIterator1 &amp;last1, InputIterator2 first2, const InputIterator2 &amp;last2, const ComparisonFunction &amp;less_than_operator)</td></tr>
<tr class="separator:ga89d7dc2175a0f5f56d4b297c3b1a0009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa230f5663cb3d54930f7b834176edddd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#gaa230f5663cb3d54930f7b834176edddd">turi::get_unique_values</a> (std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; indexed_column)</td></tr>
<tr class="separator:gaa230f5663cb3d54930f7b834176edddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be1372202e9256374e877793887e8af"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga5be1372202e9256374e877793887e8af">turi::make_unique</a> (std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; indexed_column)</td></tr>
<tr class="separator:ga5be1372202e9256374e877793887e8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec5ab8ec0d8c4c856e9688fd56ce042"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#gabec5ab8ec0d8c4c856e9688fd56ce042">turi::recsys::precision_and_recall</a> (std::vector&lt; size_t &gt; actual, std::vector&lt; size_t &gt; predicted, const std::vector&lt; size_t &gt; &amp;cutoffs)</td></tr>
<tr class="separator:gabec5ab8ec0d8c4c856e9688fd56ce042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a1afeeeb1d2a64f701e801ac33f445d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga6a1afeeeb1d2a64f701e801ac33f445d">turi::recsys::recall</a> (const std::vector&lt; size_t &gt; &amp;actual, const std::vector&lt; size_t &gt; &amp;predicted, const std::vector&lt; size_t &gt; &amp;cutoffs)</td></tr>
<tr class="separator:ga6a1afeeeb1d2a64f701e801ac33f445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ae38a59ff7dcec0e63c342ae6c718c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga04ae38a59ff7dcec0e63c342ae6c718c">turi::recsys::precision</a> (const std::vector&lt; size_t &gt; &amp;actual, const std::vector&lt; size_t &gt; &amp;predicted, const std::vector&lt; size_t &gt; &amp;cutoffs)</td></tr>
<tr class="separator:ga04ae38a59ff7dcec0e63c342ae6c718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf922f0d9f423d65ce03ecd08c32e8b48"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#gaf922f0d9f423d65ce03ecd08c32e8b48">turi::recsys::average_precision</a> (const std::unordered_set&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;actual, const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;predicted, const int k)</td></tr>
<tr class="separator:gaf922f0d9f423d65ce03ecd08c32e8b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7af2202890a2d4f51041e7969eb20fa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#gad7af2202890a2d4f51041e7969eb20fa">turi::recsys::mean_average_precision</a> (const std::vector&lt; std::unordered_set&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&gt; &amp;actual, const std::vector&lt; std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&gt; &amp;predicted, const int k)</td></tr>
<tr class="separator:gad7af2202890a2d4f51041e7969eb20fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54025cc8bf2e793927c0202ebcb68ed3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a>, <a class="el" href="classturi_1_1sframe.html">sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga54025cc8bf2e793927c0202ebcb68ed3">turi::split_sframe_on_index</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;src, std::function&lt; bool(size_t)&gt; switch_function)</td></tr>
<tr class="separator:ga54025cc8bf2e793927c0202ebcb68ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55b6675b70fe0932c3c6dff099edab3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#gaf55b6675b70fe0932c3c6dff099edab3">turi::matrix_to_sarray</a> (const Eigen::MatrixXd &amp;m)</td></tr>
<tr class="separator:gaf55b6675b70fe0932c3c6dff099edab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18a4682bfe16de1db8594e334d57e7ab"><td class="memTemplParams" colspan="2">template&lt;typename GenFunction &gt; </td></tr>
<tr class="memitem:ga18a4682bfe16de1db8594e334d57e7ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga18a4682bfe16de1db8594e334d57e7ab">turi::sframe_from_ranged_generator</a> (const std::vector&lt; std::string &gt; &amp;column_names, const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;column_types, size_t num_rows, GenFunction &amp;&amp;generator_function)</td></tr>
<tr class="separator:ga18a4682bfe16de1db8594e334d57e7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Random toolkit utility methods </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0ad3530418c9bcd52e3cec371f245a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad3530418c9bcd52e3cec371f245a8b">&#9670;&nbsp;</a></span>accumulate_intersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename ComparisonFunction , typename AccumulateFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void turi::accumulate_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator1 &amp;&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator2 &amp;&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ComparisonFunction &amp;&#160;</td>
          <td class="paramname"><em>less_than_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccumulateFunction &amp;&#160;</td>
          <td class="paramname"><em>accumulate_matching_pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls an accumulator on all intersections in two sorted ranges. This behavior is analogous to std::set_intersection, except that the intersections are simply accumulated. Matching is performed through the use of less_than_operator.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>The type of an input iterator over the first range.</td></tr>
    <tr><td class="paramname">InputIterator2</td><td>The type of an input iterator over the second range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The begin() iterator of the first range.</td></tr>
    <tr><td class="paramname">last1</td><td>The end() iterator of the first range.</td></tr>
    <tr><td class="paramname">first2</td><td>The begin() iterator of the second range.</td></tr>
    <tr><td class="paramname">last2</td><td>The end() iterator of the second range.</td></tr>
    <tr><td class="paramname">less_than_operator</td><td>A comparison function that determines the ordering. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="algorithmic__utils_8hpp_source.html#l00039">39</a> of file <a class="el" href="algorithmic__utils_8hpp_source.html">algorithmic_utils.hpp</a>.</p>

</div>
</div>
<a id="ga1a245b6f97ff63864fcad59c40c1b47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a245b6f97ff63864fcad59c40c1b47f">&#9670;&nbsp;</a></span>accumulate_intersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename AccumulateFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void turi::accumulate_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator1 &amp;&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator2 &amp;&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccumulateFunction &amp;&#160;</td>
          <td class="paramname"><em>accumulate_matching_pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls an accumulator on all intersections in two sorted ranges. This behavior is analogous to std::set_intersection, except that the intersections are simply accumulated.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>The type of an input iterator over the first range.</td></tr>
    <tr><td class="paramname">InputIterator2</td><td>The type of an input iterator over the second range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The begin() iterator of the first range.</td></tr>
    <tr><td class="paramname">last1</td><td>The end() iterator of the first range.</td></tr>
    <tr><td class="paramname">first2</td><td>The begin() iterator of the second range.</td></tr>
    <tr><td class="paramname">last2</td><td>The end() iterator of the second range. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="algorithmic__utils_8hpp_source.html#l00080">80</a> of file <a class="el" href="algorithmic__utils_8hpp_source.html">algorithmic_utils.hpp</a>.</p>

</div>
</div>
<a id="gaf922f0d9f423d65ce03ecd08c32e8b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf922f0d9f423d65ce03ecd08c32e8b48">&#9670;&nbsp;</a></span>average_precision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float turi::recsys::average_precision </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>predicted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the average precision at k. This combines precision values at values up to k, where lower ranks are less important.</p>
<p>Let <img class="formulaInl" alt="$p_k$" src="form_16.png"/> be a vector of the first <img class="formulaInl" alt="$k$" src="form_17.png"/> elements of the argument "predicted", and let <img class="formulaInl" alt="$a$" src="form_18.png"/> be the set of items in the "actual" argument. If <img class="formulaInl" alt="$P(k)$" src="form_21.png"/> is the precision at <img class="formulaInl" alt="$k$" src="form_17.png"/>, then the average precision at <img class="formulaInl" alt="$k$" src="form_17.png"/> is defined as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ AP(k) = \frac{1}{\min(k, |a|)}\sum_{k: p_k \in a} \frac{P(k)}{k} \]" src="form_22.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actual</td><td>an unordered set of observed items </td></tr>
    <tr><td class="paramname">predicted</td><td>an vector of predicted items </td></tr>
    <tr><td class="paramname">k</td><td>the maximum number of predicted elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average precision at k for the provided lists. </dd></dl>

</div>
</div>
<a id="ga42ea40acb9aa1c215739d74870dca949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ea40acb9aa1c215739d74870dca949">&#9670;&nbsp;</a></span>count_intersection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t turi::count_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator1 &amp;&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator2 &amp;&#160;</td>
          <td class="paramname"><em>last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the number of intersections in two sorted ranges. This behavior is analogous to std::set_intersection, except that the intersections are simply stored and not output.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>The type of an input iterator over the first range.</td></tr>
    <tr><td class="paramname">InputIterator2</td><td>The type of an input iterator over the second range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The begin() iterator of the first range.</td></tr>
    <tr><td class="paramname">last1</td><td>The end() iterator of the first range.</td></tr>
    <tr><td class="paramname">first2</td><td>The begin() iterator of the second range.</td></tr>
    <tr><td class="paramname">last2</td><td>The end() iterator of the second range. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="algorithmic__utils_8hpp_source.html#l00114">114</a> of file <a class="el" href="algorithmic__utils_8hpp_source.html">algorithmic_utils.hpp</a>.</p>

</div>
</div>
<a id="ga89d7dc2175a0f5f56d4b297c3b1a0009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89d7dc2175a0f5f56d4b297c3b1a0009">&#9670;&nbsp;</a></span>count_intersection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename ComparisonFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t turi::count_intersection </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator1 &amp;&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator2 &amp;&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ComparisonFunction &amp;&#160;</td>
          <td class="paramname"><em>less_than_operator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the number of intersections in two sorted ranges. This behavior is analogous to std::set_intersection, except that the intersections are simply stored and not output. Matching is performed through the use of less_than_operator.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td>The type of an input iterator over the first range.</td></tr>
    <tr><td class="paramname">InputIterator2</td><td>The type of an input iterator over the second range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first1</td><td>The begin() iterator of the first range.</td></tr>
    <tr><td class="paramname">last1</td><td>The end() iterator of the first range.</td></tr>
    <tr><td class="paramname">first2</td><td>The begin() iterator of the second range.</td></tr>
    <tr><td class="paramname">last2</td><td>The end() iterator of the second range.</td></tr>
    <tr><td class="paramname">less_than_operator</td><td>A comparison function that determines the ordering. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="algorithmic__utils_8hpp_source.html#l00152">152</a> of file <a class="el" href="algorithmic__utils_8hpp_source.html">algorithmic_utils.hpp</a>.</p>

</div>
</div>
<a id="gaa230f5663cb3d54930f7b834176edddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa230f5663cb3d54930f7b834176edddd">&#9670;&nbsp;</a></span>get_unique_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; turi::get_unique_values </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>indexed_column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a vector of the unique values present in an sframe column having integer type. The resulting vector is in sorted order, so membership can be queried using std::binary_search. When the 0, ..., n condition is met, this is faster than .unique(). </p>

</div>
</div>
<a id="ga5be1372202e9256374e877793887e8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be1372202e9256374e877793887e8af">&#9670;&nbsp;</a></span>make_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; turi::make_unique </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>indexed_column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function: Same as get_unique_values, but returns the result as an sarray. </p>

</div>
</div>
<a id="gaf55b6675b70fe0932c3c6dff099edab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf55b6675b70fe0932c3c6dff099edab3">&#9670;&nbsp;</a></span>matrix_to_sarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; turi::matrix_to_sarray </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an SArray of vector type, where each element is a row of the provided matrix. </p>

</div>
</div>
<a id="gad7af2202890a2d4f51041e7969eb20fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7af2202890a2d4f51041e7969eb20fa">&#9670;&nbsp;</a></span>mean_average_precision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float turi::recsys::mean_average_precision </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unordered_set&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute mean average precision across all of the elements of the provided vectors. The two vectors must have the same length.</p>
<p>actual: a vector of unordered sets of observed items. predicted: a vector of vectors of observed items. </p>

</div>
</div>
<a id="ga04ae38a59ff7dcec0e63c342ae6c718c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04ae38a59ff7dcec0e63c342ae6c718c">&#9670;&nbsp;</a></span>precision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; turi::recsys::precision </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>predicted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cutoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute precision at k. In information retrieval terms, this represents the ratio of relevant, retrieved items to the number of retrieved items.</p>
<p>Let <img class="formulaInl" alt="$p_k$" src="form_16.png"/> be a vector of the first <img class="formulaInl" alt="$k$" src="form_17.png"/> elements of the argument "predicted", and let <img class="formulaInl" alt="$a$" src="form_18.png"/> be the set of items in the "actual" argument. The "precision at K" is defined as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P(k) = \frac{ | a \cap p_k | }{|p_k|} \]" src="form_20.png"/>
</p>
<p>The order of the elements in predicted affects the returned score. Only unique predicted values contribute to the score. One of the provided vectors must be nonempty. If actual is empty, return 0.0. If predicted is empty, returns 1.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actual</td><td>an unordered vector observed items </td></tr>
    <tr><td class="paramname">predicted</td><td>an vector of predicted items </td></tr>
    <tr><td class="paramname">cutoffs</td><td>A vector of positive integers for which recall should be calculated</td></tr>
  </table>
  </dd>
</dl>
<p>return A vector of precision scores corresponding to the values in cutoffs</p>
<p>Notes: The corner cases that involve empty lists were chosen to be consistent with the feasible set of precision-recall curves, which start at (precision, recall) = (1,0) and end at (0,1). However, we do not believe there is a well-known concensus on this choice.Other versions of the above code </p>

</div>
</div>
<a id="gabec5ab8ec0d8c4c856e9688fd56ce042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabec5ab8ec0d8c4c856e9688fd56ce042">&#9670;&nbsp;</a></span>precision_and_recall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;double, double&gt; &gt; turi::recsys::precision_and_recall </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>predicted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cutoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute precision and recall at k. This is faster than calculating precision and recall seperately. In information retrieval terms, this represents the ratio of relevant, retrieved items to the number of relevant items.</p>
<p>Let <img class="formulaInl" alt="$p_k$" src="form_16.png"/> be a vector of the first <img class="formulaInl" alt="$k$" src="form_17.png"/> elements of the argument "predicted", and let <img class="formulaInl" alt="$a$" src="form_18.png"/> be the set of items in the "actual" argument. The "recall at K" is defined as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P(k) = \frac{ | a \cap p_k | }{|a|} \]" src="form_19.png"/>
</p>
<p>The order of the elements in predicted affects the returned score. Only unique predicted values contribute to the score. One of the provided vectors must be nonempty. If actual is empty, return 1.0. If predicted is empty, returns 0.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actual</td><td>A vector of observed items </td></tr>
    <tr><td class="paramname">predicted</td><td>A vector of predicted items </td></tr>
    <tr><td class="paramname">cutoffs</td><td>A vector of positive integers for which recall should be calculated</td></tr>
  </table>
  </dd>
</dl>
<p>return A vector of pair(precision, recall) scores corresponding to the values in cutoffs.</p>
<p>Notes: The corner cases that involve empty lists were chosen to be consistent with the feasible set of precision-recall curves, which start at (precision, recall) = (1,0) and end at (0,1). However, we do not believe there is a well-known concensus on this choice. </p>

</div>
</div>
<a id="ga6a1afeeeb1d2a64f701e801ac33f445d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a1afeeeb1d2a64f701e801ac33f445d">&#9670;&nbsp;</a></span>recall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; turi::recsys::recall </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>predicted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>cutoffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute recall at k. In information retrieval terms, this represents the ratio of relevant, retrieved items to the number of relevant items.</p>
<p>Let <img class="formulaInl" alt="$p_k$" src="form_16.png"/> be a vector of the first <img class="formulaInl" alt="$k$" src="form_17.png"/> elements of the argument "predicted", and let <img class="formulaInl" alt="$a$" src="form_18.png"/> be the set of items in the "actual" argument. The "recall at K" is defined as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P(k) = \frac{ | a \cap p_k | }{|a|} \]" src="form_19.png"/>
</p>
<p>The order of the elements in predicted affects the returned score. Only unique predicted values contribute to the score. One of the provided vectors must be nonempty. If actual is empty, return 1.0. If predicted is empty, returns 0.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actual</td><td>an unordered vector of observed items </td></tr>
    <tr><td class="paramname">predicted</td><td>an vector of predicted items </td></tr>
    <tr><td class="paramname">cutoffs</td><td>A vector of positive integers for which recall should be calculated</td></tr>
  </table>
  </dd>
</dl>
<p>return A vector of recall scores corresponding to the values in cutoffs</p>
<p>Notes: The corner cases that involve empty lists were chosen to be consistent with the feasible set of precision-recall curves, which start at (precision, recall) = (1,0) and end at (0,1). However, we do not believe there is a well-known concensus on this choice. </p>

</div>
</div>
<a id="ga18a4682bfe16de1db8594e334d57e7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18a4682bfe16de1db8594e334d57e7ab">&#9670;&nbsp;</a></span>sframe_from_ranged_generator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GenFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1sframe.html">sframe</a> turi::sframe_from_ranged_generator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>generator_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate an SFrame from a transform function that takes an index and fills a vector of flexible type. The signature of the transform function should be:</p>
<p>gen_fill_func(size_t row_index, std::vector&lt;flexible_type&gt;&amp; out_values);</p>
<p>Access there is done in parallel.</p>
<p>s </p>

<p class="definition">Definition at line <a class="el" href="sframe__utils_8hpp_source.html#l00048">48</a> of file <a class="el" href="sframe__utils_8hpp_source.html">sframe_utils.hpp</a>.</p>

</div>
</div>
<a id="ga54025cc8bf2e793927c0202ebcb68ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54025cc8bf2e793927c0202ebcb68ed3">&#9670;&nbsp;</a></span>split_sframe_on_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classturi_1_1sframe.html">sframe</a>,<a class="el" href="classturi_1_1sframe.html">sframe</a>&gt; turi::split_sframe_on_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(size_t)&gt;&#160;</td>
          <td class="paramname"><em>switch_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters the rows of an sframe into the first (false) or second (true) sframe by a switch function. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
