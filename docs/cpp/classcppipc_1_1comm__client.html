<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Turi Create: cppipc::comm_client Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcppipc_1_1comm__client.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classcppipc_1_1comm__client-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cppipc::comm_client Class Reference<div class="ingroups"><a class="el" href="group__cppipc.html">C++ Interprocess Communication Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="comm__client_8hpp_source.html">core/system/cppipc/client/comm_client.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae649032590d47393ed441bb175dab70c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#ae649032590d47393ed441bb175dab70c">comm_client</a> (std::vector&lt; std::string &gt; zkhosts, std::string name, size_t num_tolerable_ping_failures=(size_t)(-1), std::string alternate_control_address=&quot;&quot;, std::string alternate_publish_address=&quot;&quot;, const std::string public_key=&quot;&quot;, const std::string secret_key=&quot;&quot;, const std::string server_public_key=&quot;&quot;, bool ops_interruptible=false)</td></tr>
<tr class="separator:ae649032590d47393ed441bb175dab70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021f0c9432200eb27d37fa4997110b4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a021f0c9432200eb27d37fa4997110b4e">comm_client</a> (std::string name, void *zmq_ctx)</td></tr>
<tr class="separator:a021f0c9432200eb27d37fa4997110b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718554b58ef28134964464921b88438f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a718554b58ef28134964464921b88438f">set_server_alive_watch_pid</a> (int32_t pid)</td></tr>
<tr class="separator:a718554b58ef28134964464921b88438f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afc6836fd33703ba11498ee7beba01d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a5afc6836fd33703ba11498ee7beba01d">init</a> (bool ops_interruptible=false)</td></tr>
<tr class="separator:a5afc6836fd33703ba11498ee7beba01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479d8019a70c4932dddf7cb235904737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__cppipc.html#ga4b52bfde0818050add61a5338441e087">reply_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a479d8019a70c4932dddf7cb235904737">start</a> ()</td></tr>
<tr class="separator:a479d8019a70c4932dddf7cb235904737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5118e1afb6c86135a32dc62090e416"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a3b5118e1afb6c86135a32dc62090e416">~comm_client</a> ()</td></tr>
<tr class="separator:a3b5118e1afb6c86135a32dc62090e416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87be87dc345902e2302057d09739e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#ae87be87dc345902e2302057d09739e91">stop</a> ()</td></tr>
<tr class="separator:ae87be87dc345902e2302057d09739e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0535adcf8ed155dc240a236b0033d43a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a0535adcf8ed155dc240a236b0033d43a">make_object</a> (std::string object_type_name)</td></tr>
<tr class="separator:a0535adcf8ed155dc240a236b0033d43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14186bfee377e84680afa2fe69ac836d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a14186bfee377e84680afa2fe69ac836d">ping</a> (std::string)</td></tr>
<tr class="separator:a14186bfee377e84680afa2fe69ac836d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85b11228c52b8c97b97c029b34fcb8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#af85b11228c52b8c97b97c029b34fcb8e">delete_object</a> (size_t objectid)</td></tr>
<tr class="separator:af85b11228c52b8c97b97c029b34fcb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ad94628bcea50b60d2dc3ebf3b4da8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a33ad94628bcea50b60d2dc3ebf3b4da8">incr_ref_count</a> (size_t object_id)</td></tr>
<tr class="separator:a33ad94628bcea50b60d2dc3ebf3b4da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2f8a16abda256b8dd2a1866bb1f91e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a8d2f8a16abda256b8dd2a1866bb1f91e">status_callback_thread_function</a> ()</td></tr>
<tr class="separator:a8d2f8a16abda256b8dd2a1866bb1f91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319a8b10941ba2723143be11f919604a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a319a8b10941ba2723143be11f919604a">stop_status_callback_thread</a> ()</td></tr>
<tr class="separator:a319a8b10941ba2723143be11f919604a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12552e01d4fd8558d553a690a9415975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a12552e01d4fd8558d553a690a9415975">start_status_callback_thread</a> ()</td></tr>
<tr class="separator:a12552e01d4fd8558d553a690a9415975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8560b918adaabdb556e0cb4816b1f06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#af8560b918adaabdb556e0cb4816b1f06">add_status_watch</a> (std::string watch_prefix, std::function&lt; void(std::string)&gt; callback)</td></tr>
<tr class="separator:af8560b918adaabdb556e0cb4816b1f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebc1f028dbd89f9e51aa94db2ab0ef1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#afebc1f028dbd89f9e51aa94db2ab0ef1">remove_status_watch</a> (std::string watch_prefix)</td></tr>
<tr class="separator:afebc1f028dbd89f9e51aa94db2ab0ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b64ed5d3eeaa365809de54273c5e3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#aa5b64ed5d3eeaa365809de54273c5e3d">clear_status_watch</a> ()</td></tr>
<tr class="separator:aa5b64ed5d3eeaa365809de54273c5e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08982555c67856fc030bf75aca47ec90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a08982555c67856fc030bf75aca47ec90">stop_ping_thread</a> ()</td></tr>
<tr class="separator:a08982555c67856fc030bf75aca47ec90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cfeadbcfab8940521384b974679566"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a59cfeadbcfab8940521384b974679566">send_deletion_list</a> (const std::vector&lt; size_t &gt; &amp;object_ids)</td></tr>
<tr class="separator:a59cfeadbcfab8940521384b974679566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d139c54c3e0653cf72a780ad79e5c9a"><td class="memTemplParams" colspan="2">template&lt;typename MemFn &gt; </td></tr>
<tr class="memitem:a6d139c54c3e0653cf72a780ad79e5c9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a6d139c54c3e0653cf72a780ad79e5c9a">register_function</a> (MemFn f, std::string function_string)</td></tr>
<tr class="separator:a6d139c54c3e0653cf72a780ad79e5c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14535c64a8981a3888b02d9402032ef6"><td class="memTemplParams" colspan="2">template&lt;typename MemFn , typename... Args&gt; </td></tr>
<tr class="memitem:a14535c64a8981a3888b02d9402032ef6"><td class="memTemplItemLeft" align="right" valign="top">detail::member_function_return_type&lt; MemFn &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a14535c64a8981a3888b02d9402032ef6">call</a> (size_t objectid, MemFn f, const Args &amp;...args)</td></tr>
<tr class="separator:a14535c64a8981a3888b02d9402032ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a011c0f1fae00cbcc2a890022cdd19609"><td class="memItemLeft" align="right" valign="top">boost::thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a011c0f1fae00cbcc2a890022cdd19609">status_callback_thread</a> = NULL</td></tr>
<tr class="separator:a011c0f1fae00cbcc2a890022cdd19609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba7f6680e949e8c411dff7c9964d0e3"><td class="memItemLeft" align="right" valign="top">boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppipc_1_1comm__client.html#a5ba7f6680e949e8c411dff7c9964d0e3">status_buffer_mutex</a></td></tr>
<tr class="separator:a5ba7f6680e949e8c411dff7c9964d0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The client side of the IPC communication system.</p>
<p>The <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a> manages the serialization, and the calling of functions on remote machines. The <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a> and the <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a> reaches each other through the use of zookeeper. If both client and server connect to the same zookeeper host, and on construction are provided the same "name", they are connected.</p>
<p>The <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a> provides communication capability for the <a class="el" href="classcppipc_1_1object__proxy.html">object_proxy</a> objects. Here, we will go through an example of proxying the file_write class described in the <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a> documentation.</p>
<h2>Basic Utilization </h2>
<p>Given a base class file_write_base, which is implemented on the server side, we can construct on the client side, an <a class="el" href="classcppipc_1_1object__proxy.html">object_proxy</a> object which creates and binds to an implementation of file_write_base on the server side, and allows function calls across the network.</p>
<p>We first repeat the description for the base class here: </p><div class="fragment"><div class="line"><span class="keyword">class </span>file_write_base {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">int</span> open(std::string s) = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(std::string s) = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> close() = 0;</div><div class="line">  <span class="keyword">virtual</span> ~file_write_base() {}</div><div class="line"></div><div class="line">  <a class="code" href="group__cppipc.html#gab991ba71aa82c1aa330ae2054ea41baf">REGISTRATION_BEGIN</a>(file_write_base)</div><div class="line">  REGISTER(file_write_base::open)</div><div class="line">  REGISTER(file_write_base::write)</div><div class="line">  REGISTER(file_write_base::close)</div><div class="line">  REGISTRATION_END</div><div class="line">};</div></div><!-- fragment --><p>We can create an <a class="el" href="classcppipc_1_1object__proxy.html">object_proxy</a> by templating over the base class, and providing the <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a> object in the constructor. </p><div class="fragment"><div class="line">object_proxy&lt;file_write_base&gt; proxy(client);</div></div><!-- fragment --><p> This will create on the remote machine, an instance of the file_write_impl object, and the <a class="el" href="classcppipc_1_1object__proxy.html">object_proxy</a> class provides the capability to call functions on the remote object. For instance, to call the "open" function, followed by some "writes" and "close". </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> ret = proxy.call(&amp;file_write_base::open, <span class="stringliteral">&quot;log.txt&quot;</span>);</div><div class="line">proxy.call(&amp;file_write_base::write, <span class="stringliteral">&quot;hello&quot;</span>);</div><div class="line">proxy.call(&amp;file_write_base::write, <span class="stringliteral">&quot;world&quot;</span>);</div><div class="line">proxy.call(&amp;file_write_base::close);</div></div><!-- fragment --><p> The return type of the proxy.call function will match the return type of the member function pointer provided. For instance, &amp;file_write_base::open returns an integer, and the result is forwarded across the network and returned.</p>
<p>On destruction of the proxy object, the remote object is also deleted.</p>
<h2>Wrapping the Proxy Object </h2>
<p>It might be convenient in many ways to wrap the <a class="el" href="classcppipc_1_1object__proxy.html">object_proxy</a> in a way to make it easy to use. This is a convenient pattern that is very useful.</p>
<p>For instance, a proxy wrapper for the file_write_base object might look like: </p><div class="fragment"><div class="line"><span class="keyword">class </span>file_write_proxy: <span class="keyword">public</span> file_write_base {</div><div class="line"> object_proxy&lt;file_write_base&gt; proxy;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  file_write_proxy(<a class="code" href="classcppipc_1_1comm__client.html#ae649032590d47393ed441bb175dab70c">comm_client</a>&amp; comm): proxy(comm) { }</div><div class="line">  <span class="keywordtype">int</span> open(std::string s) {</div><div class="line">    <span class="keywordflow">return</span> proxy.call(&amp;file_write_base::open, s);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> write(std::string s) {</div><div class="line">    <span class="keywordflow">return</span> proxy.call(&amp;file_write_base::write , s);</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> close() {</div><div class="line">    <span class="keywordflow">return</span> proxy.call(&amp;file_write_base::close);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><h2>Preprocessor Magic </h2>
<p>To facilitate the creation of base interfaces, calling REGISTER macros appropriately, and implementing the proxy wrapper, we provide the <a class="el" href="group__cppipc.html#ga50d62f9a4f9340aa882c1a9a941796c9">GENERATE_INTERFACE</a>, <a class="el" href="group__cppipc.html#ga6eb05d8039f31e1755dd418156e07b5a">GENERATE_PROXY</a> and <a class="el" href="group__cppipc.html#ga838dae619459dce33202c1e28ecc2966">GENERATE_INTERFACE_AND_PROXY</a> magic macros.</p>
<p>For instance, to generate the proxy and the base class for the above file_write_base object, we can write</p>
<div class="fragment"><div class="line"><a class="code" href="group__cppipc.html#ga838dae619459dce33202c1e28ecc2966">GENERATE_INTERFACE_AND_PROXY</a>(file_write_base, file_write_proxy,</div><div class="line">                             (<span class="keywordtype">int</span>, open, (std::string))</div><div class="line">                             (<span class="keywordtype">void</span>, write, (std::string))</div><div class="line">                             (<span class="keywordtype">void</span>, close, )</div><div class="line">                             )</div></div><!-- fragment --><p>This is the recommended way to create proxy and base objects since this allows a collection of interesting functionality to be injected. For instance, this will allow functions to take base pointers as arguments and return base pointers (for instance file_write_base*). On the client side, proxy objects are serialized in a way so that the server side uses the matching implementation instance. When an object is returned, the object is registered on the server side and converted to a new proxy object on the client side. a</p>
<h2>Implementation Details </h2>
<p>Many other details regarding safety when interfaces, or interface argument type modifications are described in the <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a> documentation.</p>
<p>The comm client internally maintains the complete mapping of all member function pointers to strings. The <a class="el" href="classcppipc_1_1object__proxy.html">object_proxy</a> class then has the simple task of just maintaining the object_ids: i.e. what remote object does it connect to.</p>
<p>There is a special "root object" which manages all "special" tasks that operate on the <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a> itself. This root object always has object ID 0 and is the <a class="el" href="classcppipc_1_1object__factory__base.html">object_factory_base</a>. This is implemented on the server side by <a class="el" href="classcppipc_1_1object__factory__impl.html">object_factory_impl</a>, and on the client side as <a class="el" href="classcppipc_1_1object__factory__proxy.html">object_factory_proxy</a>. The <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a> exposes the object_factory functionality as member functions in the <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a> itself. These are <a class="el" href="classcppipc_1_1comm__client.html#a0535adcf8ed155dc240a236b0033d43a">make_object()</a>, <a class="el" href="classcppipc_1_1comm__client.html#a14186bfee377e84680afa2fe69ac836d">ping()</a> and <a class="el" href="classcppipc_1_1comm__client.html#af85b11228c52b8c97b97c029b34fcb8e">delete_object()</a> </p>

<p>Definition at line <a class="el" href="comm__client_8hpp_source.html#l00198">198</a> of file <a class="el" href="comm__client_8hpp_source.html">comm_client.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae649032590d47393ed441bb175dab70c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cppipc::comm_client::comm_client </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>zkhosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_tolerable_ping_failures</em> = <code>(size_t)(-1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>alternate_control_address</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>alternate_publish_address</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>public_key</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>secret_key</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>server_public_key</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ops_interruptible</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a comm client which uses remote communication via zookeeper/zeromq. The client may find the remote server via either zookeeper (in which case zkhosts must be a list of zookeeper servers, and name must be a unique key value), or you can provide the address explicitly. Note that if a server is listening via zookeeper, the client MUST connect via zookeeper; providing the server's actual tcp bind address will not work. And similarly if the server is listening on an explicit zeromq endpoint address and not using zookeeper, the client must connect directly also without using zookeeper.</p>
<p>After construction, authentication methods can be added then <a class="el" href="classcppipc_1_1comm__client.html#a479d8019a70c4932dddf7cb235904737">start()</a> must be called to initiate the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zkhosts</td><td>The zookeeper hosts to connect to. May be empty. If empty, the "name" parameter must be a zeromq endpoint address to bind to. </td></tr>
    <tr><td class="paramname">name</td><td>The key name to connect to. This must match the "name" argument on construction of the remote's <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a>. If zkhosts is empty, this must be a valid zeromq endpoint address. </td></tr>
    <tr><td class="paramname">num_tolerable_ping_failures</td><td>The number of allowable consecutive ping failures before the server is considered dead. </td></tr>
    <tr><td class="paramname">alternate_publish_address</td><td>This should match the "alternate_publish_address" argument on construction of the remote's <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a>. If zkhosts is empty, this must be a valid zeromq endpoint address. This can be empty, in which case the client will ask the server for the appropriate address. It is recommended that this is not specified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a021f0c9432200eb27d37fa4997110b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cppipc::comm_client::comm_client </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>zmq_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an inproc <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a>. The inproc <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a> and <a class="el" href="classcppipc_1_1comm__server.html">comm_server</a> are required to have the same zmq_ctx.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The inproc socket address, must start with inproc:// </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b5118e1afb6c86135a32dc62090e416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cppipc::comm_client::~comm_client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. Calls stop if not already called </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af8560b918adaabdb556e0cb4816b1f06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::add_status_watch </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>watch_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::string)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a callback for server status messages. The callback will receive all messages matching the specified prefix. For instance: </p><div class="fragment"><div class="line">client.add_status_watch(<span class="stringliteral">&quot;A&quot;</span>, callback);</div></div><!-- fragment --><p>will match all the following server messages </p><div class="fragment"><div class="line">server.report_status(<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;hello world&quot;</span>); <span class="comment">// emits A: hello world</span></div><div class="line">server.report_status(<span class="stringliteral">&quot;ABC&quot;</span>, <span class="stringliteral">&quot;hello again&quot;</span>); <span class="comment">// emits ABC: hello again</span></div></div><!-- fragment --><p>On the other hand </p><div class="fragment"><div class="line">client.add_status_watch(<span class="stringliteral">&quot;A:&quot;</span>, callback);</div></div><!-- fragment --><p> will only match the first.</p>
<p>Callbacks should be processed relatively quickly and should be thread safe. Multiple callbacks may be processed simultaneously in different threads. Callback function also should not call <a class="el" href="classcppipc_1_1comm__client.html#af8560b918adaabdb556e0cb4816b1f06">add_status_watch</a> or <a class="el" href="classcppipc_1_1comm__client.html#afebc1f028dbd89f9e51aa94db2ab0ef1">remove_status_watch</a>, or a deadlock may result.</p>
<p>If multiple callbacks are registered for exactly the same prefix, only the last callback is recorded.</p>
<dl class="section note"><dt>Note</dt><dd>The current prefix checking implementation is not fast, and is simply linear in the number of callbacks registered. </dd></dl>

</div>
</div>
<a class="anchor" id="a14535c64a8981a3888b02d9402032ef6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemFn , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::member_function_return_type&lt;MemFn&gt;::type cppipc::comm_client::call </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>objectid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemFn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls a remote function returning the result. The return type is the actual return value. May throw an exception of type reply_status on failure.</p>
<p>NOTE: ONLY the main thread can call this. If this becomes untrue, some invariants will be violated (only one thread is allowed to change the currently running command). </p>

<p>Definition at line <a class="el" href="comm__client_8hpp_source.html#l00586">586</a> of file <a class="el" href="comm__client_8hpp_source.html">comm_client.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5b64ed5d3eeaa365809de54273c5e3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::clear_status_watch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all status callbacks. Note that status callbacks may still be called even after this function returns. To ensure complete removal of the function, <a class="el" href="classcppipc_1_1comm__client.html#a319a8b10941ba2723143be11f919604a">stop_status_callback_thread()</a> and <a class="el" href="classcppipc_1_1comm__client.html#a12552e01d4fd8558d553a690a9415975">start_status_callback_thread()</a> must be called. </p>

</div>
</div>
<a class="anchor" id="af85b11228c52b8c97b97c029b34fcb8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::delete_object </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>objectid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete object. Deletes the object with ID objectid on the remote machine.</p>
<dl class="section note"><dt>Note</dt><dd>This call redirects to the <a class="el" href="classcppipc_1_1object__factory__proxy.html">object_factory_proxy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a33ad94628bcea50b60d2dc3ebf3b4da8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cppipc::comm_client::incr_ref_count </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>object_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Functions for manipulating local reference counting data structure </p>

</div>
</div>
<a class="anchor" id="a5afc6836fd33703ba11498ee7beba01d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::init </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ops_interruptible</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the <a class="el" href="classcppipc_1_1comm__client.html">comm_client</a>, called right inside the constructor. </p>

</div>
</div>
<a class="anchor" id="a0535adcf8ed155dc240a236b0033d43a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cppipc::comm_client::make_object </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>object_type_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an object of a given type on the remote machine. Returns an object ID. If return value is (-1), this is a failure.</p>
<dl class="section note"><dt>Note</dt><dd>This call redirects to the <a class="el" href="classcppipc_1_1object__factory__proxy.html">object_factory_proxy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a14186bfee377e84680afa2fe69ac836d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cppipc::comm_client::ping </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ping test. Sends a string to the remote system, and replies with the same string.</p>
<dl class="section note"><dt>Note</dt><dd>This call redirects to the <a class="el" href="classcppipc_1_1object__factory__proxy.html">object_factory_proxy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6d139c54c3e0653cf72a780ad79e5c9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MemFn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::register_function </td>
          <td>(</td>
          <td class="paramtype">MemFn&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>function_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Registers a member function which then can be used in the <a class="el" href="classcppipc_1_1comm__client.html#a14535c64a8981a3888b02d9402032ef6">call()</a> function </p>

<p>Definition at line <a class="el" href="comm__client_8hpp_source.html#l00544">544</a> of file <a class="el" href="comm__client_8hpp_source.html">comm_client.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afebc1f028dbd89f9e51aa94db2ab0ef1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::remove_status_watch </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>watch_prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a status callback for a given prefix. Note that the function associated with the prefix may still be called even after this function returns. To ensure complete removal of the function, <a class="el" href="classcppipc_1_1comm__client.html#a319a8b10941ba2723143be11f919604a">stop_status_callback_thread()</a> and <a class="el" href="classcppipc_1_1comm__client.html#a12552e01d4fd8558d553a690a9415975">start_status_callback_thread()</a> must be called. </p>

</div>
</div>
<a class="anchor" id="a59cfeadbcfab8940521384b974679566"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cppipc::comm_client::send_deletion_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>object_ids</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to synchronize the list of tracked objects with the server by sending a list of objects to be deleted. Returns 0 on success, -1 on failure. </p>

</div>
</div>
<a class="anchor" id="a718554b58ef28134964464921b88438f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::set_server_alive_watch_pid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a pid to watch. If this pid goes away, server is considered dead. This is a more robust way compared to "pings" for local interprocess communication. Set to 0 to disable. </p>

</div>
</div>
<a class="anchor" id="a479d8019a70c4932dddf7cb235904737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__cppipc.html#ga4b52bfde0818050add61a5338441e087">reply_status</a> cppipc::comm_client::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes connections with the servers Must be called prior to creation of any client objects. Returns <a class="el" href="group__cppipc.html#gga4b52bfde0818050add61a5338441e087ae0aa021e21dddbd6d8cecec71e9cf564" title="Call was successful. ">reply_status::OK</a> on success, and an error code failure. Failure could be caused by an inability to connect to the server, or could also be due to authentication errors. </p>

</div>
</div>
<a class="anchor" id="a12552e01d4fd8558d553a690a9415975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::start_status_callback_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the status callback thread if not already started. </p>

</div>
</div>
<a class="anchor" id="a8d2f8a16abda256b8dd2a1866bb1f91e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::status_callback_thread_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function which implements the thread which issues the messages to the status callback handlers. </p>

</div>
</div>
<a class="anchor" id="ae87be87dc345902e2302057d09739e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops the comm client object. Closes all open sockets </p>

</div>
</div>
<a class="anchor" id="a08982555c67856fc030bf75aca47ec90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::stop_ping_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops the ping thread. </p>

</div>
</div>
<a class="anchor" id="a319a8b10941ba2723143be11f919604a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppipc::comm_client::stop_status_callback_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminates the thread which calls the callback handlers. Unprocessed messages are dropped. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5ba7f6680e949e8c411dff7c9964d0e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::mutex cppipc::comm_client::status_buffer_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The lock / cv pair around the ping_thread_done value </p>

<p>Definition at line <a class="el" href="comm__client_8hpp_source.html#l00451">451</a> of file <a class="el" href="comm__client_8hpp_source.html">comm_client.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a011c0f1fae00cbcc2a890022cdd19609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::thread* cppipc::comm_client::status_callback_thread = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This thread is used to serve the status callbacks. This prevents status callback locks from blocking the server </p>

<p>Definition at line <a class="el" href="comm__client_8hpp_source.html#l00447">447</a> of file <a class="el" href="comm__client_8hpp_source.html">comm_client.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/system/cppipc/client/<a class="el" href="comm__client_8hpp_source.html">comm_client.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecppipc.html">cppipc</a></li><li class="navelem"><a class="el" href="classcppipc_1_1comm__client.html">comm_client</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
