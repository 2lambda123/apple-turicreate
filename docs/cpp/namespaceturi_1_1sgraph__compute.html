<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: turi::sgraph_compute Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceturi_1_1sgraph__compute.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">turi::sgraph_compute Namespace Reference<div class="ingroups"><a class="el" href="group__sgraph__physical.html">SGraph : Physical</a> &raquo; <a class="el" href="group__sgraph__compute.html">SGraph Compute</a><a class="el" href="group__sgraph__physical.html">SGraph : Physical</a> &raquo;  &#124; <a class="el" href="group__sgraph__compute__internal.html">SGraph Compute Internal</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sgraph__compute_1_1edge__scope.html">edge_scope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sgraph__compute_1_1fast__edge__scope.html">fast_edge_scope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sgraph__compute_1_1sgraph__engine.html">sgraph_engine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sgraph__compute_1_1sgraph__synchronize.html">sgraph_synchronize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sgraph__compute_1_1sgraph__synchronize__interface.html">sgraph_synchronize_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sgraph__compute_1_1vertex__block.html">vertex_block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1sgraph__compute_1_1vertex__partition__exchange.html">vertex_partition_exchange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a089fa67e5ad46669ade8355ea4c7a97d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#a089fa67e5ad46669ade8355ea4c7a97d">hilbert_blocked_parallel_for</a> (size_t n, std::function&lt; void(std::vector&lt; std::pair&lt; size_t, size_t &gt; &gt;) &gt; preamble, std::function&lt; void(std::pair&lt; size_t, size_t &gt;)&gt; fn, size_t parallel_limit=<a class="el" href="group__sgraph__main.html#ga3d9472a9f9707e4c406223f64b712a57">SGRAPH_HILBERT_CURVE_PARALLEL_FOR_NUM_THREADS</a>)</td></tr>
<tr class="separator:a089fa67e5ad46669ade8355ea4c7a97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4086b068ded2372c100c5eb2b9eff54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#ad4086b068ded2372c100c5eb2b9eff54">hilbert_parallel_for</a> (size_t n, std::function&lt; void(std::vector&lt; std::pair&lt; size_t, size_t &gt; &gt;) &gt; preamble, std::function&lt; void(std::pair&lt; size_t, size_t &gt;)&gt; fn)</td></tr>
<tr class="separator:ad4086b068ded2372c100c5eb2b9eff54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ced74c64990a169f306893d1b63ea0"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename T &gt; </td></tr>
<tr class="memitem:a33ced74c64990a169f306893d1b63ea0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#a33ced74c64990a169f306893d1b63ea0">edge_apply</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt;&gt;&gt; &amp;other, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> result_type, Fn fn)</td></tr>
<tr class="separator:a33ced74c64990a169f306893d1b63ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea67b2864895aa23104be4db4daa41be"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:aea67b2864895aa23104be4db4daa41be"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#aea67b2864895aa23104be4db4daa41be">edge_apply</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> result_type, Fn fn)</td></tr>
<tr class="separator:aea67b2864895aa23104be4db4daa41be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a741d25f502c12bb93b570100035101"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename T &gt; </td></tr>
<tr class="memitem:a7a741d25f502c12bb93b570100035101"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#a7a741d25f502c12bb93b570100035101">edge_apply</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, std::string column_name, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt;&gt;&gt; &amp;other, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> result_type, Fn fn)</td></tr>
<tr class="separator:a7a741d25f502c12bb93b570100035101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe942ef6cf6619118f9845f9275ad920"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:abe942ef6cf6619118f9845f9275ad920"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#abe942ef6cf6619118f9845f9275ad920">edge_apply</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, std::string column_name, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> result_type, Fn fn)</td></tr>
<tr class="separator:abe942ef6cf6619118f9845f9275ad920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7988bd003262bb4aeea430a0962e5bce"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename Reducer , typename Combiner &gt; </td></tr>
<tr class="memitem:a7988bd003262bb4aeea430a0962e5bce"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_convertible&lt; Reducer, std::string &gt;::value, ResultType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#a7988bd003262bb4aeea430a0962e5bce">edge_reduce</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, Reducer fn, Combiner combine, ResultType init=ResultType())</td></tr>
<tr class="separator:a7988bd003262bb4aeea430a0962e5bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae368949e50fd13e2cbdfc3ffbc9b3acc"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename Reducer , typename Combiner &gt; </td></tr>
<tr class="memitem:ae368949e50fd13e2cbdfc3ffbc9b3acc"><td class="memTemplItemLeft" align="right" valign="top">ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#ae368949e50fd13e2cbdfc3ffbc9b3acc">edge_reduce</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, std::string column_name, Reducer fn, Combiner combine, ResultType init=ResultType())</td></tr>
<tr class="separator:ae368949e50fd13e2cbdfc3ffbc9b3acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1993ce88c48a7329bdda639a0491331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#ab1993ce88c48a7329bdda639a0491331">fast_triple_apply</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, fast_triple_apply_fn_type apply_fn, const std::vector&lt; std::string &gt; &amp;edge_fields, const std::vector&lt; std::string &gt; &amp;mutated_edge_fields)</td></tr>
<tr class="separator:ab1993ce88c48a7329bdda639a0491331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25fac47bd194fa6dd263c2882b381977"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25fac47bd194fa6dd263c2882b381977"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#a25fac47bd194fa6dd263c2882b381977">create_vertex_data</a> (const <a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g)</td></tr>
<tr class="separator:a25fac47bd194fa6dd263c2882b381977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5483eba064ac21a6446f31e4d4bbdf97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#a5483eba064ac21a6446f31e4d4bbdf97">triple_apply</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, triple_apply_fn_type apply_fn, const std::vector&lt; std::string &gt; &amp;mutated_vertex_fields, const std::vector&lt; std::string &gt; &amp;mutated_edge_fields={}, bool requires_vertex_id=true)</td></tr>
<tr class="separator:a5483eba064ac21a6446f31e4d4bbdf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3be22d54bed2301fa4060f41377b1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#afa3be22d54bed2301fa4060f41377b1f">triple_apply</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, batch_triple_apply_fn_type batch_apply_fn, const std::vector&lt; std::string &gt; &amp;mutated_vertex_fields, const std::vector&lt; std::string &gt; &amp;mutated_edge_fields={})</td></tr>
<tr class="separator:afa3be22d54bed2301fa4060f41377b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75274a38f53175c6ab797ca6e9a227ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#a75274a38f53175c6ab797ca6e9a227ef">batch_triple_apply_mock</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, triple_apply_fn_type apply_fn, const std::vector&lt; std::string &gt; &amp;mutated_vertex_fields, const std::vector&lt; std::string &gt; &amp;mutated_edge_fields={})</td></tr>
<tr class="separator:a75274a38f53175c6ab797ca6e9a227ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03eeeef4022c21bda8dda6eef096431"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename T &gt; </td></tr>
<tr class="memitem:ac03eeeef4022c21bda8dda6eef096431"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#ac03eeeef4022c21bda8dda6eef096431">vertex_apply</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt;&gt;&gt; &amp;other, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> result_type, Fn fn)</td></tr>
<tr class="separator:ac03eeeef4022c21bda8dda6eef096431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5417f572483e0fd172e82eefd2f00b2e"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a5417f572483e0fd172e82eefd2f00b2e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#a5417f572483e0fd172e82eefd2f00b2e">vertex_apply</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> result_type, Fn fn)</td></tr>
<tr class="separator:a5417f572483e0fd172e82eefd2f00b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5109c34fb830eec1f5577899e6f2b0c"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename T &gt; </td></tr>
<tr class="memitem:af5109c34fb830eec1f5577899e6f2b0c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#af5109c34fb830eec1f5577899e6f2b0c">vertex_apply</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, std::string column_name, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt;&gt;&gt; &amp;other, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> result_type, Fn fn)</td></tr>
<tr class="separator:af5109c34fb830eec1f5577899e6f2b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655649c985213d07d4ad3752c268bc63"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a655649c985213d07d4ad3752c268bc63"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#a655649c985213d07d4ad3752c268bc63">vertex_apply</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, std::string column_name, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> result_type, Fn fn)</td></tr>
<tr class="separator:a655649c985213d07d4ad3752c268bc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46799b61f368ac6607fb87ad9b8df158"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename Reducer , typename Combiner &gt; </td></tr>
<tr class="memitem:a46799b61f368ac6607fb87ad9b8df158"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_convertible&lt; Reducer, std::string &gt;::value, ResultType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#a46799b61f368ac6607fb87ad9b8df158">vertex_reduce</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, Reducer fn, Combiner combine, ResultType init=ResultType())</td></tr>
<tr class="separator:a46799b61f368ac6607fb87ad9b8df158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e09908743abb981c8ef4672162e225"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename Reducer , typename Combiner &gt; </td></tr>
<tr class="memitem:a14e09908743abb981c8ef4672162e225"><td class="memTemplItemLeft" align="right" valign="top">ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html#a14e09908743abb981c8ef4672162e225">vertex_reduce</a> (<a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, std::string column_name, Reducer fn, Combiner combine, ResultType init=ResultType())</td></tr>
<tr class="separator:a14e09908743abb981c8ef4672162e225"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Graph Computation Functions </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a75274a38f53175c6ab797ca6e9a227ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75274a38f53175c6ab797ca6e9a227ef">&#9670;&nbsp;</a></span>batch_triple_apply_mock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sgraph_compute::batch_triple_apply_mock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">triple_apply_fn_type&#160;</td>
          <td class="paramname"><em>apply_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutated_vertex_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutated_edge_fields</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mock the single triple apply using batch_triple_apply implementation. Used for testing only. </p>

</div>
</div>
<a id="a25fac47bd194fa6dd263c2882b381977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25fac47bd194fa6dd263c2882b381977">&#9670;&nbsp;</a></span>create_vertex_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; turi::sgraph_compute::create_vertex_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function </p>

<p class="definition">Definition at line <a class="el" href="sgraph__fast__triple__apply_8hpp_source.html#l00096">96</a> of file <a class="el" href="sgraph__fast__triple__apply_8hpp_source.html">sgraph_fast_triple_apply.hpp</a>.</p>

</div>
</div>
<a id="a33ced74c64990a169f306893d1b63ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ced74c64990a169f306893d1b63ea0">&#9670;&nbsp;</a></span>edge_apply() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; &gt; turi::sgraph_compute::edge_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>result_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a map operation combining one external array (other) with the graph edge data. other must be the same length as the edge data. Abstractly performs the following computation: </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> edge i:</div><div class="line">  out[i] = fn(edge[i], other[i])</div></div><!-- fragment --><p> out must be of the result_type specified.</p>
<p>The function must take as the first argument, a vector&lt;flexible_type&gt; and the second argument, T, and must return an object castable to a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of the result_type specified.</p>
<p>For instance, if I am going to compute a change in message value between the existing column, and a new computed column:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> msg_idx = g.get_edge_field_id(<span class="stringliteral">&quot;message&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// compute the change in message</span></div><div class="line"><span class="keyword">auto</span> delta = <a class="code" href="namespaceturi_1_1sgraph__compute.html#a33ced74c64990a169f306893d1b63ea0">sgraph_compute::edge_apply</a>(</div><div class="line">    g,</div><div class="line">    new_message,      <span class="comment">// a vector&lt;shared_ptr&lt;sarray&lt;flexible_type&gt;&gt;&gt;</span></div><div class="line">    <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>,</div><div class="line">    [&amp;](<span class="keyword">const</span> std::vector&lt;flexible_type&gt;&amp; edata, <span class="keyword">const</span> flexible_type&amp; y) {</div><div class="line">      <span class="keywordflow">return</span> std::abs((<span class="keywordtype">double</span>)(edata[msg_idx]) - (<span class="keywordtype">double</span>)(y));</div><div class="line">    });</div></div><!-- fragment --><p>Note that if the apply is only going to access one column, the alternative overload will be more efficient. </p>

<p class="definition">Definition at line <a class="el" href="sgraph__edge__apply_8hpp_source.html#l00069">69</a> of file <a class="el" href="sgraph__edge__apply_8hpp_source.html">sgraph_edge_apply.hpp</a>.</p>

</div>
</div>
<a id="aea67b2864895aa23104be4db4daa41be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea67b2864895aa23104be4db4daa41be">&#9670;&nbsp;</a></span>edge_apply() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; &gt; turi::sgraph_compute::edge_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>result_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a map operation on graph edge_data. Abstractly performs the following computation: </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> edge i:</div><div class="line">  out[i] = fn(edge_data[i])</div></div><!-- fragment --><p> out must be of the result_type specified.</p>
<p>The function must take as the only argument, a vector&lt;flexible_type&gt;. and must return an object castable to a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of the result_type specified.</p>
<p>For instance, if I am going to compute a "normalized" sampling vector.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> normalized = <a class="code" href="namespaceturi_1_1sgraph__compute.html#a33ced74c64990a169f306893d1b63ea0">sgraph_compute::edge_apply</a>(</div><div class="line">    g,</div><div class="line">    <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>,</div><div class="line">    [&amp;](std::vector&lt;flexible_type&gt;&amp; edata) {</div><div class="line">      <span class="keywordtype">double</span> sum = 0.0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : edata) sum += v;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; v : edata): v /= sum;</div><div class="line">      <span class="keywordflow">return</span> edata;</div><div class="line">    });</div></div><!-- fragment --><p>Note that if the apply is only going to access one column, the alternative overload will be more efficient. </p>

<p class="definition">Definition at line <a class="el" href="sgraph__edge__apply_8hpp_source.html#l00121">121</a> of file <a class="el" href="sgraph__edge__apply_8hpp_source.html">sgraph_edge_apply.hpp</a>.</p>

</div>
</div>
<a id="a7a741d25f502c12bb93b570100035101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a741d25f502c12bb93b570100035101">&#9670;&nbsp;</a></span>edge_apply() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; &gt; turi::sgraph_compute::edge_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>result_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a map operation combining one external array (other) with one column of the graph edge data. other must be the same length as the edge data. Abstractly performs the following computation: </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> edge i:</div><div class="line">  out[i] = fn(edge_data[column_name][i], other[i])</div></div><!-- fragment --><p> out must be of the result_type specified.</p>
<p>The function must take as the first argument, a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> and the second argument, T, and must return an object castable to a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of the result_type specified.</p>
<p>For instance, if I am going to compute a change in message value between the existing column, and a new computed column:</p>
<div class="fragment"><div class="line"><span class="comment">// compute the change in message</span></div><div class="line"><span class="keyword">auto</span> delta = <a class="code" href="namespaceturi_1_1sgraph__compute.html#a33ced74c64990a169f306893d1b63ea0">sgraph_compute::edge_apply</a>(</div><div class="line">    g,</div><div class="line">    <span class="stringliteral">&quot;message&quot;</span>,</div><div class="line">    new_message,      <span class="comment">// a vector&lt;shared_ptr&lt;sarray&lt;flexible_type&gt;&gt;&gt;</span></div><div class="line">    <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>,</div><div class="line">    [&amp;](<span class="keyword">const</span> flexible_type&amp; edata, <span class="keyword">const</span> flexible_type&amp; y) {</div><div class="line">      <span class="keywordflow">return</span> std::abs((<span class="keywordtype">double</span>)(edata) - (<span class="keywordtype">double</span>)(y));</div><div class="line">    });</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="sgraph__edge__apply_8hpp_source.html#l00171">171</a> of file <a class="el" href="sgraph__edge__apply_8hpp_source.html">sgraph_edge_apply.hpp</a>.</p>

</div>
</div>
<a id="abe942ef6cf6619118f9845f9275ad920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe942ef6cf6619118f9845f9275ad920">&#9670;&nbsp;</a></span>edge_apply() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; &gt; turi::sgraph_compute::edge_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>result_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a map operation on one column of the graph edge_data. Abstractly performs the following computation: </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> edge i:</div><div class="line">  out[i] = fn(edge_data[column_name][i])</div></div><!-- fragment --><p> out must be of the result_type specified.</p>
<p>The function must take as the only argument, a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>. and must return an object castable to a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of the result_type specified.</p>
<p>For instance, if I am going to compute the log of the message column.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> normalized = <a class="code" href="namespaceturi_1_1sgraph__compute.html#a33ced74c64990a169f306893d1b63ea0">sgraph_compute::edge_apply</a>(</div><div class="line">    g,</div><div class="line">    <span class="stringliteral">&quot;message&quot;</span>,</div><div class="line">    <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>,</div><div class="line">    [&amp;](<span class="keyword">const</span> flexible_type&amp; y) {</div><div class="line">      <span class="keywordflow">return</span> log(y);</div><div class="line">    });</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="sgraph__edge__apply_8hpp_source.html#l00220">220</a> of file <a class="el" href="sgraph__edge__apply_8hpp_source.html">sgraph_edge_apply.hpp</a>.</p>

</div>
</div>
<a id="a7988bd003262bb4aeea430a0962e5bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7988bd003262bb4aeea430a0962e5bce">&#9670;&nbsp;</a></span>edge_reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType , typename Reducer , typename Combiner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_convertible&lt;Reducer, std::string&gt;::value, ResultType&gt;::type turi::sgraph_compute::edge_reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reducer&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combiner&#160;</td>
          <td class="paramname"><em>combine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType&#160;</td>
          <td class="paramname"><em>init</em> = <code>ResultType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a reduction over the graph data. If you are only reducing over one column, see the alternative overload.</p>
<p>The edge data is partitioned into small chunks. Within each chunk, the reducer function is called on every element using init as the initial value. This accomplishes a collection of partial reductions. Finally, the combine function is used to merge all the partial reductions which is then returned.</p>
<p>Abstractly performs the following computation: </p><div class="fragment"><div class="line">total_reduction = init</div><div class="line"><span class="keywordflow">for each</span> partition:</div><div class="line">   partial_reduction[partition] = init</div><div class="line">   <span class="keywordflow">for each</span> edge i in partition:</div><div class="line">     reducer(edge_data[i], partial_reduction[partition])</div><div class="line">   combiner(partial_reduction[partition], total_reduction)</div><div class="line"><span class="keywordflow">return</span> total_reduction</div></div><!-- fragment --><p>Example. Here were compute the sum of the triangle_count field of every edge. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> triangle_idx = g.get_edge_field_id(<span class="stringliteral">&quot;triangle_counts&quot;</span>);</div><div class="line">total_triangles =</div><div class="line">      sgraph_compute::reduce&lt;double&gt;(g,</div><div class="line">                             [](<span class="keyword">const</span> std::vector&lt;flexible_type&gt;&amp; edata, <span class="keywordtype">double</span>&amp; acc) {</div><div class="line">                               <span class="comment">// ran on each edge data</span></div><div class="line">                               acc += (<a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>)edata[triangle_idx];</div><div class="line">                             },</div><div class="line">                             [](<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; v, <span class="keywordtype">double</span>&amp; acc) {</div><div class="line">                               <span class="comment">// partial combiner.</span></div><div class="line">                               acc += v;</div><div class="line">                             });</div></div><!-- fragment --><p>Note that if the apply is only going to access one column, the alternative overload will be more efficient. </p>

<p class="definition">Definition at line <a class="el" href="sgraph__edge__apply_8hpp_source.html#l00282">282</a> of file <a class="el" href="sgraph__edge__apply_8hpp_source.html">sgraph_edge_apply.hpp</a>.</p>

</div>
</div>
<a id="ae368949e50fd13e2cbdfc3ffbc9b3acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae368949e50fd13e2cbdfc3ffbc9b3acc">&#9670;&nbsp;</a></span>edge_reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType , typename Reducer , typename Combiner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultType turi::sgraph_compute::edge_reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reducer&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combiner&#160;</td>
          <td class="paramname"><em>combine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType&#160;</td>
          <td class="paramname"><em>init</em> = <code>ResultType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a reduction over a single column of the graph data.</p>
<p>The edge data is partitioned into small chunks. Within each chunk, the reducer function is called on every element using init as the initial value. This accomplishes a collection of partial reductions. Finally, the combine function is used to merge all the partial reductions which is then returned.</p>
<p>Abstractly performs the following computation: </p><div class="fragment"><div class="line">total_reduction = init</div><div class="line"><span class="keywordflow">for each</span> partition:</div><div class="line">   partial_reduction[partition] = init</div><div class="line">   <span class="keywordflow">for each</span> edge i in partition:</div><div class="line">     reducer(edge_data[columnname][i], partial_reduction[partition])</div><div class="line">   combiner(partial_reduction[partition], total_reduction)</div><div class="line"><span class="keywordflow">return</span> total_reduction</div></div><!-- fragment --><p>Example. Here were compute the sum of the triangle field of every edge. </p><div class="fragment"><div class="line">total_triangles =</div><div class="line">      sgraph_compute::reduce&lt;double&gt;(g,</div><div class="line">                             <span class="stringliteral">&quot;triangle&quot;</span>,</div><div class="line">                             [](<span class="keyword">const</span> flexible_type&amp; tr, <span class="keywordtype">double</span>&amp; acc) {</div><div class="line">                               <span class="comment">// ran on each edge data</span></div><div class="line">                               acc += (<a class="code" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a>)tr;</div><div class="line">                             },</div><div class="line">                             [](<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; v, <span class="keywordtype">double</span>&amp; acc) {</div><div class="line">                               <span class="comment">// partial combiner.</span></div><div class="line">                               acc += v;</div><div class="line">                             });</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="sgraph__edge__apply_8hpp_source.html#l00344">344</a> of file <a class="el" href="sgraph__edge__apply_8hpp_source.html">sgraph_edge_apply.hpp</a>.</p>

</div>
</div>
<a id="ab1993ce88c48a7329bdda639a0491331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1993ce88c48a7329bdda639a0491331">&#9670;&nbsp;</a></span>fast_triple_apply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sgraph_compute::fast_triple_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fast_triple_apply_fn_type&#160;</td>
          <td class="paramname"><em>apply_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutated_edge_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A faster and simplified version of triple_apply.</p>
<p>The "faster" assumption is based on that vertex data can be loaded entirey into memory and accessed by the apply function through addressing.</p>
<p>The interface made it possible for vertex data to stay in memory <em>across</em> multiple triple applies before commiting to the disk.</p>
<p>Main interface difference:</p><ol type="1">
<li>Vertex data are provided as vertex address, allowing user to specify their own vertex data storage.</li>
<li>Allowing user to explicitly specify which edge fields are required to read and mutate.</li>
<li>Vertex locking is ommited for simplification. (we can add it later if needed).</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The target graph to perform the transformation. </td></tr>
    <tr><td class="paramname">apply_fn</td><td>The user defined function that will be applied on each edge scope. </td></tr>
    <tr><td class="paramname">vertex_fields</td><td>A subset of vertex data columns that the apply_fn will access. </td></tr>
    <tr><td class="paramname">mutated_vertex_fields</td><td>A subset of columns in vertex_fields that the apply_fn will modify. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a089fa67e5ad46669ade8355ea4c7a97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089fa67e5ad46669ade8355ea4c7a97d">&#9670;&nbsp;</a></span>hilbert_blocked_parallel_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sgraph_compute::hilbert_blocked_parallel_for </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::vector&lt; std::pair&lt; size_t, size_t &gt; &gt;) &gt;&#160;</td>
          <td class="paramname"><em>preamble</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::pair&lt; size_t, size_t &gt;)&gt;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>parallel_limit</em> = <code><a class="el" href="group__sgraph__main.html#ga3d9472a9f9707e4c406223f64b712a57">SGRAPH_HILBERT_CURVE_PARALLEL_FOR_NUM_THREADS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This performs a parallel sweep over an n*n grid following the Hilbert curve ordering. The parallel sweep is broken into two parts. A "preamble" callback which is called sequentially, which contains a list of all the coordinates to be executed in the next pass, and a function which is executed on every coordinate in the pass.</p>
<p>The function abstractly implements the following:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i = 0 to n*n step parallel_limit</div><div class="line">  <span class="comment">// collect all the coordinates to be run in this pass</span></div><div class="line">  std::vector&lt;pair&lt;size_t, size_t&gt; &gt; coordinates</div><div class="line">  <span class="keywordflow">for</span> j = i to min(i + parallel_limit, n*n)</div><div class="line">     coordinates.push_back(convert_hilbert_curve_to_coordinates(j))</div><div class="line">  <span class="comment">// run the preamble</span></div><div class="line">  preamble(coordinates)</div><div class="line"></div><div class="line">  parallel <span class="keywordflow">for</span> over coordinate in coordinates:</div><div class="line">     fn(coordinate)</div></div><!-- fragment --><p>n must be at least 2 and a power of 2. </p>

<p class="definition">Definition at line <a class="el" href="hilbert__parallel__for_8hpp_source.html#l00054">54</a> of file <a class="el" href="hilbert__parallel__for_8hpp_source.html">hilbert_parallel_for.hpp</a>.</p>

</div>
</div>
<a id="ad4086b068ded2372c100c5eb2b9eff54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4086b068ded2372c100c5eb2b9eff54">&#9670;&nbsp;</a></span>hilbert_parallel_for()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sgraph_compute::hilbert_parallel_for </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::vector&lt; std::pair&lt; size_t, size_t &gt; &gt;) &gt;&#160;</td>
          <td class="paramname"><em>preamble</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::pair&lt; size_t, size_t &gt;)&gt;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non blocking version. </p>

<p class="definition">Definition at line <a class="el" href="hilbert__parallel__for_8hpp_source.html#l00073">73</a> of file <a class="el" href="hilbert__parallel__for_8hpp_source.html">hilbert_parallel_for.hpp</a>.</p>

</div>
</div>
<a id="a5483eba064ac21a6446f31e4d4bbdf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5483eba064ac21a6446f31e4d4bbdf97">&#9670;&nbsp;</a></span>triple_apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sgraph_compute::triple_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">triple_apply_fn_type&#160;</td>
          <td class="paramname"><em>apply_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutated_vertex_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutated_edge_fields</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requires_vertex_id</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a transform function on each edge and its associated source and target vertices in parallel. Each edge is visited once and in parallel. The modification to vertex data will be protected by lock.</p>
<p>The effect of the function is equivalent to the following pesudo-code: </p><div class="fragment"><div class="line"><a class="code" href="group__threading.html#gac532f68a1b4c1c4b4d42ffd0fdff2784">parallel_for</a> (edge in g) {</div><div class="line"> lock(edge.source(), edge.target())</div><div class="line"> apply_fn(edge.source().data(), edge.data(), edge.target().data());</div><div class="line"> unlock(edge.source(), edge.target())</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The target graph to perform the transformation. </td></tr>
    <tr><td class="paramname">apply_fn</td><td>The user defined function that will be applied on each edge scope. </td></tr>
    <tr><td class="paramname">mutated_vertex_fields</td><td>A subset of vertex data columns that the apply_fn will modify. </td></tr>
    <tr><td class="paramname">mutated_edge_fields</td><td>A subset of edge data columns that the apply_fn will modify. </td></tr>
    <tr><td class="paramname">requires_vertex_id</td><td>Set to false for optimization when vertex id is not required for triple_apply computation.</td></tr>
  </table>
  </dd>
</dl>
<p>The behavior is undefined when mutated_vertex_fields, and mutated_edge_fields are inconsistent with the apply_fn function. </p>

</div>
</div>
<a id="afa3be22d54bed2301fa4060f41377b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3be22d54bed2301fa4060f41377b1f">&#9670;&nbsp;</a></span>triple_apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sgraph_compute::triple_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">batch_triple_apply_fn_type&#160;</td>
          <td class="paramname"><em>batch_apply_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutated_vertex_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutated_edge_fields</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload. Take the apply function that processes a batch of edges at once. Used for testing the building block of lambda triple apply. </p>

</div>
</div>
<a id="ac03eeeef4022c21bda8dda6eef096431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03eeeef4022c21bda8dda6eef096431">&#9670;&nbsp;</a></span>vertex_apply() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; &gt; turi::sgraph_compute::vertex_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>result_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a map operation combining one external array (other) with the graph vertex data. other must be the same length as the vertex data. Abstractly performs the following computation: </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> vertex i:</div><div class="line">  out[i] = fn(vertex_data[i], other[i])</div></div><!-- fragment --><p> out must be of the result_type specified.</p>
<p>The function must take as the first argument, a vector&lt;flexible_type&gt; and the second argument, T, and must return an object castable to a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of the result_type specified.</p>
<p>For instance, if I am going to compute a change in pagerank value between the existing pagerank column, and a new computed column:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> pr_idx = g.get_vertex_field_id(<span class="stringliteral">&quot;pagerank&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// compute the change in pagerank</span></div><div class="line"><span class="keyword">auto</span> delta = <a class="code" href="namespaceturi_1_1sgraph__compute.html#ac03eeeef4022c21bda8dda6eef096431">sgraph_compute::vertex_apply</a>(</div><div class="line">    g,</div><div class="line">    new_pagerank,      <span class="comment">// a vector&lt;shared_ptr&lt;sarray&lt;flexible_type&gt;&gt;&gt;</span></div><div class="line">    <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>,</div><div class="line">    [&amp;](<span class="keyword">const</span> std::vector&lt;flexible_type&gt;&amp; vdata, <span class="keyword">const</span> flexible_type&amp; y) {</div><div class="line">      <span class="keywordflow">return</span> std::abs((<span class="keywordtype">double</span>)(vdata[pr_idx]) - (<span class="keywordtype">double</span>)(y));</div><div class="line">    });</div></div><!-- fragment --><p>Note that if the apply is only going to access one column, the alternative overload will be more efficient. </p>

<p class="definition">Definition at line <a class="el" href="sgraph__vertex__apply_8hpp_source.html#l00069">69</a> of file <a class="el" href="sgraph__vertex__apply_8hpp_source.html">sgraph_vertex_apply.hpp</a>.</p>

</div>
</div>
<a id="a5417f572483e0fd172e82eefd2f00b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5417f572483e0fd172e82eefd2f00b2e">&#9670;&nbsp;</a></span>vertex_apply() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; &gt; turi::sgraph_compute::vertex_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>result_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a map operation on graph vertex_data. Abstractly performs the following computation: </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> vertex i:</div><div class="line">  out[i] = fn(vertex_data[i])</div></div><!-- fragment --><p> out must be of the result_type specified.</p>
<p>The function must take as the only argument, a vector&lt;flexible_type&gt;. and must return an object castable to a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of the result_type specified.</p>
<p>For instance, if I am going to compute a "normalized" pagerank.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> pagerank_sum = [...from <a class="code" href="group__eager__algorithms.html#gad73eec4b557bb91e92b781c26df159a6">reduce</a> <span class="keyword">function</span> below...]</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> pr_idx = g.get_vertex_field_id(<span class="stringliteral">&quot;pagerank&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> normalized = <a class="code" href="namespaceturi_1_1sgraph__compute.html#ac03eeeef4022c21bda8dda6eef096431">sgraph_compute::vertex_apply</a>(</div><div class="line">    g,</div><div class="line">    <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>,</div><div class="line">    [&amp;](<span class="keyword">const</span> std::vector&lt;flexible_type&gt;&amp; vdata) {</div><div class="line">      <span class="keywordflow">return</span> vdata[pr_idx] / pagerank_sum;</div><div class="line">    });</div></div><!-- fragment --><p>Note that if the apply is only going to access one column, the alternative overload will be more efficient. </p>

<p class="definition">Definition at line <a class="el" href="sgraph__vertex__apply_8hpp_source.html#l00121">121</a> of file <a class="el" href="sgraph__vertex__apply_8hpp_source.html">sgraph_vertex_apply.hpp</a>.</p>

</div>
</div>
<a id="af5109c34fb830eec1f5577899e6f2b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5109c34fb830eec1f5577899e6f2b0c">&#9670;&nbsp;</a></span>vertex_apply() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; &gt; turi::sgraph_compute::vertex_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>result_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a map operation combining one external array (other) with one column of the graph vertex data. other must be the same length as the vertex data. Abstractly performs the following computation: </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> vertex i:</div><div class="line">  out[i] = fn(vertex_data[column_name][i], other[i])</div></div><!-- fragment --><p> out must be of the result_type specified.</p>
<p>The function must take as the first argument, a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> and the second argument, T, and must return an object castable to a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of the result_type specified.</p>
<p>For instance, if I am going to compute a change in pagerank value between the existing pagerank column, and a new computed column:</p>
<div class="fragment"><div class="line"><span class="comment">// compute the change in pagerank</span></div><div class="line"><span class="keyword">auto</span> delta = <a class="code" href="namespaceturi_1_1sgraph__compute.html#ac03eeeef4022c21bda8dda6eef096431">sgraph_compute::vertex_apply</a>(</div><div class="line">    g,</div><div class="line">    <span class="stringliteral">&quot;pagerank&quot;</span>,</div><div class="line">    new_pagerank,      <span class="comment">// a vector&lt;shared_ptr&lt;sarray&lt;flexible_type&gt;&gt;&gt;</span></div><div class="line">    <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>,</div><div class="line">    [&amp;](<span class="keyword">const</span> flexible_type&amp; vdata, <span class="keyword">const</span> flexible_type&amp; y) {</div><div class="line">      <span class="keywordflow">return</span> std::abs((<span class="keywordtype">double</span>)(vdata) - (<span class="keywordtype">double</span>)(y));</div><div class="line">    });</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="sgraph__vertex__apply_8hpp_source.html#l00170">170</a> of file <a class="el" href="sgraph__vertex__apply_8hpp_source.html">sgraph_vertex_apply.hpp</a>.</p>

</div>
</div>
<a id="a655649c985213d07d4ad3752c268bc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655649c985213d07d4ad3752c268bc63">&#9670;&nbsp;</a></span>vertex_apply() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; &gt; turi::sgraph_compute::vertex_apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>result_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a map operation on one column of the graph vertex_data. Abstractly performs the following computation: </p><div class="fragment"><div class="line"><span class="keywordflow">for each</span> vertex i:</div><div class="line">  out[i] = fn(vertex_data[column_name][i])</div></div><!-- fragment --><p> out must be of the result_type specified.</p>
<p>The function must take as the only argument, a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>. and must return an object castable to a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> of the result_type specified.</p>
<p>For instance, if I am going to compute a "normalized" pagerank.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> pagerank_sum = [...from <a class="code" href="group__eager__algorithms.html#gad73eec4b557bb91e92b781c26df159a6">reduce</a> <span class="keyword">function</span> below...]</div><div class="line"></div><div class="line"><span class="keyword">auto</span> normalized = <a class="code" href="namespaceturi_1_1sgraph__compute.html#ac03eeeef4022c21bda8dda6eef096431">sgraph_compute::vertex_apply</a>(</div><div class="line">    g,</div><div class="line">    <span class="stringliteral">&quot;pagerank&quot;</span>,</div><div class="line">    <a class="code" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a>,</div><div class="line">    [&amp;](<span class="keyword">const</span> flexible_type&amp; y) {</div><div class="line">      <span class="keywordflow">return</span> y / pagerank_sum;</div><div class="line">    });</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="sgraph__vertex__apply_8hpp_source.html#l00220">220</a> of file <a class="el" href="sgraph__vertex__apply_8hpp_source.html">sgraph_vertex_apply.hpp</a>.</p>

</div>
</div>
<a id="a46799b61f368ac6607fb87ad9b8df158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46799b61f368ac6607fb87ad9b8df158">&#9670;&nbsp;</a></span>vertex_reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType , typename Reducer , typename Combiner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_convertible&lt;Reducer, std::string&gt;::value, ResultType&gt;::type turi::sgraph_compute::vertex_reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reducer&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combiner&#160;</td>
          <td class="paramname"><em>combine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType&#160;</td>
          <td class="paramname"><em>init</em> = <code>ResultType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a reduction over the graph data. If you are only reducing over one column, see the alternative overload.</p>
<p>The vertex data is partitioned into small chunks. Within each chunk, the reducer function is called on every element using init as the initial value. This accomplishes a collection of partial reductions. Finally, the combine function is used to merge all the partial reductions which is then returned.</p>
<p>Abstractly performs the following computation: </p><div class="fragment"><div class="line">total_reduction = init</div><div class="line"><span class="keywordflow">for each</span> partition:</div><div class="line">   partial_reduction[partition] = init</div><div class="line">   <span class="keywordflow">for each</span> vertex i in partition:</div><div class="line">     reducer(vertex_data[i], partial_reduction[partition])</div><div class="line">   combiner(partial_reduction[partition], total_reduction)</div><div class="line"><span class="keywordflow">return</span> total_reduction</div></div><!-- fragment --><p>Example. Here were compute the sum of the pagerank field of every vertex. </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> pr_idx = g.get_vertex_field_id(<span class="stringliteral">&quot;pagerank&quot;</span>);</div><div class="line">total_pagerank =</div><div class="line">      sgraph_compute::reduce&lt;double&gt;(g,</div><div class="line">                             [](<span class="keyword">const</span> std::vector&lt;flexible_type&gt;&amp; vdata, <span class="keywordtype">double</span>&amp; acc) {</div><div class="line">                               <span class="comment">// ran on each vertex data</span></div><div class="line">                               acc += (<a class="code" href="group__group__flexible__type__types.html#gadcf31f61cc0e0b82bdc9d886fa163e86">flex_float</a>)vdata[pr_idx];</div><div class="line">                             },</div><div class="line">                             [](<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; v, <span class="keywordtype">double</span>&amp; acc) {</div><div class="line">                               <span class="comment">// partial combiner.</span></div><div class="line">                               acc += v;</div><div class="line">                             });</div></div><!-- fragment --><p>Note that if the apply is only going to access one column, the alternative overload will be more efficient. </p>

<p class="definition">Definition at line <a class="el" href="sgraph__vertex__apply_8hpp_source.html#l00281">281</a> of file <a class="el" href="sgraph__vertex__apply_8hpp_source.html">sgraph_vertex_apply.hpp</a>.</p>

</div>
</div>
<a id="a14e09908743abb981c8ef4672162e225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e09908743abb981c8ef4672162e225">&#9670;&nbsp;</a></span>vertex_reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType , typename Reducer , typename Combiner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultType turi::sgraph_compute::vertex_reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>column_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Reducer&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combiner&#160;</td>
          <td class="paramname"><em>combine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType&#160;</td>
          <td class="paramname"><em>init</em> = <code>ResultType()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a reduction over a single column of the graph data.</p>
<p>The vertex data is partitioned into small chunks. Within each chunk, the reducer function is called on every element using init as the initial value. This accomplishes a collection of partial reductions. Finally, the combine function is used to merge all the partial reductions which is then returned.</p>
<p>Abstractly performs the following computation: </p><div class="fragment"><div class="line">total_reduction = init</div><div class="line"><span class="keywordflow">for each</span> partition:</div><div class="line">   partial_reduction[partition] = init</div><div class="line">   <span class="keywordflow">for each</span> vertex i in partition:</div><div class="line">     reducer(vertex_data[columnname][i], partial_reduction[partition])</div><div class="line">   combiner(partial_reduction[partition], total_reduction)</div><div class="line"><span class="keywordflow">return</span> total_reduction</div></div><!-- fragment --><p>Example. Here were compute the sum of the pagerank field of every vertex. </p><div class="fragment"><div class="line">total_pagerank =</div><div class="line">      sgraph_compute::reduce&lt;double&gt;(g,</div><div class="line">                             <span class="stringliteral">&quot;pagerank&quot;</span>,</div><div class="line">                             [](<span class="keyword">const</span> flexible_type&amp; pr, <span class="keywordtype">double</span>&amp; acc) {</div><div class="line">                               <span class="comment">// ran on each vertex data</span></div><div class="line">                               acc += (<a class="code" href="group__group__flexible__type__types.html#gadcf31f61cc0e0b82bdc9d886fa163e86">flex_float</a>)pr;</div><div class="line">                             },</div><div class="line">                             [](<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; v, <span class="keywordtype">double</span>&amp; acc) {</div><div class="line">                               <span class="comment">// partial combiner.</span></div><div class="line">                               acc += v;</div><div class="line">                             });</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="sgraph__vertex__apply_8hpp_source.html#l00342">342</a> of file <a class="el" href="sgraph__vertex__apply_8hpp_source.html">sgraph_vertex_apply.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="namespaceturi_1_1sgraph__compute.html">sgraph_compute</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
