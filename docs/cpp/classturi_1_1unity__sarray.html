<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: turi::unity_sarray Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1unity__sarray.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classturi_1_1unity__sarray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::unity_sarray Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="unity__sarray_8hpp_source.html">core/storage/sframe_interface/unity_sarray.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aed051d43628500b38b0b682588456b79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#aed051d43628500b38b0b682588456b79">unity_sarray</a> ()</td></tr>
<tr class="separator:aed051d43628500b38b0b682588456b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8459aac18c6e8920ce1d66ace34632f9"><td class="memItemLeft" align="right" valign="top"><a id="a8459aac18c6e8920ce1d66ace34632f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a8459aac18c6e8920ce1d66ace34632f9">~unity_sarray</a> ()</td></tr>
<tr class="memdesc:a8459aac18c6e8920ce1d66ace34632f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Deletes all temporary sarray files created. <br /></td></tr>
<tr class="separator:a8459aac18c6e8920ce1d66ace34632f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c0e5dbf37395bfc6b4edbe03aba972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#af1c0e5dbf37395bfc6b4edbe03aba972">construct_from_vector</a> (const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;vec, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type)</td></tr>
<tr class="separator:af1c0e5dbf37395bfc6b4edbe03aba972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe63c5d23ddda423b31987228764cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#aafe63c5d23ddda423b31987228764cb9">construct_from_sarray</a> (std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&gt; s_ptr)</td></tr>
<tr class="separator:aafe63c5d23ddda423b31987228764cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fed9c0c98aae226c07629f80dc6107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a76fed9c0c98aae226c07629f80dc6107">construct_from_const</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;value, size_t <a class="el" href="classturi_1_1unity__sarray.html#a74e62d4b9e3ed62fcd8db92963cc820f">size</a>, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type=<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a0db45d2a4141101bdfe48e3314cfbca3">flex_type_enum::UNDEFINED</a>)</td></tr>
<tr class="separator:a76fed9c0c98aae226c07629f80dc6107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade18ca64eabae923a53e9ec32b332f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#aade18ca64eabae923a53e9ec32b332f0">construct_from_planner_node</a> (std::shared_ptr&lt; <a class="el" href="structturi_1_1query__eval_1_1planner__node.html">query_eval::planner_node</a> &gt; node)</td></tr>
<tr class="separator:aade18ca64eabae923a53e9ec32b332f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cb44063aada3c1df8597ecaebeee88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a88cb44063aada3c1df8597ecaebeee88">construct_from_sarray_index</a> (std::string location)</td></tr>
<tr class="separator:a88cb44063aada3c1df8597ecaebeee88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f913c2b53bc575dfb3ed3bfc45df621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a8f913c2b53bc575dfb3ed3bfc45df621">construct_from_files</a> (std::string url, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type)</td></tr>
<tr class="separator:a8f913c2b53bc575dfb3ed3bfc45df621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191d353e64c2ec69822ebb740df43b21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a191d353e64c2ec69822ebb740df43b21">construct_from_json_record_files</a> (std::string url)</td></tr>
<tr class="separator:a191d353e64c2ec69822ebb740df43b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e0690fb054710fe243a46784055a9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a74e0690fb054710fe243a46784055a9d">construct_from_autodetect</a> (std::string url, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type)</td></tr>
<tr class="separator:a74e0690fb054710fe243a46784055a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add15d2e4e1d36003dab7e6b1a59e50f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#add15d2e4e1d36003dab7e6b1a59e50f6">save_array</a> (std::string target_directory)</td></tr>
<tr class="separator:add15d2e4e1d36003dab7e6b1a59e50f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3141924024afc2b69751b867c9fad5e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a3141924024afc2b69751b867c9fad5e6">save_array_by_index_file</a> (std::string index_file)</td></tr>
<tr class="separator:a3141924024afc2b69751b867c9fad5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c8b8a28be486b59f05f98b8005aff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a67c8b8a28be486b59f05f98b8005aff1">clear</a> ()</td></tr>
<tr class="separator:a67c8b8a28be486b59f05f98b8005aff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e62d4b9e3ed62fcd8db92963cc820f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a74e62d4b9e3ed62fcd8db92963cc820f">size</a> ()</td></tr>
<tr class="separator:a74e62d4b9e3ed62fcd8db92963cc820f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78796115a1b5b56ab868a6f26724934d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a78796115a1b5b56ab868a6f26724934d">has_size</a> ()</td></tr>
<tr class="separator:a78796115a1b5b56ab868a6f26724934d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf7ede30bde37a6e82931eb8f24fb61"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#aeaf7ede30bde37a6e82931eb8f24fb61">get_underlying_sarray</a> ()</td></tr>
<tr class="separator:aeaf7ede30bde37a6e82931eb8f24fb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3420c25e161bb384449ffb0dbca8074f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structturi_1_1query__eval_1_1planner__node.html">query_eval::planner_node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a3420c25e161bb384449ffb0dbca8074f">get_planner_node</a> ()</td></tr>
<tr class="separator:a3420c25e161bb384449ffb0dbca8074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2911746011f5021eb2cfecd1e9f8cfe9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a2911746011f5021eb2cfecd1e9f8cfe9">head</a> (size_t nrows)</td></tr>
<tr class="separator:a2911746011f5021eb2cfecd1e9f8cfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf883c4a50680fb8071bbe8bd1ffb0f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#addf883c4a50680fb8071bbe8bd1ffb0f">_head</a> (size_t nrows)</td></tr>
<tr class="separator:addf883c4a50680fb8071bbe8bd1ffb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b5c414aac24a6e8aae8e3e64a95b2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#af5b5c414aac24a6e8aae8e3e64a95b2a">dtype</a> ()</td></tr>
<tr class="separator:af5b5c414aac24a6e8aae8e3e64a95b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820bac4cdbaf297408e29f3fe26f95d9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a820bac4cdbaf297408e29f3fe26f95d9">transform</a> (const std::string &amp;lambda, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type, bool skip_undefined, uint64_t seed)</td></tr>
<tr class="separator:a820bac4cdbaf297408e29f3fe26f95d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677fb22b47ed4368d501112a581641af"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a677fb22b47ed4368d501112a581641af">transform_native</a> (const <a class="el" href="structturi_1_1function__closure__info.html">function_closure_info</a> &amp;closure, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> type, bool skip_undefined, uint64_t seed)</td></tr>
<tr class="separator:a677fb22b47ed4368d501112a581641af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9596e06303d932855d23f82f485ad02e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a9596e06303d932855d23f82f485ad02e">append</a> (std::shared_ptr&lt; unity_sarray_base &gt; other)</td></tr>
<tr class="separator:a9596e06303d932855d23f82f485ad02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944c504c4b113563a9f7d019f9398136"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a944c504c4b113563a9f7d019f9398136">vector_slice</a> (size_t start, size_t end)</td></tr>
<tr class="separator:a944c504c4b113563a9f7d019f9398136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8635902ba98495d41d415cbb40cf3e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a4b8635902ba98495d41d415cbb40cf3e">filter</a> (const std::string &amp;lambda, bool skip_undefined, uint64_t seed)</td></tr>
<tr class="separator:a4b8635902ba98495d41d415cbb40cf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021c79627ad2eba535744bdf7b678ba1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a021c79627ad2eba535744bdf7b678ba1">logical_filter</a> (std::shared_ptr&lt; unity_sarray_base &gt; index)</td></tr>
<tr class="separator:a021c79627ad2eba535744bdf7b678ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1a94e39e7786ca4e7cd7c79db65bdd"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ade1a94e39e7786ca4e7cd7c79db65bdd">topk_index</a> (size_t k, bool reverse)</td></tr>
<tr class="separator:ade1a94e39e7786ca4e7cd7c79db65bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ad6035553b3ae146ce69f5be5d7274"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a72ad6035553b3ae146ce69f5be5d7274">all</a> ()</td></tr>
<tr class="separator:a72ad6035553b3ae146ce69f5be5d7274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e3325760714ce1da043251bf42fc3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a36e3325760714ce1da043251bf42fc3b">any</a> ()</td></tr>
<tr class="separator:a36e3325760714ce1da043251bf42fc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50692b28cda8e57e6af03acdf2aefb7f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a50692b28cda8e57e6af03acdf2aefb7f">datetime_to_str</a> (std::string format)</td></tr>
<tr class="separator:a50692b28cda8e57e6af03acdf2aefb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34d6f59fa9de7fd22e978248c28ce21"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#aa34d6f59fa9de7fd22e978248c28ce21">str_to_datetime</a> (std::string format)</td></tr>
<tr class="separator:aa34d6f59fa9de7fd22e978248c28ce21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6cabf5825d9de7a71833bb769ce316"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a5f6cabf5825d9de7a71833bb769ce316">astype</a> (<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> <a class="el" href="classturi_1_1unity__sarray.html#af5b5c414aac24a6e8aae8e3e64a95b2a">dtype</a>, bool undefined_on_failure=false)</td></tr>
<tr class="separator:a5f6cabf5825d9de7a71833bb769ce316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936001d8e043cdca6d12d95162acb6d1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a936001d8e043cdca6d12d95162acb6d1">lazy_astype</a> (<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> <a class="el" href="classturi_1_1unity__sarray.html#af5b5c414aac24a6e8aae8e3e64a95b2a">dtype</a>, bool undefined_on_failure=false)</td></tr>
<tr class="separator:a936001d8e043cdca6d12d95162acb6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b16a926378ca24e27d889f98794ff0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a59b16a926378ca24e27d889f98794ff0">clip</a> (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> lower=<a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>(), <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> upper=<a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>())</td></tr>
<tr class="separator:a59b16a926378ca24e27d889f98794ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827f648c316973c9b30c93698b7f29b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a827f648c316973c9b30c93698b7f29b5">max</a> ()</td></tr>
<tr class="separator:a827f648c316973c9b30c93698b7f29b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad257e89c7a8425e09c9c81b4a55076d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ad257e89c7a8425e09c9c81b4a55076d6">min</a> ()</td></tr>
<tr class="separator:ad257e89c7a8425e09c9c81b4a55076d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b5b66db62ce3270b55bab3fda53c55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ab4b5b66db62ce3270b55bab3fda53c55">sum</a> ()</td></tr>
<tr class="separator:ab4b5b66db62ce3270b55bab3fda53c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eca82ad5ed55417a77da0b8d39b0af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ae7eca82ad5ed55417a77da0b8d39b0af">mean</a> ()</td></tr>
<tr class="separator:ae7eca82ad5ed55417a77da0b8d39b0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5e3d0afca10ef0912c23ea2dba03d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a2b5e3d0afca10ef0912c23ea2dba03d4">median</a> (bool approx)</td></tr>
<tr class="separator:a2b5e3d0afca10ef0912c23ea2dba03d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1816a72554d4872bc4a4c72ff67ace90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a1816a72554d4872bc4a4c72ff67ace90">std</a> (size_t ddof=0)</td></tr>
<tr class="separator:a1816a72554d4872bc4a4c72ff67ace90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8275e35d8d2cbd092d5afc7c6df0fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a4e8275e35d8d2cbd092d5afc7c6df0fe">var</a> (size_t ddof=0)</td></tr>
<tr class="separator:a4e8275e35d8d2cbd092d5afc7c6df0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab759b45ff7839fccf9924c3956c32629"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ab759b45ff7839fccf9924c3956c32629">num_missing</a> ()</td></tr>
<tr class="separator:ab759b45ff7839fccf9924c3956c32629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc5025871ec3972714e0eeb7f885d6d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a9cc5025871ec3972714e0eeb7f885d6d">nnz</a> ()</td></tr>
<tr class="separator:a9cc5025871ec3972714e0eeb7f885d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af8c6983e80e13952a5736cc6953f2b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a6af8c6983e80e13952a5736cc6953f2b">left_scalar_operator</a> (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> other, std::string op)</td></tr>
<tr class="separator:a6af8c6983e80e13952a5736cc6953f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f105e10cecd16c253e8314dd6e38d5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ad7f105e10cecd16c253e8314dd6e38d5">right_scalar_operator</a> (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> other, std::string op)</td></tr>
<tr class="separator:ad7f105e10cecd16c253e8314dd6e38d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1b615d9f4c421285aa6e020b47487d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#aac1b615d9f4c421285aa6e020b47487d">vector_operator</a> (std::shared_ptr&lt; unity_sarray_base &gt; other, std::string op)</td></tr>
<tr class="separator:aac1b615d9f4c421285aa6e020b47487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec45b3b0e87f78d20891dbcbe9f26c8d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#aec45b3b0e87f78d20891dbcbe9f26c8d">drop_missing_values</a> ()</td></tr>
<tr class="separator:aec45b3b0e87f78d20891dbcbe9f26c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbe03088f430086e30da3f156c07760"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a4cbe03088f430086e30da3f156c07760">missing_mask</a> (bool recursive=false, bool missing_is_true=true)</td></tr>
<tr class="separator:a4cbe03088f430086e30da3f156c07760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f13d761b2443f904c8438a280047e95"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a6f13d761b2443f904c8438a280047e95">fill_missing_values</a> (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> default_value)</td></tr>
<tr class="separator:a6f13d761b2443f904c8438a280047e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f2c94aeee519fc925ddeaeab2bf2dc"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a91f2c94aeee519fc925ddeaeab2bf2dc">tail</a> (size_t nrows=10)</td></tr>
<tr class="separator:a91f2c94aeee519fc925ddeaeab2bf2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16495d5e11e3e5c04585557515fcc35d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a16495d5e11e3e5c04585557515fcc35d">sample</a> (float percent, uint64_t random_seed, bool exact=false)</td></tr>
<tr class="separator:a16495d5e11e3e5c04585557515fcc35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a52968b57bd7efc28a6371f9b0a636c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a6a52968b57bd7efc28a6371f9b0a636c">hash</a> (uint64_t seed)</td></tr>
<tr class="separator:a6a52968b57bd7efc28a6371f9b0a636c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30972073ec79a42bdd9b4b302e57aefa"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a30972073ec79a42bdd9b4b302e57aefa">count_bag_of_words</a> (std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; options)</td></tr>
<tr class="separator:a30972073ec79a42bdd9b4b302e57aefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc7a9710d48ad60ff032bbdbbc157f8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a8dc7a9710d48ad60ff032bbdbbc157f8">count_character_ngrams</a> (size_t n, std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; options)</td></tr>
<tr class="separator:a8dc7a9710d48ad60ff032bbdbbc157f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0649e74c99b2b2725c11040264aa9a9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ad0649e74c99b2b2725c11040264aa9a9">count_ngrams</a> (size_t n, std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; options)</td></tr>
<tr class="separator:ad0649e74c99b2b2725c11040264aa9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacd6a49d0586a89a9cd422fef18fc11"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#abacd6a49d0586a89a9cd422fef18fc11">dict_trim_by_keys</a> (const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;<a class="el" href="group__set__and__map.html#ga918b8235a3af13f02053fdf76c17ae83">keys</a>, bool exclude)</td></tr>
<tr class="separator:abacd6a49d0586a89a9cd422fef18fc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d333be1893ff1270f6a947d20bca68"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ad3d333be1893ff1270f6a947d20bca68">dict_trim_by_values</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;lower, const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;upper)</td></tr>
<tr class="separator:ad3d333be1893ff1270f6a947d20bca68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5135a72c56704047f53df72f4bd43ee2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a5135a72c56704047f53df72f4bd43ee2">dict_keys</a> ()</td></tr>
<tr class="separator:a5135a72c56704047f53df72f4bd43ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc228db3e110272cc5d5e845624cbfd1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#afc228db3e110272cc5d5e845624cbfd1">dict_values</a> ()</td></tr>
<tr class="separator:afc228db3e110272cc5d5e845624cbfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ea7a641aa66e730fe11fe5779610ae"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a95ea7a641aa66e730fe11fe5779610ae">dict_has_any_keys</a> (const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;<a class="el" href="group__set__and__map.html#ga918b8235a3af13f02053fdf76c17ae83">keys</a>)</td></tr>
<tr class="separator:a95ea7a641aa66e730fe11fe5779610ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b6b363823ab9dcd501f57083f627d1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a81b6b363823ab9dcd501f57083f627d1">dict_has_all_keys</a> (const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;<a class="el" href="group__set__and__map.html#ga918b8235a3af13f02053fdf76c17ae83">keys</a>)</td></tr>
<tr class="separator:a81b6b363823ab9dcd501f57083f627d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65021dc9c7edc05988bc51585765797"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ae65021dc9c7edc05988bc51585765797">item_length</a> ()</td></tr>
<tr class="separator:ae65021dc9c7edc05988bc51585765797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990992c57e2c21554d2917948b09d23e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a990992c57e2c21554d2917948b09d23e">expand</a> (const std::string &amp;column_name_prefix, const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;expanded_column_elements, const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;expanded_columns_types)</td></tr>
<tr class="separator:a990992c57e2c21554d2917948b09d23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8dd4e91f234e19c182ff99db6a63829"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#af8dd4e91f234e19c182ff99db6a63829">unpack</a> (const std::string &amp;column_name_prefix, const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;unpacked_keys, const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;unpacked_columns_types, const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;na_value)</td></tr>
<tr class="separator:af8dd4e91f234e19c182ff99db6a63829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e46e89c2f9c4efbdc5b1aec9c047dd"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sframe_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#aa3e46e89c2f9c4efbdc5b1aec9c047dd">unpack_dict</a> (const std::string &amp;column_name_prefix, const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;limit, const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;na_value)</td></tr>
<tr class="separator:aa3e46e89c2f9c4efbdc5b1aec9c047dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b55521a9c6e634f5bd5e84bfced261b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a6b55521a9c6e634f5bd5e84bfced261b">subslice</a> (<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> start, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> step, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> stop)</td></tr>
<tr class="separator:a6b55521a9c6e634f5bd5e84bfced261b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc77e6534d8d370374e4bae9f99fc1c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a4dc77e6534d8d370374e4bae9f99fc1c">ternary_operator</a> (std::shared_ptr&lt; unity_sarray_base &gt; is_true, std::shared_ptr&lt; unity_sarray_base &gt; is_false)</td></tr>
<tr class="separator:a4dc77e6534d8d370374e4bae9f99fc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20106a1f4cd9d4e9674f668c971d6d59"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a20106a1f4cd9d4e9674f668c971d6d59">to_const</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;value, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> <a class="el" href="classturi_1_1unity__sarray.html#af5b5c414aac24a6e8aae8e3e64a95b2a">dtype</a>)</td></tr>
<tr class="separator:a20106a1f4cd9d4e9674f668c971d6d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dd5d7abb82e8918b29ad2eed553f98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ae7dd5d7abb82e8918b29ad2eed553f98">begin_iterator</a> ()</td></tr>
<tr class="separator:ae7dd5d7abb82e8918b29ad2eed553f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ba5c91b4a6e1f14c42513ada02acd2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ab1ba5c91b4a6e1f14c42513ada02acd2">iterator_get_next</a> (size_t len)</td></tr>
<tr class="separator:ab1ba5c91b4a6e1f14c42513ada02acd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994dd1a0fbdd0264db610f9de009e701"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a994dd1a0fbdd0264db610f9de009e701">to_vector</a> ()</td></tr>
<tr class="separator:a994dd1a0fbdd0264db610f9de009e701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281241fc5573044feb6955a430992572"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a281241fc5573044feb6955a430992572">materialize</a> ()</td></tr>
<tr class="separator:a281241fc5573044feb6955a430992572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661687ec20b4834090abafe7e59540c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a661687ec20b4834090abafe7e59540c8">is_materialized</a> ()</td></tr>
<tr class="separator:a661687ec20b4834090abafe7e59540c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8233720d1f31da16c530c01e89dbdc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#add8233720d1f31da16c530c01e89dbdc">get_content_identifier</a> ()</td></tr>
<tr class="separator:add8233720d1f31da16c530c01e89dbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cbeb1754e74389df2202108d793833"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a88cbeb1754e74389df2202108d793833">copy_range</a> (size_t start, size_t step, size_t end)</td></tr>
<tr class="separator:a88cbeb1754e74389df2202108d793833"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4e470c1783849077e2cab28b406eaf5b"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a4e470c1783849077e2cab28b406eaf5b">make_uniform_boolean_array</a> (size_t <a class="el" href="classturi_1_1unity__sarray.html#a74e62d4b9e3ed62fcd8db92963cc820f">size</a>, float percent, uint64_t random_seed, bool exact=false)</td></tr>
<tr class="separator:a4e470c1783849077e2cab28b406eaf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad999f05e4bb5296907e4f561f7ca42f1"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#ad999f05e4bb5296907e4f561f7ca42f1">make_exact_uniform_boolean_array</a> (size_t <a class="el" href="classturi_1_1unity__sarray.html#a74e62d4b9e3ed62fcd8db92963cc820f">size</a>, size_t num_trues, uint64_t random_seed)</td></tr>
<tr class="separator:ad999f05e4bb5296907e4f561f7ca42f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb3d0ef2ce1dad469e13398e044db1c"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html#a0fb3d0ef2ce1dad469e13398e044db1c">make_uniform_int_array</a> (size_t <a class="el" href="classturi_1_1unity__sarray.html#a74e62d4b9e3ed62fcd8db92963cc820f">size</a>, size_t max_int)</td></tr>
<tr class="separator:a0fb3d0ef2ce1dad469e13398e044db1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the SArray object exposed to Python. Abstractly, it stores a single column of a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>. An Sarray represents a single immutable column: i.e. once created, it cannot be modified.</p>
<p>Internally, it is represented as a single shared_ptr to an "sarray&lt;flexible_type&gt;" sarray object. We delay construction of the internal sarray object until a "construct" call is made. This allows the class to be used in the following way:</p>
<div class="fragment"><div class="line"><a class="code" href="classturi_1_1unity__sarray.html#aed051d43628500b38b0b682588456b79">unity_sarray</a> array;</div><div class="line"><span class="comment">// creates the array</span></div><div class="line">array.construct(...);</div><div class="line"><span class="comment">// now the array is immutable.</span></div></div><!-- fragment --><p>Multiple different construct functions can then be used to create sarrays from different sources: some sources may require the sarray to download files, etc.</p>
<p>The SArray may require temporary on disk storage which will be deleted when the SArray is deleted. The temporary file names are obtained from <a class="el" href="group__fileio.html#ga49a7014c73f094ce56bb700d684fd08d">turi::get_temp_name</a> </p>

<p class="definition">Definition at line <a class="el" href="unity__sarray_8hpp_source.html#l00054">54</a> of file <a class="el" href="unity__sarray_8hpp_source.html">unity_sarray.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aed051d43628500b38b0b682588456b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed051d43628500b38b0b682588456b79">&#9670;&nbsp;</a></span>unity_sarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">turi::unity_sarray::unity_sarray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default Constructor. Does nothing basically. Use one of the construct_from_* functions to construct the contents of the SArray. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="addf883c4a50680fb8071bbe8bd1ffb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf883c4a50680fb8071bbe8bd1ffb0f">&#9670;&nbsp;</a></span>_head()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; turi::unity_sarray::_head </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as head, return vector&lt;flexible_type&gt;, used for testing. </p>

<p class="definition">Definition at line <a class="el" href="unity__sarray_8hpp_source.html#l00182">182</a> of file <a class="el" href="unity__sarray_8hpp_source.html">unity_sarray.hpp</a>.</p>

</div>
</div>
<a id="a72ad6035553b3ae146ce69f5be5d7274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ad6035553b3ae146ce69f5be5d7274">&#9670;&nbsp;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::unity_sarray::all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if all the values in the sarray are non-zero / non-empty. An empty array returns true. </p>

</div>
</div>
<a id="a36e3325760714ce1da043251bf42fc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e3325760714ce1da043251bf42fc3b">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::unity_sarray::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if any value in the sarray is non-zero / non-empty. An empty array returns false. </p>

</div>
</div>
<a id="a9596e06303d932855d23f82f485ad02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9596e06303d932855d23f82f485ad02e">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::append </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append all rows from "other" sarray to "this" sarray and returns a new sarray that contains all rows from both sarrays </p>

</div>
</div>
<a id="a5f6cabf5825d9de7a71833bb769ce316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6cabf5825d9de7a71833bb769ce316">&#9670;&nbsp;</a></span>astype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::astype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>undefined_on_failure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new SArray with the same values as current one, but casted to the given type.</p>
<p>If undefined_on_failure is set, cast failures do not cause errors, but become undefined values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1unity__sarray.html#a936001d8e043cdca6d12d95162acb6d1">lazy_astype</a> </dd></dl>

</div>
</div>
<a id="ae7dd5d7abb82e8918b29ad2eed553f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7dd5d7abb82e8918b29ad2eed553f98">&#9670;&nbsp;</a></span>begin_iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::begin_iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begin iteration through the SArray.</p>
<p>Works together with <a class="el" href="classturi_1_1unity__sarray.html#ab1ba5c91b4a6e1f14c42513ada02acd2">iterator_get_next()</a>. The usage pattern is as follows: </p><div class="fragment"><div class="line">array.begin_iterator();</div><div class="line"><span class="keywordflow">while</span>(1) {</div><div class="line">  <span class="keyword">auto</span> ret = array.iterator_get_next(64);</div><div class="line">  <span class="comment">// do stuff</span></div><div class="line">  <span class="keywordflow">if</span> (ret.size() &lt; 64) {</div><div class="line">    <span class="comment">// we are done</span></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Note that use of pretty much any of the other data-dependent SArray functions will invalidate the iterator. </p>

</div>
</div>
<a id="a67c8b8a28be486b59f05f98b8005aff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c8b8a28be486b59f05f98b8005aff1">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the contents of the SArray, deleting all temporary files if any. </p>

</div>
</div>
<a id="a59b16a926378ca24e27d889f98794ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b16a926378ca24e27d889f98794ff0">&#9670;&nbsp;</a></span>clip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::clip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td>
          <td class="paramname"><em>lower</em> = <code><a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td>
          <td class="paramname"><em>upper</em> = <code><a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new SArray with the same values as the current one, except any values above or below the given bounds are changed to be equal to the bound.</p>
<p>If lower or upper are given a flex_undefined(), this is interpreted to mean that there is no bound there. For example, clip(flex_undefined(), 25) clips with no lower bound and an upper bound of 25. </p>

</div>
</div>
<a id="a74e0690fb054710fe243a46784055a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e0690fb054710fe243a46784055a9d">&#9670;&nbsp;</a></span>construct_from_autodetect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::construct_from_autodetect </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a URL, this function attempts to autodetect if it should</p><ul>
<li>treat it as a .sidx file and load an SArray from it (construct_from_sarray_index)</li>
<li>treat it as a file to read line by line (construct_from_files)</li>
<li>treat it as a directory and load an SArray from it (construct_from_sarray_index) </li>
</ul>

</div>
</div>
<a id="a76fed9c0c98aae226c07629f80dc6107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fed9c0c98aae226c07629f80dc6107">&#9670;&nbsp;</a></span>construct_from_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::construct_from_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a0db45d2a4141101bdfe48e3314cfbca3">flex_type_enum::UNDEFINED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classturi_1_1unity__sarray.html">unity_sarray</a> from a const value. </p>

</div>
</div>
<a id="a8f913c2b53bc575dfb3ed3bfc45df621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f913c2b53bc575dfb3ed3bfc45df621">&#9670;&nbsp;</a></span>construct_from_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::construct_from_files </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an Sarray from a url. Each line of the file will be a row in the resultant SArray, and each row will be of string type. If the current object is already storing an array, it is cleared (<a class="el" href="classturi_1_1unity__sarray.html#a67c8b8a28be486b59f05f98b8005aff1">clear()</a>).May throw an exception on failure. If an exception occurs, the contents of SArray is empty. </p>

</div>
</div>
<a id="a191d353e64c2ec69822ebb740df43b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191d353e64c2ec69822ebb740df43b21">&#9670;&nbsp;</a></span>construct_from_json_record_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::construct_from_json_record_files </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an SArray from one or more json record files.</p>
<p>Each json record file contains an array of dictionaries. Resultant SArray is of dictionary type. </p>

</div>
</div>
<a id="aade18ca64eabae923a53e9ec32b332f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade18ca64eabae923a53e9ec32b332f0">&#9670;&nbsp;</a></span>construct_from_planner_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::construct_from_planner_node </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structturi_1_1query__eval_1_1planner__node.html">query_eval::planner_node</a> &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classturi_1_1unity__sarray.html">unity_sarray</a> from a parallel iterator generator. </p>

</div>
</div>
<a id="aafe63c5d23ddda423b31987228764cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe63c5d23ddda423b31987228764cb9">&#9670;&nbsp;</a></span>construct_from_sarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::construct_from_sarray </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>s_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a <a class="el" href="classturi_1_1unity__sarray.html">unity_sarray</a> from an existing sarray. This simply sets this class's shared_ptr to the one given by the parameter. </p>

</div>
</div>
<a id="a88cb44063aada3c1df8597ecaebeee88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cb44063aada3c1df8597ecaebeee88">&#9670;&nbsp;</a></span>construct_from_sarray_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::construct_from_sarray_index </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>location</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an Sarray from an existing directory on disk saved with <a class="el" href="classturi_1_1unity__sarray.html#add15d2e4e1d36003dab7e6b1a59e50f6">save_array()</a> or a on disk sarray prefix (saved with <a class="el" href="classturi_1_1unity__sarray.html#a3141924024afc2b69751b867c9fad5e6">save_array_by_index_file()</a>). This function will automatically detect if the location is a directory, or a file. The files will not be deleted on destruction. If the current object is already storing an array, it is cleared (<a class="el" href="classturi_1_1unity__sarray.html#a67c8b8a28be486b59f05f98b8005aff1">clear()</a>). May throw an exception on failure. If an exception occurs, the contents of SArray is empty. </p>

</div>
</div>
<a id="af1c0e5dbf37395bfc6b4edbe03aba972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c0e5dbf37395bfc6b4edbe03aba972">&#9670;&nbsp;</a></span>construct_from_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::construct_from_vector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an Sarray from an in memory vector. If the current object is already storing an array, it is cleared (<a class="el" href="classturi_1_1unity__sarray.html#a67c8b8a28be486b59f05f98b8005aff1">clear()</a>).May throw an exception on failure. If an exception occurs, the contents of SArray is empty. </p>

</div>
</div>
<a id="a88cbeb1754e74389df2202108d793833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cbeb1754e74389df2202108d793833">&#9670;&nbsp;</a></span>copy_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::copy_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts a range of rows from an SArray as a new SArray. This will extract rows beginning at start (inclusive) and ending at end(exclusive) in steps of "step". step must be at least 1. </p>

</div>
</div>
<a id="a30972073ec79a42bdd9b4b302e57aefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30972073ec79a42bdd9b4b302e57aefa">&#9670;&nbsp;</a></span>count_bag_of_words()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::count_bag_of_words </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a word-count for each element in the SArray and return a SArray of dictionary </p>

</div>
</div>
<a id="a8dc7a9710d48ad60ff032bbdbbc157f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc7a9710d48ad60ff032bbdbbc157f8">&#9670;&nbsp;</a></span>count_character_ngrams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::count_character_ngrams </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a character n-gram count for each element in the SArray and return a SArray of dictionary type. Parameter n is the number or charachters in each n-gram options takes: to_lower, which makes words lower case ignore_space, which ignores spaces in calculating charachter n-grams </p>

</div>
</div>
<a id="ad0649e74c99b2b2725c11040264aa9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0649e74c99b2b2725c11040264aa9a9">&#9670;&nbsp;</a></span>count_ngrams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::count_ngrams </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a character n-gram count for each element in the SArray and return a SArray of dictionary type. Parameter n is the number of words in each n-gram options takes: to_lower, which makes words lower case </p>

</div>
</div>
<a id="a50692b28cda8e57e6af03acdf2aefb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50692b28cda8e57e6af03acdf2aefb7f">&#9670;&nbsp;</a></span>datetime_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::datetime_to_str </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new SArray with the datetime values casted to string.</p>
<p>"format" determines the string format for the output SArray. </p>

</div>
</div>
<a id="a81b6b363823ab9dcd501f57083f627d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b6b363823ab9dcd501f57083f627d1">&#9670;&nbsp;</a></span>dict_has_all_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::dict_has_all_keys </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If SArray dtype is dict, returns a new SArray which contains integer of 1s or 0s with 1 means the original array element has all keys in the param otherwise throws exception </p>

</div>
</div>
<a id="a95ea7a641aa66e730fe11fe5779610ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ea7a641aa66e730fe11fe5779610ae">&#9670;&nbsp;</a></span>dict_has_any_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::dict_has_any_keys </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If SArray dtype is dict, returns a new SArray which contains integer of 1s or 0s with 1 means the original array element has at least one key in the param otherwise throws exception </p>

</div>
</div>
<a id="a5135a72c56704047f53df72f4bd43ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5135a72c56704047f53df72f4bd43ee2">&#9670;&nbsp;</a></span>dict_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::dict_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If SArray dtype is dict, returns a new SArray which contains keys for input dictionary otherwise throws exception </p>

</div>
</div>
<a id="abacd6a49d0586a89a9cd422fef18fc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacd6a49d0586a89a9cd422fef18fc11">&#9670;&nbsp;</a></span>dict_trim_by_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::dict_trim_by_keys </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If SArray dtype is dict, filter out each dict by the given keys. If exclude is True, then all keys that are in the input key list are removed If exclude is False, then only keys that are in the input key list are retained </p>

</div>
</div>
<a id="ad3d333be1893ff1270f6a947d20bca68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d333be1893ff1270f6a947d20bca68">&#9670;&nbsp;</a></span>dict_trim_by_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::dict_trim_by_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If SArray dtype is dict, filter out each dict by the given value boundary. all items whose value is not in the low/up bound are removed from the dictionary The boundary are included. I.e, if a value is either lower or upper bound, then the key/value pair is included in the result This function will fail if the value is not comparable </p>

</div>
</div>
<a id="afc228db3e110272cc5d5e845624cbfd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc228db3e110272cc5d5e845624cbfd1">&#9670;&nbsp;</a></span>dict_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::dict_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If SArray dtype is dict, returns a new SArray which contains values for input dictionary otherwise throws exception </p>

</div>
</div>
<a id="aec45b3b0e87f78d20891dbcbe9f26c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec45b3b0e87f78d20891dbcbe9f26c8d">&#9670;&nbsp;</a></span>drop_missing_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::drop_missing_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new array with all UNDEFINED values removed. A new array is returned with the same type as the current array, but potentially shorter. If the array has no missing values, the output array has the same length and the same segment structure as this array. </p>

</div>
</div>
<a id="af5b5c414aac24a6e8aae8e3e64a95b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b5c414aac24a6e8aae8e3e64a95b2a">&#9670;&nbsp;</a></span>dtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> turi::unity_sarray::dtype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type name of the SArray </p>

</div>
</div>
<a id="a990992c57e2c21554d2917948b09d23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990992c57e2c21554d2917948b09d23e">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sarray::expand </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expanded_column_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expanded_columns_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand an SArray of datetime type to a set of new columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_name_prefix</td><td>prefix for the expanded column name </td></tr>
    <tr><td class="paramname">expanded_column_elements</td><td>a list including the elements to expand from the datetime column. Elements could be 'year','month','day' 'hour','minute','second', and 'timezone'. </td></tr>
    <tr><td class="paramname">expanded_columns_types</td><td>list of types for the expanded columns</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a new SFrame that contains the expanded columns </p>

</div>
</div>
<a id="a6f13d761b2443f904c8438a280047e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f13d761b2443f904c8438a280047e95">&#9670;&nbsp;</a></span>fill_missing_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::fill_missing_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td>
          <td class="paramname"><em>default_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new array with all UNDEFINED values replaced with the given value.</p>
<p>Throws if the given value is not convertible to the SArray's type. </p>

</div>
</div>
<a id="a4b8635902ba98495d41d415cbb40cf3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8635902ba98495d41d415cbb40cf3e">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::filter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_undefined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new SArray which is filtered to by the given lambda function. If the lambda evaluates an element to true, this element is copied to the new SArray. If not, it isn't. Throws an exception if the return type of the lambda is not castable to a boolean value. </p>

</div>
</div>
<a id="add8233720d1f31da16c530c01e89dbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8233720d1f31da16c530c01e89dbdc">&#9670;&nbsp;</a></span>get_content_identifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::unity_sarray::get_content_identifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an integer which attempts to uniquely identifies the contents of the SArray.</p>
<p>This is not generally guaranteed to be actually a unique identifier for the data contents. It certainly tries to be, but both false positives and false negatives can be possible. It tries <em>really</em> hard to avoid false positives though.</p>
<p>If the array is lazy, it returns a random number. If the array is materialized, it returns a hash of the file names and row sizes that make up the array. </p>

</div>
</div>
<a id="a3420c25e161bb384449ffb0dbca8074f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3420c25e161bb384449ffb0dbca8074f">&#9670;&nbsp;</a></span>get_planner_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structturi_1_1query__eval_1_1planner__node.html">query_eval::planner_node</a>&gt; turi::unity_sarray::get_planner_node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the underlying planner pointer </p>

</div>
</div>
<a id="aeaf7ede30bde37a6e82931eb8f24fb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf7ede30bde37a6e82931eb8f24fb61">&#9670;&nbsp;</a></span>get_underlying_sarray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; &gt; turi::unity_sarray::get_underlying_sarray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the underlying sarray pointer. TODO: will slowly move away all users of this function to get_lazy_sarray </p>

</div>
</div>
<a id="a78796115a1b5b56ab868a6f26724934d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78796115a1b5b56ab868a6f26724934d">&#9670;&nbsp;</a></span>has_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::unity_sarray::has_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if size is obtainable efficiently. </p>

</div>
</div>
<a id="a6a52968b57bd7efc28a6371f9b0a636c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a52968b57bd7efc28a6371f9b0a636c">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::hash </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an SArray of type flex_int that contains the hash of each element. The hash function takes a seed value so this can be used for random generation as well. </p>

</div>
</div>
<a id="a2911746011f5021eb2cfecd1e9f8cfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2911746011f5021eb2cfecd1e9f8cfe9">&#9670;&nbsp;</a></span>head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::head </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns some number of rows of the SArray</p>
<p>NOTE: If there are more elements asked for than can fit into memory, this makes no attempt to stop crashing your computer. </p>

</div>
</div>
<a id="a661687ec20b4834090abafe7e59540c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661687ec20b4834090abafe7e59540c8">&#9670;&nbsp;</a></span>is_materialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::unity_sarray::is_materialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>test hook to check if the array is materialized </p>

</div>
</div>
<a id="ae65021dc9c7edc05988bc51585765797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65021dc9c7edc05988bc51585765797">&#9670;&nbsp;</a></span>item_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::item_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new SArray that contains elements that are the length of each item in input SArray. This function only works on SArray of type vector, list and dict. It is equivalent to the following python work sa_ret = sa.apply(lambda x: len(x)) </p>

</div>
</div>
<a id="ab1ba5c91b4a6e1f14c42513ada02acd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ba5c91b4a6e1f14c42513ada02acd2">&#9670;&nbsp;</a></span>iterator_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; turi::unity_sarray::iterator_get_next </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the next block of elements of size len from the SFrame. Works together with <a class="el" href="classturi_1_1unity__sarray.html#ae7dd5d7abb82e8918b29ad2eed553f98">begin_iterator()</a>. See the code example in <a class="el" href="classturi_1_1unity__sarray.html#ae7dd5d7abb82e8918b29ad2eed553f98">begin_iterator()</a> for details.</p>
<p>This function will always return a vector of length 'len' unless at the end of the array, or if an error has occured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>The number of elements to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next collection of elements in the array. Returns less then len elements on end of file or failure. </dd></dl>

</div>
</div>
<a id="a936001d8e043cdca6d12d95162acb6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936001d8e043cdca6d12d95162acb6d1">&#9670;&nbsp;</a></span>lazy_astype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::lazy_astype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>undefined_on_failure</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new SArray with the same values as current one, but casted to the given type. Performed lazily.</p>
<p>If undefined_on_failure is set, cast failures do not cause errors, but become undefined values. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classturi_1_1unity__sarray.html#a5f6cabf5825d9de7a71833bb769ce316">astype</a> </dd></dl>

</div>
</div>
<a id="a6af8c6983e80e13952a5736cc6953f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af8c6983e80e13952a5736cc6953f2b">&#9670;&nbsp;</a></span>left_scalar_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::left_scalar_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the equivalent of array [op] other , where other is a scalar value. The operation must be one of the following: "+", "-", "*", "/", "&lt;", "&gt;", "&lt;=", "&gt;=", "==", "!=",'','in'. The type of the new array is dependent on the semantics of the operation.</p><ul>
<li>comparison operators always return integers</li>
<li>+,-,* of integer against integers always return integers</li>
<li>/ of integer against integer always returns floats</li>
<li>+,-,*,/ of floats against floats always return floats</li>
<li>+,-,*,/ of integer against floats or floats against integers always return floats.</li>
<li>%. integer against integers -&gt; integers</li>
<li>"in". must be string against string, and returns a boolean.</li>
</ul>
<p>This function throws a string exception if there is a type mismatch ( for instance you cannot add a string value to an integer array), or if the operation is invalid.</p>
<p>UNDEFINED values in the array are ignored.</p>
<p>On success, a new array is returned. The new array is the same length and has the same segment structure. </p>

</div>
</div>
<a id="a021c79627ad2eba535744bdf7b678ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021c79627ad2eba535744bdf7b678ba1">&#9670;&nbsp;</a></span>logical_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::logical_filter </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new SArray which is filtered by a given logical column. The index array must be the same length as the current array. An output array is returned containing only the elements in the current where are the corresponding element in the index array evaluates to true. </p>

</div>
</div>
<a id="ad999f05e4bb5296907e4f561f7ca42f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad999f05e4bb5296907e4f561f7ca42f1">&#9670;&nbsp;</a></span>make_exact_uniform_boolean_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::make_exact_uniform_boolean_array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_trues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>random_seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a boolean array with exactly a certain number of true elements.</p>
<p>if num_trues is &gt; size, an array of all trues of length size is returned. </p>

</div>
</div>
<a id="a4e470c1783849077e2cab28b406eaf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e470c1783849077e2cab28b406eaf5b">&#9670;&nbsp;</a></span>make_uniform_boolean_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::make_uniform_boolean_array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>percent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>random_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a boolean array with approximately a percent of the array randomly true.</p>
<p>if exact is false, each row is a sample from Bernoulli(percent). On average, 'percent' fraction of the array will be true, but this will not be exact.</p>
<p>If exact is true, <a class="el" href="classturi_1_1unity__sarray.html#ad999f05e4bb5296907e4f561f7ca42f1">make_exact_uniform_boolean_array</a> is used. </p>

</div>
</div>
<a id="a0fb3d0ef2ce1dad469e13398e044db1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb3d0ef2ce1dad469e13398e044db1c">&#9670;&nbsp;</a></span>make_uniform_int_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::make_uniform_int_array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_int</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a int array with uniform distribution between 0 and max_int. </p>

</div>
</div>
<a id="a281241fc5573044feb6955a430992572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281241fc5573044feb6955a430992572">&#9670;&nbsp;</a></span>materialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::materialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>materialize the sarray, this is different from save() as this is a temporary persist of this sarray to disk to speed up some computation (for example, lambda) this will NOT create a new uity_sarray. </p>

</div>
</div>
<a id="a827f648c316973c9b30c93698b7f29b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827f648c316973c9b30c93698b7f29b5">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::unity_sarray::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the largest element in the sarray. An empty array returns <a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>, which in python is numpy.nan. Only works for INTEGER and FLOAT. Throws an exception if invoked on an sarray of any other type. Undefined values in the array are skipped. </p>

</div>
</div>
<a id="ae7eca82ad5ed55417a77da0b8d39b0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7eca82ad5ed55417a77da0b8d39b0af">&#9670;&nbsp;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::unity_sarray::mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the mean of the elements in sarray as a flex_float.</p>
<p>Invoking on an empty sarray returns <a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>. Invoking on a non-numeric type throws an exception. Undefined values in the array are skipped. </p>

</div>
</div>
<a id="a2b5e3d0afca10ef0912c23ea2dba03d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5e3d0afca10ef0912c23ea2dba03d4">&#9670;&nbsp;</a></span>median()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::unity_sarray::median </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>approx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the medain of the elements in the sarray.</p>
<p>Invoking on an empty sarray returns <a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>. Invoking on a non-numeric type throws an exception. Undefined values in the array are skipped. </p>

</div>
</div>
<a id="ad257e89c7a8425e09c9c81b4a55076d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad257e89c7a8425e09c9c81b4a55076d6">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::unity_sarray::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the smallest element in the sarray. An empty array returns <a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>, which in python is numpy.nan. Only works for INTEGER and FLOAT. Throws an exception if invoked on an sarray of any other type. Undefined values in the array are skipped. </p>

</div>
</div>
<a id="a4cbe03088f430086e30da3f156c07760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbe03088f430086e30da3f156c07760">&#9670;&nbsp;</a></span>missing_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::missing_mask </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>missing_is_true</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new integer typed array indicating the presence of a missing value or float NA in the corresponding element.</p>
<p>If recursive is true, then it also checks if a NA is present in any element of a recursive type.</p>
<p>If missing_is_true is true, then the array contains a 1 if the element is a missing value and a 0 if it is not; otherwise, it returns 1 on the presence of a na. </p>

</div>
</div>
<a id="a9cc5025871ec3972714e0eeb7f885d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc5025871ec3972714e0eeb7f885d6d">&#9670;&nbsp;</a></span>nnz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::unity_sarray::nnz </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of non-zero elements in the array. Functionally equivalent to </p><div class="fragment"><div class="line">nonzero().length()</div></div><!-- fragment --><p> But takes much less memory. </p>

</div>
</div>
<a id="ab759b45ff7839fccf9924c3956c32629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab759b45ff7839fccf9924c3956c32629">&#9670;&nbsp;</a></span>num_missing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::unity_sarray::num_missing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of missing values in the SArray. </p>

</div>
</div>
<a id="ad7f105e10cecd16c253e8314dd6e38d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f105e10cecd16c253e8314dd6e38d5">&#9670;&nbsp;</a></span>right_scalar_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::right_scalar_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the equivalent of other [op] array, where other is a scalar value. The operation must be one of the following: "+", "-", "*", "/", "&lt;", "&gt;", "&lt;=", "&gt;=", "==", "!=". The type of the new array is dependent on the semantics of the operation.</p><ul>
<li>comparison operators always return integers</li>
<li>+,-,* of integer against integers always return integers</li>
<li>/ of integer against integer always returns floats</li>
<li>+,-,*,/ of floats against floats always return floats</li>
<li>+,-,*,/ of integer against floats or floats against integers always return floats.</li>
</ul>
<p>This function throws a string exception if there is a type mismatch ( for instance you cannot add a string value to an integer array), or if the operation is invalid.</p>
<p>UNDEFINED values in the array are ignored.</p>
<p>On success, a new array is returned. The new array is the same length and has the same segment structure. </p>

</div>
</div>
<a id="a16495d5e11e3e5c04585557515fcc35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16495d5e11e3e5c04585557515fcc35d">&#9670;&nbsp;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::sample </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>percent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>random_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a uniform random sample of the sarray, that contains percent of the total elements, without replacement, using the random_seed. </p>

</div>
</div>
<a id="add15d2e4e1d36003dab7e6b1a59e50f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add15d2e4e1d36003dab7e6b1a59e50f6">&#9670;&nbsp;</a></span>save_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::save_array </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>target_directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves a copy of the current sarray into a directory. Does not modify the current sarray </p>

</div>
</div>
<a id="a3141924024afc2b69751b867c9fad5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3141924024afc2b69751b867c9fad5e6">&#9670;&nbsp;</a></span>save_array_by_index_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unity_sarray::save_array_by_index_file </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>index_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves a copy of the current sarray into a target location defined by an index file. DOes not modify the current sarray. </p>

</div>
</div>
<a id="a74e62d4b9e3ed62fcd8db92963cc820f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e62d4b9e3ed62fcd8db92963cc820f">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::unity_sarray::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of rows in the SArray. Or 0 if the SArray is empty. </p>

</div>
</div>
<a id="a1816a72554d4872bc4a4c72ff67ace90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1816a72554d4872bc4a4c72ff67ace90">&#9670;&nbsp;</a></span>std()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::unity_sarray::std </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the standard deviation of the elements in sarray as a flex_float.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ddof</td><td>...stands for "delta degrees of freedom". Adjusts the degrees of freedom in the variance calculation. If ddof=0, there are N degrees of freedom, with N being the number of elements in the sarray.</td></tr>
  </table>
  </dd>
</dl>
<p>Throws an exception if: ddof &gt;= sarray size sarray is of a non-numeric type</p>
<p>Returns <a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a> if executed on empty or non-existent sarray. Undefined values in the array are skipped. </p>

</div>
</div>
<a id="aa34d6f59fa9de7fd22e978248c28ce21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34d6f59fa9de7fd22e978248c28ce21">&#9670;&nbsp;</a></span>str_to_datetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::str_to_datetime </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new SArray with the string values casted to datetime.</p>
<p>"format" determines the string format for the input SArray. </p>

</div>
</div>
<a id="a6b55521a9c6e634f5bd5e84bfced261b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b55521a9c6e634f5bd5e84bfced261b">&#9670;&nbsp;</a></span>subslice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::subslice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the subslice of the sarray</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The start row of the slice, cycle around if negative </td></tr>
    <tr><td class="paramname">step</td><td>Take an element every step, can be negative </td></tr>
    <tr><td class="paramname">stop</td><td>The end row of the slice, cycle around if negative </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4b5b66db62ce3270b55bab3fda53c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b5b66db62ce3270b55bab3fda53c55">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::unity_sarray::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the sum of all elements in the sarray. An empty returns <a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>, which in python is numpy.nan. Only works for INTEGER and FLOAT. Throws an exception if invoked on an sarray of any other type. Overflows without shame. Undefined values in the array are skipped. </p>

</div>
</div>
<a id="a91f2c94aeee519fc925ddeaeab2bf2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f2c94aeee519fc925ddeaeab2bf2dc">&#9670;&nbsp;</a></span>tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::tail </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em> = <code>10</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns some number of rows on the end of the SArray. The values are returned in the order they were found in the SArray.</p>
<p>NOTE: If there are more elements asked for than can fit into memory, this makes no attempt to stop crashing your computer. </p>

</div>
</div>
<a id="a4dc77e6534d8d370374e4bae9f99fc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc77e6534d8d370374e4bae9f99fc1c">&#9670;&nbsp;</a></span>ternary_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::ternary_operator </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td>
          <td class="paramname"><em>is_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td>
          <td class="paramname"><em>is_false</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_true and is_false and this SArray must be the same size. Returns an SArray of the same size.</p>
<p>For each non-zero value in this SArray, it picks up the corresponding value from is_true. For each zero value in this SArray, it picks up the corresponding value from is_false. </p>

</div>
</div>
<a id="a20106a1f4cd9d4e9674f668c971d6d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20106a1f4cd9d4e9674f668c971d6d59">&#9670;&nbsp;</a></span>to_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::to_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an SArray of the same length but with all constant values. Does so without materializing the SArray.</p>
<dl class="section note"><dt>Note</dt><dd>This is really only useful for internal use </dd></dl>

</div>
</div>
<a id="a994dd1a0fbdd0264db610f9de009e701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994dd1a0fbdd0264db610f9de009e701">&#9670;&nbsp;</a></span>to_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; turi::unity_sarray::to_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the content as a vector. Convenience function. </p>

<p class="definition">Definition at line <a class="el" href="unity__sarray_8hpp_source.html#l00735">735</a> of file <a class="el" href="unity__sarray_8hpp_source.html">unity_sarray.hpp</a>.</p>

</div>
</div>
<a id="ade1a94e39e7786ca4e7cd7c79db65bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1a94e39e7786ca4e7cd7c79db65bdd">&#9670;&nbsp;</a></span>topk_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::topk_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new SArray which has the top k elements selected. k should be reasonably small. O(k) memory required.</p>
<p>If reverse if true, the bottom k is returned instead </p>

</div>
</div>
<a id="a820bac4cdbaf297408e29f3fe26f95d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820bac4cdbaf297408e29f3fe26f95d9">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::transform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_undefined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new sarray which is a transform of this using a Python lambda function pickled into a string. </p>

</div>
</div>
<a id="a677fb22b47ed4368d501112a581641af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677fb22b47ed4368d501112a581641af">&#9670;&nbsp;</a></span>transform_native()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::transform_native </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structturi_1_1function__closure__info.html">function_closure_info</a> &amp;&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_undefined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new sarray which is a transform of this using a registered toolkit function. </p>

</div>
</div>
<a id="af8dd4e91f234e19c182ff99db6a63829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8dd4e91f234e19c182ff99db6a63829">&#9670;&nbsp;</a></span>unpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sarray::unpack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unpacked_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unpacked_columns_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>na_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unpack an SArray of dict/list/vector type to a set of new columns. For dictionary type, each unique key is a new column For vector/list type, each sub column in the vector is a new column</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_name_prefix</td><td>prefix for the unpacked column name </td></tr>
    <tr><td class="paramname">unpacked_keys</td><td>list of keys to unpack, this is list of string for dictionary type, and list of integers for list/array type. This list is used to limit the subset of values to unpack </td></tr>
    <tr><td class="paramname">unpacked_column_types</td><td>list of types for the unpacked columns </td></tr>
    <tr><td class="paramname">na_value</td><td>if not undefined, replace all na_value with missing values</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a new SFrame that contains the unpacked columns </p>

</div>
</div>
<a id="aa3e46e89c2f9c4efbdc5b1aec9c047dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e46e89c2f9c4efbdc5b1aec9c047dd">&#9670;&nbsp;</a></span>unpack_dict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sframe_base&gt; turi::unity_sarray::unpack_dict </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>column_name_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>na_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unpack a dict SArray to a set of new columns by extracting each key from dict and creating new column for each unique key. The key name becomes column name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column_name_prefix</td><td>prefix for the unpacked column name </td></tr>
    <tr><td class="paramname">limit</td><td>limited keys for the unpack </td></tr>
    <tr><td class="paramname">na_value</td><td>if not undefined, replace all na_value with missing values</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a new SFrame that contains the unpacked columns </p>

</div>
</div>
<a id="a4e8275e35d8d2cbd092d5afc7c6df0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8275e35d8d2cbd092d5afc7c6df0fe">&#9670;&nbsp;</a></span>var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::unity_sarray::var </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the variance of the elements in sarray as a flex_float.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ddof</td><td>...stands for "delta degrees of freedom". Adjusts the degrees of freedom in the variance calculation. If ddof=0, there are N degrees of freedom, with N being the number of elements in the sarray.</td></tr>
  </table>
  </dd>
</dl>
<p>Throws an exception if: ddof &gt;= sarray size sarray is of a non-numeric type</p>
<p>Returns <a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a> if executed on empty or non-existent SArray. Undefined values in the array are skipped. </p>

</div>
</div>
<a id="aac1b615d9f4c421285aa6e020b47487d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1b615d9f4c421285aa6e020b47487d">&#9670;&nbsp;</a></span>vector_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::vector_operator </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; unity_sarray_base &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs the equivalent of array [op] other, where other is an SArray. The operation must be one of the following: "+", "-", "*", "/", "&lt;", "&gt;", "&lt;=", "&gt;=", "==", "!=". The type of the new array is dependent on the semantics of the operation.</p><ul>
<li>comparison operators always return integers</li>
<li>+,-,* of integer against integers always return integers</li>
<li>/ of integer against integer always returns floats</li>
<li>+,-,*,/ of floats against floats always return floats</li>
<li>+,-,*,/ of integer against floats or floats against integers always return floats.</li>
</ul>
<p>This function throws a string exception if there is a type mismatch ( for instance you cannot add a string value to an integer array), or if the operation is invalid.</p>
<p>UNDEFINED values in the array are ignored.</p>
<p>On success, a new array is returned. The new array is the same length and has the same segment structure. </p>

</div>
</div>
<a id="a944c504c4b113563a9f7d019f9398136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944c504c4b113563a9f7d019f9398136">&#9670;&nbsp;</a></span>vector_slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;unity_sarray_base&gt; turi::unity_sarray::vector_slice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this sarray contains vectors, this returns a new sarray comprising of a vertical slice of the vector from position start (inclusive) to position end (exclusive). Throws an exception if the sarray is not an vector.</p>
<p>If end==(start+1), the output is an SArray of doubles. if end &gt; start, the output is an SArray of vectors, each of length (end - start). If a vector cannot be sliced (for instance the length of the vector is less than end), the resultant value will be UNDEFINED.</p>
<p>End must be greater than start. throws an exception otherwise. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/storage/sframe_interface/<a class="el" href="unity__sarray_8hpp_source.html">unity_sarray.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="classturi_1_1unity__sarray.html">unity_sarray</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
