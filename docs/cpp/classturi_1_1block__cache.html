<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: turi::block_cache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classturi_1_1block__cache.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classturi_1_1block__cache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">turi::block_cache Class Reference<div class="ingroups"><a class="el" href="group__fileio.html">File IO Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="block__cache_8hpp_source.html">core/storage/fileio/block_cache.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3b6c68e6cb276bb87919393601e357de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#a3b6c68e6cb276bb87919393601e357de">block_cache</a> ()=default</td></tr>
<tr class="separator:a3b6c68e6cb276bb87919393601e357de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f93816a1f8180a95134d887e9ec065"><td class="memItemLeft" align="right" valign="top"><a id="a28f93816a1f8180a95134d887e9ec065"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#a28f93816a1f8180a95134d887e9ec065">~block_cache</a> ()</td></tr>
<tr class="memdesc:a28f93816a1f8180a95134d887e9ec065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. Deletes all associated files. <br /></td></tr>
<tr class="separator:a28f93816a1f8180a95134d887e9ec065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f70490d65ec329f88bbb9a2d7ef3d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#a51f70490d65ec329f88bbb9a2d7ef3d0">init</a> (const std::string &amp;storage_prefix, size_t max_file_handle_cache=16)</td></tr>
<tr class="separator:a51f70490d65ec329f88bbb9a2d7ef3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d5c8bf37c7d17f6b03a7329365d074"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#ad7d5c8bf37c7d17f6b03a7329365d074">write</a> (const std::string &amp;key, const std::string &amp;value)</td></tr>
<tr class="separator:ad7d5c8bf37c7d17f6b03a7329365d074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f843925128056ab02a1f8faa7bb179"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#a59f843925128056ab02a1f8faa7bb179">evict_key</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a59f843925128056ab02a1f8faa7bb179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17defe9c7a680d37ee72e3e6eba3207c"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#a17defe9c7a680d37ee72e3e6eba3207c">value_length</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a17defe9c7a680d37ee72e3e6eba3207c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87aed0f16ade6c386566e35b289624ca"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#a87aed0f16ade6c386566e35b289624ca">read</a> (const std::string &amp;key, char *output, size_t start=0, size_t end=(size_t)(-1))</td></tr>
<tr class="separator:a87aed0f16ade6c386566e35b289624ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794b417e829f6d7a86314dba2ac7fe7e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#a794b417e829f6d7a86314dba2ac7fe7e">read</a> (const std::string &amp;key, std::string &amp;output, size_t start=0, size_t end=(size_t)(-1))</td></tr>
<tr class="separator:a794b417e829f6d7a86314dba2ac7fe7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d17a57e06a3c03d8a56b659703afc11"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#a7d17a57e06a3c03d8a56b659703afc11">file_handle_cache_hits</a> () const</td></tr>
<tr class="separator:a7d17a57e06a3c03d8a56b659703afc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c315773a511b208e14a12aab4168701"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#a4c315773a511b208e14a12aab4168701">file_handle_cache_misses</a> () const</td></tr>
<tr class="separator:a4c315773a511b208e14a12aab4168701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11f52be0ad778ce54f273ea1260a39f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#ac11f52be0ad778ce54f273ea1260a39f">get_max_capacity</a> ()</td></tr>
<tr class="separator:ac11f52be0ad778ce54f273ea1260a39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe27283eaa8d829ea1a87e1ec8327a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#abe27283eaa8d829ea1a87e1ec8327a5f">set_max_capacity</a> (size_t)</td></tr>
<tr class="separator:abe27283eaa8d829ea1a87e1ec8327a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a28db5537fb853bcdf4d22b1963a25ea8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classturi_1_1block__cache.html">block_cache</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html#a28db5537fb853bcdf4d22b1963a25ea8">get_instance</a> ()</td></tr>
<tr class="separator:a28db5537fb853bcdf4d22b1963a25ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The block cache implements a simple key-value store for extremely large values (~16MB at least). Every key can only be written to exactly once, and allows for arbitrary range reads (i.e. read byte X to byte Y of this key)</p>
<p>Essentially every value is stored as a single file inside the storage_prefix parameter set at <a class="el" href="classturi_1_1block__cache.html#a51f70490d65ec329f88bbb9a2d7ef3d0">init</a>.</p>
<p>The <a class="el" href="classturi_1_1block__cache.html">block_cache</a> is safe for concurrent use.</p>
<h2>Use On a Distributed File System </h2>
<p>The storage prefix be located on a distributed filesystem (for instance HDFS or NFS). In which case, <em>every</em> machine sharing the same storage prefix also shares keys.</p>
<p>When sharing a storage prefix with other processes on a distributed filesystem, the atomicity guarantees of the filesystem becomes important.</p>
<p>In particular, on HDFS, you may find keys in a "indeterminate" state, where it cannot be written to, but cannot be queried (because the writer has created the file but has not finished writing to it yet). On NFS multiple machines may be able to write to the same key, but only one will win. Also the length and contents of the key may be wrong if you read the key while someone else is writing to it.</p>
<h2>Design Notes </h2>
<p>We will like these "interesting" distributed file system properties to not be true when the <a class="el" href="classturi_1_1block__cache.html">block_cache</a> is merely used concurrently. So a bit of care is needed to ensure atomicity, at least within the context of the same <a class="el" href="classturi_1_1block__cache.html">block_cache</a> object. Essentially we want write-once, but arbitrary parallel reads semantics. </p>

<p class="definition">Definition at line <a class="el" href="block__cache_8hpp_source.html#l00052">52</a> of file <a class="el" href="block__cache_8hpp_source.html">block_cache.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3b6c68e6cb276bb87919393601e357de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6c68e6cb276bb87919393601e357de">&#9670;&nbsp;</a></span>block_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">turi::block_cache::block_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs the block cache. init must be called before the <a class="el" href="classturi_1_1block__cache.html">block_cache</a> can be used. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a59f843925128056ab02a1f8faa7bb179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f843925128056ab02a1f8faa7bb179">&#9670;&nbsp;</a></span>evict_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::block_cache::evict_key </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evicts a particular key. Returns true on success, false on failure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d17a57e06a3c03d8a56b659703afc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d17a57e06a3c03d8a56b659703afc11">&#9670;&nbsp;</a></span>file_handle_cache_hits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::block_cache::file_handle_cache_hits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns then number of file handle cache hits. This function is for profiling purposes since file handles are cached for performance reasons. </p>

</div>
</div>
<a id="a4c315773a511b208e14a12aab4168701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c315773a511b208e14a12aab4168701">&#9670;&nbsp;</a></span>file_handle_cache_misses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::block_cache::file_handle_cache_misses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns then number of file handle cache misses. This function is for profiling purposes since file handles are cached for performance reasons. </p>

</div>
</div>
<a id="a28db5537fb853bcdf4d22b1963a25ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28db5537fb853bcdf4d22b1963a25ea8">&#9670;&nbsp;</a></span>get_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classturi_1_1block__cache.html">block_cache</a>&amp; turi::block_cache::get_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a singleton instance. The singleton instance has this default behavior:</p>
<p>Location of storage:</p><ul>
<li>If temp files are located on HDFS, the cache just writes through and is always located on HDFS.</li>
<li>If temp files are located on local disk, the cache is set to the cache:// file system. This allows for a degree of in-memory caching.</li>
</ul>
<p>File handle LRU cache size:</p><ul>
<li>4 * ncpus </li>
</ul>

</div>
</div>
<a id="ac11f52be0ad778ce54f273ea1260a39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11f52be0ad778ce54f273ea1260a39f">&#9670;&nbsp;</a></span>get_max_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::block_cache::get_max_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the maximum number of files managed. If 0, there is no max capacity. </p>

</div>
</div>
<a id="a51f70490d65ec329f88bbb9a2d7ef3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f70490d65ec329f88bbb9a2d7ef3d0">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::block_cache::init </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>storage_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_file_handle_cache</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>init must be called exactly once on block cache construction before the block cache can be used. Multiple calls to init will raise an exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage_prefix</td><td>The location where all values are stored </td></tr>
    <tr><td class="paramname">max_file_handle_cache</td><td>The maximum number of file handles to cache</td></tr>
  </table>
  </dd>
</dl>
<p>Essentially, every value is stored as a separate file inside the directory. </p>

</div>
</div>
<a id="a87aed0f16ade6c386566e35b289624ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87aed0f16ade6c386566e35b289624ca">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t turi::block_cache::read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>(size_t)(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the value of a key into an output string, resizing the output string if necessary; Returns the number of bytes read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to read </td></tr>
    <tr><td class="paramname">output</td><td>A reference to the output string </td></tr>
    <tr><td class="paramname">start</td><td>Optional, denotes the start offset of the value to read. Defaults to 0. </td></tr>
    <tr><td class="paramname">end</td><td>Optional, denotes the end offset of the value to read. The byte at end is not read. i.e. to read the first 5 bytes of the file, you call read(key, output, 0, 5); Defaults to the length of the file.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the number of bytes read can be 0 if:</p><ul>
<li>start is past the end of the value</li>
<li>end is less than start</li>
</ul>
<p>If start and end are not passed, the entire block is read.</p>
<dl class="section return"><dt>Returns</dt><dd>A value less than 0 on failure. </dd></dl>

</div>
</div>
<a id="a794b417e829f6d7a86314dba2ac7fe7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794b417e829f6d7a86314dba2ac7fe7e">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t turi::block_cache::read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em> = <code>(size_t)(-1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>string overload. Note the char* reader is faster. </p>

</div>
</div>
<a id="abe27283eaa8d829ea1a87e1ec8327a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe27283eaa8d829ea1a87e1ec8327a5f">&#9670;&nbsp;</a></span>set_max_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::block_cache::set_max_capacity </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the maximum number of files managed. If 0, there is no max capacity. </p>

</div>
</div>
<a id="a17defe9c7a680d37ee72e3e6eba3207c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17defe9c7a680d37ee72e3e6eba3207c">&#9670;&nbsp;</a></span>value_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t turi::block_cache::value_length </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the value of a particular key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the value on success, a value &lt; 0 on failure. </dd></dl>

</div>
</div>
<a id="ad7d5c8bf37c7d17f6b03a7329365d074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d5c8bf37c7d17f6b03a7329365d074">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::block_cache::write </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a string to a key. Returns true on success. The key must not already exist. If the key already exists this fails and false is returned. When operating on a distributed filesystem, note that every machine sharing the same storage prefix have a common key space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to write to </td></tr>
    <tr><td class="paramname">value</td><td>The value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/storage/fileio/<a class="el" href="block__cache_8hpp_source.html">block_cache.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li><li class="navelem"><a class="el" href="classturi_1_1block__cache.html">block_cache</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
