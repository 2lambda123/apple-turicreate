<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Turi Create: turi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Turi Create
   &#160;<span id="projectnumber">4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceturi.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">turi Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>SKD.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceturi_1_1aggregate"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1aggregate.html">aggregate</a></td></tr>
<tr class="memdesc:namespaceturi_1_1aggregate"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the available groupby aggregators aggregators. See <a class="el" href="classturi_1_1gl__sframe.html#ad38deca1b806caef7c34e03cd4fdce10">gl_sframe::groupby</a> for details. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1groupby__aggregate__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1groupby__aggregate__impl.html">groupby_aggregate_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1groupby__operators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1groupby__operators.html">groupby_operators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1integer__pack"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1integer__pack.html">integer_pack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1join__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1join__impl.html">join_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1memory__info"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1memory__info.html">memory_info</a></td></tr>
<tr class="memdesc:namespaceturi_1_1memory__info"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory info namespace contains functions used to compute memory usage. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1query__eval"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1query__eval.html">query_eval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1random"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1random.html">random</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1rolling__aggregate"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1rolling__aggregate.html">rolling_aggregate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1sframe__config"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sframe__config.html">sframe_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1sframe__saving__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sframe__saving__impl.html">sframe_saving_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1sgraph__compute"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1sgraph__compute.html">sgraph_compute</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceturi_1_1v2__block__impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi_1_1v2__block__impl.html">v2_block_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1all__flexible__type__convertible.html">all_flexible_type_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1all__variant__convertible.html">all_variant_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1any.html">any</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1auto__close__sarrays.html">auto_close_sarrays</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1bad__alloc.html">bad_alloc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1bad__cast.html">bad_cast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1blob.html">blob</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1block__cache.html">block_cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1blocking__queue.html">blocking_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a blocking queue useful for producer/consumer models.  <a href="classturi_1_1blocking__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1broadcast__queue.html">broadcast_queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1buffer__pool.html">buffer_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1buffered__writer.html">buffered_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1cancellable__barrier.html">cancellable_barrier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1conditional.html">conditional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1conditional__test.html">conditional_test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1const__gl__sarray__reference.html">const_gl_sarray_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1csv__file__handling__options.html">csv_file_handling_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1csv__line__tokenizer.html">csv_line_tokenizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1csv__writer.html">csv_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1dataframe__row__iterator.html">dataframe_row_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1deferred__rwlock.html">deferred_rwlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1dense__bitset.html">dense_bitset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1dir__archive.html">dir_archive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1edge__triple.html">edge_triple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1enum__to__type.html">enum_to_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fast__integer__power.html">fast_integer_power</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1file__download__cache.html">file_download_cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1file__line__count__estimator.html">file_line_count_estimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1first__nested__type.html">first_nested_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1fixed__dense__bitset.html">fixed_dense_bitset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1flex__date__time.html">flex_date_time</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flex__dict__view.html">flex_dict_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1flexible__type__converter.html">flexible_type_converter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1flexible__type__parser.html">flexible_type_parser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1flexible__type__parser__impl.html">flexible_type_parser_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1function__closure__info.html">function_closure_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1function__output__iterator.html">function_output_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1general__ifstream.html">general_ifstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1general__ofstream.html">general_ofstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__gframe.html">gl_gframe</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1gl__is__pod.html">gl_is_pod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if T is a POD type.  <a href="structturi_1_1gl__is__pod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1gl__is__pod__or__scaler.html">gl_is_pod_or_scaler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sarray__range.html">gl_sarray_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sarray__reference.html">gl_sarray_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sarray__writer.html">gl_sarray_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe__range.html">gl_sframe_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sframe__writer.html">gl_sframe_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1gl__sgraph.html">gl_sgraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1global__startup.html">global_startup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1global__teardown.html">global_teardown</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1group__index__file__information.html">group_index_file_information</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1GroupKeyHash.html">GroupKeyHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1has__direct__conversion__to__flexible__type.html">has_direct_conversion_to_flexible_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1hash__bucket.html">hash_bucket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1hash__bucket__container.html">hash_bucket_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1hash__value.html">hash_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1hopscotch__map.html">hopscotch_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1hopscotch__set.html">hopscotch_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1hopscotch__table.html">hopscotch_table</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1iarchive.html">iarchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The serialization input archive object which, provided with a reference to an istream, will read from the istream, providing deserialization capabilities.  <a href="classturi_1_1iarchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1iarchive__soft__fail.html">iarchive_soft_fail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this archive is used to deserialize an object, and the object does not support serialization, failure will only occur at runtime. Otherwise equivalent to <a class="el" href="classturi_1_1iarchive.html" title="The serialization input archive object which, provided with a reference to an istream, will read from the istream, providing deserialization capabilities. ">turi::iarchive</a>.  <a href="classturi_1_1iarchive__soft__fail.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1image__type.html">image_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1index__file__information.html">index_file_information</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1indexed__column__groupby.html">indexed_column_groupby</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1is__flexible__type__convertible.html">is_flexible_type_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1IS__POD__TYPE.html">IS_POD_TYPE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheriting from this type will force the serializer to treat the derived type as a POD type.  <a href="structturi_1_1IS__POD__TYPE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1is__valid__flex__type.html">is_valid_flex_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1is__variant__convertible.html">is_variant_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1l2__rescaling.html">l2_rescaling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1lazy__eval__future.html">lazy_eval_future</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1lazy__eval__operation__base.html">lazy_eval_operation_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1lazy__eval__operation__dag.html">lazy_eval_operation_dag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1list__objects__response.html">list_objects_response</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1lockfree__push__back.html">lockfree_push_back</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1lru__cache.html">lru_cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data.html">ml_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1ml__data__entry.html">ml_data_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1ml__data__entry__global__index.html">ml_data_entry_global_index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1ml__data__full__entry.html">ml_data_full_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data__iterator.html">ml_data_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__data__row__reference.html">ml_data_row_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1ml__model__base.html">ml_model_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1model__base.html">model_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1model__proxy.html">model_proxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1mutable__queue.html">mutable_queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1mutex.html">mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1oarchive.html">oarchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The serialization output archive object which, provided with a reference to an ostream, will write to the ostream, providing serialization capabilities.  <a href="classturi_1_1oarchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1oarchive__soft__fail.html">oarchive_soft_fail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this archive is used to serialize an object, and the object does not support serialization, failure will only occur at runtime. Otherwise equivalent to <a class="el" href="classturi_1_1oarchive.html" title="The serialization output archive object which, provided with a reference to an ostream, will write to the ostream, providing serialization capabilities. ">turi::oarchive</a>.  <a href="classturi_1_1oarchive__soft__fail.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1option__manager.html">option_manager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1padded__integer.html">padded_integer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an integer value padded to 64 bytes  <a href="structturi_1_1padded__integer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1padded__simple__spinlock.html">padded_simple_spinlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1parallel__sframe__iterator.html">parallel_sframe_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1parallel__sframe__iterator__initializer.html">parallel_sframe_iterator_initializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1parallel__task__queue.html">parallel_task_queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1process.html">process</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1progress__time.html">progress_time</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1queued__rw__lock.html">queued_rw_lock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1rdtsc__time.html">rdtsc_time</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1read__caching__device.html">read_caching_device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1recursive__mutex.html">recursive_mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1resizing__array__sink__ref.html">resizing_array_sink_ref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1rwlock.html">rwlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1s3__device.html">s3_device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1s3url.html">s3url</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1safe__circular__char__buffer.html">safe_circular_char_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray.html">sarray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__block__iterator.html">sarray_block_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__format__reader__common__base.html">sarray_format_reader_common_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__format__reader__v2.html">sarray_format_reader_v2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__group__format__writer.html">sarray_group_format_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__group__format__writer__v2.html">sarray_group_format_writer_v2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__iterator.html">sarray_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__reader.html">sarray_reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__reader__buffer.html">sarray_reader_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sarray__sorted__buffer.html">sarray_sorted_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1scoped__finally.html">scoped_finally</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1second__nested__type.html">second_nested_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1semaphore.html">semaphore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1Serializable.html">Serializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept checks if a type T is serializable.  <a href="classturi_1_1Serializable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe.html">sframe</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__function__output__iterator.html">sframe_function_output_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__iterator.html">sframe_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader.html">sframe_reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__reader__buffer.html">sframe_reader_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sframe__rows.html">sframe_rows</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sgraph.html">sgraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1simple__model.html">simple_model</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1simple__spinlock.html">simple_spinlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1siterable.html">siterable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sparse__parallel__2d__array.html">sparse_parallel_2d_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1sparse__similarity__lookup.html">sparse_similarity_lookup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1spinrwlock.html">spinrwlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1standardization__interface.html">standardization_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1statistics__tracker.html">statistics_tracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1swriter__base.html">swriter_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1symmetric__2d__array.html">symmetric_2d_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1table__printer.html">table_printer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1thread.html">thread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1thread__group.html">thread_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1thread__pool.html">thread_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1timer.html">timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that can be used for benchmarking/timing up to microsecond resolution.  <a href="classturi_1_1timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1toolkit__class__registry.html">toolkit_class_registry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1toolkit__class__specification.html">toolkit_class_specification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1toolkit__function__invocation.html">toolkit_function_invocation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1toolkit__function__registry.html">toolkit_function_registry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1toolkit__function__response__type.html">toolkit_function_response_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1toolkit__function__specification.html">toolkit_function_specification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1topk__indexer.html">topk_indexer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1trace__count.html">trace_count</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1type__to__enum.html">type_to_enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unfair__lock.html">unfair_lock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1union__fstream.html">union_fstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__global.html">unity_global</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__global__base.html">unity_global_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray.html">unity_sarray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sarray__builder.html">unity_sarray_builder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe.html">unity_sframe</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sframe__builder.html">unity_sframe_builder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sgraph.html">unity_sgraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sgraph__base.html">unity_sgraph_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1unity__sketch.html">unity_sketch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1unsupported__serialize.html">unsupported_serialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritting from this class will prevent the serialization of the derived class. Used for debugging purposes.  <a href="structturi_1_1unsupported__serialize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1value__container__mapper.html">value_container_mapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter.html">variant_converter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01gl__sarray_00_01void_01_4.html">variant_converter&lt; gl_sarray, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01std_1_1function_3_01S_07Args_8_8_8_08_4_00_01typename_01stde8ef53dd70f8facd6cc5d3b899a7e76b.html">variant_converter&lt; std::function&lt; S(Args...)&gt;, typename std::enable_if&lt; is_variant_convertible&lt; S &gt;::value &amp;&amp;all_variant_convertible&lt; Args... &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01std_1_1map_3_01std_1_1string_00_01T_01_4_00_01typename_01steb921e526939df4b6787a299e9eca002.html">variant_converter&lt; std::map&lt; std::string, T &gt;, typename std::enable_if&lt;!is_flexible_type_convertible&lt; T &gt;::value &amp;&amp;is_variant_convertible&lt; T &gt;::value &amp;&amp;!is_variant_member&lt; std::map&lt; std::string, T &gt; &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01std_1_1pair_3_01S_00_01T_01_4_00_01typename_01std_1_1enablefdd6abc72e9114774ec15ac64509ca94.html">variant_converter&lt; std::pair&lt; S, T &gt;, typename std::enable_if&lt;!is_flexible_type_convertible&lt; T &gt;::value &amp;&amp;is_variant_convertible&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01std_1_1shared__ptr_3_01T_01_4_00_01typename_01std_1_1enablec167e880c64e2086540b988c9a289ebc.html">variant_converter&lt; std::shared_ptr&lt; T &gt;, typename std::enable_if&lt; is_model_descendent&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, model_base &gt;::value &amp;&amp;!is_toolkit_builtin&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01std_1_1shared__ptr_3_01unity__sarray_01_4_00_01void_01_4.html">variant_converter&lt; std::shared_ptr&lt; unity_sarray &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01std_1_1shared__ptr_3_01unity__sframe_01_4_00_01void_01_4.html">variant_converter&lt; std::shared_ptr&lt; unity_sframe &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01std_1_1shared__ptr_3_01unity__sgraph_01_4_00_01void_01_4.html">variant_converter&lt; std::shared_ptr&lt; unity_sgraph &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01std_1_1tuple_3_01Args_8_8_8_01_4_00_01typename_01std_1_1ena13843fb9454a9c1cd7101708ae18f754.html">variant_converter&lt; std::tuple&lt; Args... &gt;, typename std::enable_if&lt;!all_flexible_type_convertible&lt; Args... &gt;::value &amp;&amp;all_variant_convertible&lt; Args... &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01std_1_1unordered__map_3_01std_1_1string_00_01T_01_4_00_01ty155fba366a4b0f7dca1f388fff36c55e.html">variant_converter&lt; std::unordered_map&lt; std::string, T &gt;, typename std::enable_if&lt;!is_flexible_type_convertible&lt; T &gt;::value &amp;&amp;is_variant_convertible&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01std_1_1vector_3_01T_01_4_00_01typename_01std_1_1enable__if_c36eb3cbbd74e09f7620a3a22937e975.html">variant_converter&lt; std::vector&lt; T &gt;, typename std::enable_if&lt;!is_flexible_type_convertible&lt; std::vector&lt; T &gt; &gt;::value &amp;&amp;is_variant_convertible&lt; T &gt;::value &amp;&amp;!is_variant_member&lt; std::vector&lt; T &gt; &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01T_00_01typename_01std_1_1enable__if_3_01is__flexible__type_191eb27affec302a827e3b97f00b9707.html">variant_converter&lt; T, typename std::enable_if&lt; is_flexible_type_convertible&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01T_00_01typename_01std_1_1enable__if_3_01is__model__descendea6851f5c424a968d631dcf076c4d9d36.html">variant_converter&lt; T, typename std::enable_if&lt; is_model_descendent&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, model_base &gt;::value &amp;&amp;!is_toolkit_builtin&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01T_00_01typename_01std_1_1enable__if_3_07is__variant__member510a7bcad77b051f5283003e44761ce7.html">variant_converter&lt; T, typename std::enable_if&lt;(is_variant_member&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, flexible_type &gt;::value)||std::is_same&lt; T, variant_type &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structturi_1_1variant__converter_3_01variant__type_00_01void_01_4.html">variant_converter&lt; variant_type, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classturi_1_1vector__index__mapper.html">vector_index_mapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7936350fa49b122a09c32b26922fd658"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a></td></tr>
<tr class="separator:ga7936350fa49b122a09c32b26922fd658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf31f61cc0e0b82bdc9d886fa163e86"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flexible__type__types.html#gadcf31f61cc0e0b82bdc9d886fa163e86">flex_float</a></td></tr>
<tr class="separator:gadcf31f61cc0e0b82bdc9d886fa163e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf154f20efeacc01dbbe38388a3067566"><td class="memItemLeft" align="right" valign="top">typedef std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a></td></tr>
<tr class="separator:gaf154f20efeacc01dbbe38388a3067566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3209fbbd62e8deaeff5fdb24965f2ac"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a></td></tr>
<tr class="separator:gae3209fbbd62e8deaeff5fdb24965f2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6850eab6f89c527876575257a7c271ce"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a></td></tr>
<tr class="separator:ga6850eab6f89c527876575257a7c271ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga408eb4413a2a629b462fb3a5d4f42c24"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::pair&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a></td></tr>
<tr class="separator:ga408eb4413a2a629b462fb3a5d4f42c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40bb1656bebeb5ab0e3cd138c09e5995"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classturi_1_1image__type.html">image_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flexible__type__types.html#ga40bb1656bebeb5ab0e3cd138c09e5995">flex_image</a></td></tr>
<tr class="separator:ga40bb1656bebeb5ab0e3cd138c09e5995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2900ffa5e2fef35d706e307db74d859"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classturi_1_1flexible__type__impl_1_1ndarray.html">flexible_type_impl::ndarray</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flexible__type__types.html#gac2900ffa5e2fef35d706e307db74d859">flex_nd_vec</a></td></tr>
<tr class="separator:gac2900ffa5e2fef35d706e307db74d859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479770a63836117d0a1fe37ae4a7ba99"><td class="memItemLeft" align="right" valign="top"><a id="a479770a63836117d0a1fe37ae4a7ba99"></a>
typedef <a class="el" href="classturi_1_1mutex.html">mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a479770a63836117d0a1fe37ae4a7ba99">spinlock</a></td></tr>
<tr class="memdesc:a479770a63836117d0a1fe37ae4a7ba99"><td class="mdescLeft">&#160;</td><td class="mdescRight">if spinlock not supported, it is typedef it to a mutex. <br /></td></tr>
<tr class="separator:a479770a63836117d0a1fe37ae4a7ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae2ab6a167bcb565888c5584ddc56ac"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classturi_1_1conditional.html">conditional</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a6ae2ab6a167bcb565888c5584ddc56ac">condition_variable</a></td></tr>
<tr class="separator:a6ae2ab6a167bcb565888c5584ddc56ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad88e65780e1a9617bc5853ccbe78d93d"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__main.html#gad88e65780e1a9617bc5853ccbe78d93d">sgraph_vertex_data</a></td></tr>
<tr class="separator:gad88e65780e1a9617bc5853ccbe78d93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3287fc42b19a09c06dd0138b2b97299"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__main.html#gab3287fc42b19a09c06dd0138b2b97299">sgraph_edge_data</a></td></tr>
<tr class="separator:gab3287fc42b19a09c06dd0138b2b97299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1bc4e23409359261abdb23d0b87ec30"><td class="memItemLeft" align="right" valign="top">typedef boost::iostreams::stream&lt; charstream_impl::resizing_array_sink&lt; true &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gac1bc4e23409359261abdb23d0b87ec30">charstream</a></td></tr>
<tr class="separator:gac1bc4e23409359261abdb23d0b87ec30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaa2cc0f37094753493cb20e3ba0b29f"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__unity.html#gafaa2cc0f37094753493cb20e3ba0b29f">options_map_t</a></td></tr>
<tr class="separator:gafaa2cc0f37094753493cb20e3ba0b29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f01fc93cbbadcab29068fd9b6947ec"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(<a class="el" href="structturi_1_1edge__triple.html">edge_triple</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ad2f01fc93cbbadcab29068fd9b6947ec">lambda_triple_apply_fn</a></td></tr>
<tr class="separator:ad2f01fc93cbbadcab29068fd9b6947ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c19b1dc3f7d958801c33d6265a4109"><td class="memItemLeft" align="right" valign="top"><a id="a95c19b1dc3f7d958801c33d6265a4109"></a>
typedef <a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a95c19b1dc3f7d958801c33d6265a4109">sframe_type</a></td></tr>
<tr class="memdesc:a95c19b1dc3f7d958801c33d6265a4109"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sframe type. <br /></td></tr>
<tr class="separator:a95c19b1dc3f7d958801c33d6265a4109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133f01ff63e13b5b78b761e5c78e0c25"><td class="memItemLeft" align="right" valign="top">typedef boost::make_recursive_variant&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>, std::shared_ptr&lt; <a class="el" href="classturi_1_1unity__sgraph__base.html">unity_sgraph_base</a> &gt;, <a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a>, std::shared_ptr&lt; <a class="el" href="classturi_1_1model__base.html">model_base</a> &gt;, std::shared_ptr&lt; unity_sframe_base &gt;, std::shared_ptr&lt; unity_sarray_base &gt;, std::map&lt; std::string, boost::recursive_variant_ &gt;, std::vector&lt; boost::recursive_variant_ &gt;, boost::recursive_wrapper&lt; <a class="el" href="structturi_1_1function__closure__info.html">function_closure_info</a> &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a></td></tr>
<tr class="separator:a133f01ff63e13b5b78b761e5c78e0c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8f5592bc6ffb76005399e580c12519"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc8f5592bc6ffb76005399e580c12519"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#adc8f5592bc6ffb76005399e580c12519">is_variant_member</a> = boost::mpl::contains&lt; variant_type::types, T &gt;</td></tr>
<tr class="separator:adc8f5592bc6ffb76005399e580c12519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b96181769442a107940d85d2f5e59b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62b96181769442a107940d85d2f5e59b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a62b96181769442a107940d85d2f5e59b">is_model_descendent</a> = std::is_convertible&lt; T *, <a class="el" href="classturi_1_1model__base.html">model_base</a> * &gt;</td></tr>
<tr class="separator:a62b96181769442a107940d85d2f5e59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a232ed812da2796b7bd317ea4b3a21f76"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> : char { <br />
&#160;&#160;<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a5d5cd46919fa987731fb2edefe0f2a0c">flex_type_enum::INTEGER</a> = 0, 
<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6">flex_type_enum::FLOAT</a> = 1, 
<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a63b588d5559f64f89a416e656880b949">flex_type_enum::STRING</a> = 2, 
<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a87752381b583740610f1dfeb07fdad7e">flex_type_enum::VECTOR</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a298cb25408234de02baf2085803a464a">flex_type_enum::LIST</a> = 4, 
<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76ad7f73f951e7f6c4ed5e17c4204f4032e">flex_type_enum::DICT</a> = 5, 
<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76aa3eb957bd02f4780a599d5ec4464ca46">flex_type_enum::DATETIME</a> = 6, 
<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a0db45d2a4141101bdfe48e3314cfbca3">flex_type_enum::UNDEFINED</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a23a12f67f614b5518c7f1c2465bf95e3">flex_type_enum::IMAGE</a> = 8, 
<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76a260c729a53b25b0587857d9a6ca1b6ab">flex_type_enum::ND_VECTOR</a> = 9
<br />
 }</td></tr>
<tr class="separator:a232ed812da2796b7bd317ea4b3a21f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a91663acc51ef53b8d40f4efe12b1be"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1be">Format</a> : size_t { <a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1bea92769fe7c40229f4301d6125e0a9e928">Format::JPG</a> = 0, 
<a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1bea55505ba281b015ec31f03ccb151b2a34">Format::PNG</a> = 1, 
<a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1bea7bd5775f0cb56bfb85009a49a87d9835">Format::RAW_ARRAY</a> = 2, 
<a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1bea0db45d2a4141101bdfe48e3314cfbca3">Format::UNDEFINED</a> = 3
 }</td></tr>
<tr class="separator:a9a91663acc51ef53b8d40f4efe12b1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8056e26a070ff45a1bf1232aa463dd1e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; turi::unity_server_initializer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a8056e26a070ff45a1bf1232aa463dd1e">capi_server_initializer</a> ()</td></tr>
<tr class="separator:a8056e26a070ff45a1bf1232aa463dd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5163d800c1557ce946f305d93665dbc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a5163d800c1557ce946f305d93665dbc1">flex_type_is_convertible</a> (<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> from, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> to)</td></tr>
<tr class="separator:a5163d800c1557ce946f305d93665dbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95083e63ff7e20e03de8833909a699f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a95083e63ff7e20e03de8833909a699f1">flex_type_has_binary_op</a> (<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> left, <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> right, char op)</td></tr>
<tr class="separator:a95083e63ff7e20e03de8833909a699f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65de5f31193ee46ccb4cfd60cddfaaa6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a65de5f31193ee46ccb4cfd60cddfaaa6">flex_type_enum_to_name</a> (<a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> en)</td></tr>
<tr class="separator:a65de5f31193ee46ccb4cfd60cddfaaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532ea655972eb0b72dc40ad14fd82075"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a532ea655972eb0b72dc40ad14fd82075">flex_type_enum_from_name</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a532ea655972eb0b72dc40ad14fd82075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a238b8e9e1ac815ea7f3cd96b899a18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a9a238b8e9e1ac815ea7f3cd96b899a18">get_common_type</a> (const std::set&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;types)</td></tr>
<tr class="separator:a9a238b8e9e1ac815ea7f3cd96b899a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50d334ec1920c64f0eb5e5753a2683e"><td class="memItemLeft" align="right" valign="top">JSONNode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ac50d334ec1920c64f0eb5e5753a2683e">flexible_type_to_json</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;val, std::string name)</td></tr>
<tr class="separator:ac50d334ec1920c64f0eb5e5753a2683e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccc44c9454b45c43047d828b57d6fd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a2ccc44c9454b45c43047d828b57d6fd1">unescape_string</a> (std::string &amp;cal, bool use_escape_char, char escape_char, char quote_char, bool double_quote)</td></tr>
<tr class="separator:a2ccc44c9454b45c43047d828b57d6fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13115823b388e342edac6cb32fc8139a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a13115823b388e342edac6cb32fc8139a">unescape_string</a> (std::string &amp;cal, char escape_char, char quote_char, bool double_quote)</td></tr>
<tr class="separator:a13115823b388e342edac6cb32fc8139a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e1c068cd0a8828f77ae63bc90b1274"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#aa8e1c068cd0a8828f77ae63bc90b1274">unescape_string</a> (char *cal, size_t length, bool use_escape_char, char escape_char, char quote_char, bool double_quote)</td></tr>
<tr class="separator:aa8e1c068cd0a8828f77ae63bc90b1274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0526311cf92a664dffb244238f7a85f1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a0526311cf92a664dffb244238f7a85f1">unescape_string</a> (char *cal, size_t length, char escape_char, char quote_char, bool double_quote)</td></tr>
<tr class="separator:a0526311cf92a664dffb244238f7a85f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae830551f09920d9b64680bf3515a6f32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ae830551f09920d9b64680bf3515a6f32">escape_string</a> (const std::string &amp;val, char escape_char, bool use_escape_char, char quote_char, bool use_quote_char, bool double_quote, std::string &amp;output, size_t &amp;output_len)</td></tr>
<tr class="separator:ae830551f09920d9b64680bf3515a6f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf4d2fbf53fba839b18a35d368924c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#abdf4d2fbf53fba839b18a35d368924c6">decode_image_inplace</a> (<a class="el" href="classturi_1_1image__type.html">image_type</a> &amp;image)</td></tr>
<tr class="separator:abdf4d2fbf53fba839b18a35d368924c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d76d18027e4e0c8ac3141490c67e6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a44d76d18027e4e0c8ac3141490c67e6c">encode_image_inplace</a> (<a class="el" href="classturi_1_1image__type.html">image_type</a> &amp;image)</td></tr>
<tr class="separator:a44d76d18027e4e0c8ac3141490c67e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7681ae05529ccf8380697613715dcf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#aa7681ae05529ccf8380697613715dcf7">write_image</a> (const std::string &amp;filename, char *data, size_t width, size_t height, size_t channels, <a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1be">Format</a> format)</td></tr>
<tr class="separator:aa7681ae05529ccf8380697613715dcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20946a7fa4fc493e32694f38127031a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1image__type.html">image_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ac20946a7fa4fc493e32694f38127031a">read_image</a> (const std::string &amp;url, const std::string &amp;format_hint)</td></tr>
<tr class="separator:ac20946a7fa4fc493e32694f38127031a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad334d106e681dbeb62fe12f20a9587f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ad334d106e681dbeb62fe12f20a9587f8">read_raw_image</a> (const std::string &amp;url, char **data, size_t &amp;length, size_t &amp;width, size_t &amp;height, size_t &amp;channels, <a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1be">Format</a> &amp;format, const std::string &amp;format_hint)</td></tr>
<tr class="separator:ad334d106e681dbeb62fe12f20a9587f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038a75dabfb984fcb3a983de4556d68d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a038a75dabfb984fcb3a983de4556d68d">parse_jpeg</a> (const char *data, size_t length, size_t &amp;width, size_t &amp;height, size_t &amp;channels)</td></tr>
<tr class="separator:a038a75dabfb984fcb3a983de4556d68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac1a9b3f0a93e841933c44c72ddf2c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#abac1a9b3f0a93e841933c44c72ddf2c5">parse_png</a> (const char *data, size_t length, size_t &amp;width, size_t &amp;height, size_t &amp;channels)</td></tr>
<tr class="separator:abac1a9b3f0a93e841933c44c72ddf2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d7a190d06b8c451159379b0648ee6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a38d7a190d06b8c451159379b0648ee6c">boost_parse_image</a> (std::string filename, size_t &amp;width, size_t &amp;height, size_t &amp;channels, <a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1be">Format</a> &amp;format, size_t &amp;image_data_size, std::string format_string)</td></tr>
<tr class="separator:a38d7a190d06b8c451159379b0648ee6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156b50aa4a360da0f21c4797e608a685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a156b50aa4a360da0f21c4797e608a685">boost_read_image</a> (std::string filename, char **out_data, size_t &amp;width, size_t &amp;height, size_t &amp;channels, <a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1be">Format</a> &amp;format, size_t &amp;image_data_size, std::string format_string)</td></tr>
<tr class="separator:a156b50aa4a360da0f21c4797e608a685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df09423ccd9d8dfeccd98adf9c6287f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a9df09423ccd9d8dfeccd98adf9c6287f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &amp;other)</td></tr>
<tr class="separator:a9df09423ccd9d8dfeccd98adf9c6287f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4187e63c2a35218e0b8c574657012b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a4b4187e63c2a35218e0b8c574657012b">infer_type_of_list</a> (const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;vec)</td></tr>
<tr class="separator:a4b4187e63c2a35218e0b8c574657012b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f09d91617696aa2a93dae054142c4e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a26f09d91617696aa2a93dae054142c4e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;other)</td></tr>
<tr class="separator:a26f09d91617696aa2a93dae054142c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07b18042dc57af0299bda68a1a68a95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__turilogger.html#gae07b18042dc57af0299bda68a1a68a95">begin_log_rotation</a> (std::string log_file_name, size_t log_interval, size_t truncate_limit)</td></tr>
<tr class="separator:gae07b18042dc57af0299bda68a1a68a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff3de78d5d1e8ab742cf8c185db5f7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a6ff3de78d5d1e8ab742cf8c185db5f7a">stop_log_rotation</a> ()</td></tr>
<tr class="separator:a6ff3de78d5d1e8ab742cf8c185db5f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb5999683f3468d3a758648743563ba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadfb5999683f3468d3a758648743563ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#gadfb5999683f3468d3a758648743563ba">atomic_compare_and_swap</a> (T &amp;a, T oldval, T newval)</td></tr>
<tr class="separator:gadfb5999683f3468d3a758648743563ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dbc02ef0d719802daae98fb9131423d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8dbc02ef0d719802daae98fb9131423d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#ga8dbc02ef0d719802daae98fb9131423d">atomic_compare_and_swap</a> (volatile T &amp;a, T oldval, T newval)</td></tr>
<tr class="separator:ga8dbc02ef0d719802daae98fb9131423d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a15654a80afea264bde55b177e8b212"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a15654a80afea264bde55b177e8b212"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#ga0a15654a80afea264bde55b177e8b212">atomic_compare_and_swap_val</a> (T &amp;a, T oldval, T newval)</td></tr>
<tr class="separator:ga0a15654a80afea264bde55b177e8b212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9038e6507be6a3b1ae3416d483c7ebb1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9038e6507be6a3b1ae3416d483c7ebb1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#ga9038e6507be6a3b1ae3416d483c7ebb1">atomic_compare_and_swap_val</a> (volatile T &amp;a, T oldval, T newval)</td></tr>
<tr class="separator:ga9038e6507be6a3b1ae3416d483c7ebb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76df639dc6e8f0e95e236d70851bd28c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga76df639dc6e8f0e95e236d70851bd28c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#ga76df639dc6e8f0e95e236d70851bd28c">atomic_compare_and_swap</a> (volatile double &amp;a, double oldval, double newval)</td></tr>
<tr class="separator:ga76df639dc6e8f0e95e236d70851bd28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9989e28a2984767656bf297f8e42de2"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:gab9989e28a2984767656bf297f8e42de2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#gab9989e28a2984767656bf297f8e42de2">atomic_compare_and_swap</a> (volatile float &amp;a, float oldval, float newval)</td></tr>
<tr class="separator:gab9989e28a2984767656bf297f8e42de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39393e3121fad2f4922c8db98c1c5a23"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga39393e3121fad2f4922c8db98c1c5a23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#ga39393e3121fad2f4922c8db98c1c5a23">atomic_exchange</a> (T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:ga39393e3121fad2f4922c8db98c1c5a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically exchanges the values of a and b.  <a href="group__threading.html#ga39393e3121fad2f4922c8db98c1c5a23">More...</a><br /></td></tr>
<tr class="separator:ga39393e3121fad2f4922c8db98c1c5a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92311e93877e88bc3a8c0a2c914f762"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf92311e93877e88bc3a8c0a2c914f762"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#gaf92311e93877e88bc3a8c0a2c914f762">atomic_exchange</a> (volatile T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:gaf92311e93877e88bc3a8c0a2c914f762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically exchanges the values of a and b.  <a href="group__threading.html#gaf92311e93877e88bc3a8c0a2c914f762">More...</a><br /></td></tr>
<tr class="separator:gaf92311e93877e88bc3a8c0a2c914f762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c9b2ac8cd6e2ea9d83208a9675a7cd7"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4c9b2ac8cd6e2ea9d83208a9675a7cd7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#ga4c9b2ac8cd6e2ea9d83208a9675a7cd7">fetch_and_store</a> (T &amp;a, const T &amp;newval)</td></tr>
<tr class="memdesc:ga4c9b2ac8cd6e2ea9d83208a9675a7cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically sets a to the newval, returning the old value. <br /></td></tr>
<tr class="separator:ga4c9b2ac8cd6e2ea9d83208a9675a7cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744006aadcfef2e6ff34c7b2ac8e76c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a744006aadcfef2e6ff34c7b2ac8e76c5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a744006aadcfef2e6ff34c7b2ac8e76c5">atomic_set_max</a> (T &amp;max_value, T new_value)</td></tr>
<tr class="separator:a744006aadcfef2e6ff34c7b2ac8e76c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd991361ce193704dfdf10108cf013b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecd991361ce193704dfdf10108cf013b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#aecd991361ce193704dfdf10108cf013b">atomic_set_max</a> (volatile T &amp;max_value, T new_value)</td></tr>
<tr class="separator:aecd991361ce193704dfdf10108cf013b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab229d7b848f9bdc386c756d57cacfa17"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab229d7b848f9bdc386c756d57cacfa17"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ab229d7b848f9bdc386c756d57cacfa17">atomic_set_min</a> (T &amp;min_value, T new_value)</td></tr>
<tr class="separator:ab229d7b848f9bdc386c756d57cacfa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ba5183fe200d8080585aeaad049748"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71ba5183fe200d8080585aeaad049748"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a71ba5183fe200d8080585aeaad049748">atomic_set_min</a> (volatile T &amp;min_value, T new_value)</td></tr>
<tr class="separator:a71ba5183fe200d8080585aeaad049748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086b1dff0f102785fb75fddf9fb9b436"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = int&gt; </td></tr>
<tr class="memitem:a086b1dff0f102785fb75fddf9fb9b436"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a086b1dff0f102785fb75fddf9fb9b436">atomic_increment</a> (T &amp;value, const U &amp;increment=1, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_integral&lt; U &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:a086b1dff0f102785fb75fddf9fb9b436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadecbb3af09801b00cab2f2a2bafa11d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = int&gt; </td></tr>
<tr class="memitem:aadecbb3af09801b00cab2f2a2bafa11d"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#aadecbb3af09801b00cab2f2a2bafa11d">atomic_increment</a> (volatile T &amp;value, const U &amp;increment=1, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_integral&lt; U &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:aadecbb3af09801b00cab2f2a2bafa11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6908d494c9441dac770d1ba74651b3e5"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga6908d494c9441dac770d1ba74651b3e5">execute_task_in_native_thread</a> (const std::function&lt; void(void)&gt; &amp;fn)</td></tr>
<tr class="separator:ga6908d494c9441dac770d1ba74651b3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc576e62a6ee3e65da2ac00c3571049"><td class="memTemplParams" colspan="2">template&lt;typename F , typename ... Args&gt; </td></tr>
<tr class="memitem:a5dc576e62a6ee3e65da2ac00c3571049"><td class="memTemplItemLeft" align="right" valign="top">std::result_of&lt; F(Args...)&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a5dc576e62a6ee3e65da2ac00c3571049">run_as_native</a> (F f, Args... args)</td></tr>
<tr class="separator:a5dc576e62a6ee3e65da2ac00c3571049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e5d72eafe277424284997a198212730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#ga1e5d72eafe277424284997a198212730">in_parallel</a> (const std::function&lt; void(size_t thread_id, size_t num_threads)&gt; &amp;fn)</td></tr>
<tr class="separator:ga1e5d72eafe277424284997a198212730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae01665f82adc1cb33d894854b82002ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1thread__pool.html">thread_pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threading.html#gae01665f82adc1cb33d894854b82002ed">get_parfor_thread_pool</a> ()</td></tr>
<tr class="separator:gae01665f82adc1cb33d894854b82002ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac532f68a1b4c1c4b4d42ffd0fdff2784"><td class="memTemplParams" colspan="2">template&lt;typename FunctionType &gt; </td></tr>
<tr class="memitem:gac532f68a1b4c1c4b4d42ffd0fdff2784"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#gac532f68a1b4c1c4b4d42ffd0fdff2784">parallel_for</a> (size_t begin, size_t end, const FunctionType &amp;fn)</td></tr>
<tr class="separator:gac532f68a1b4c1c4b4d42ffd0fdff2784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5df1c3139afa10b171ec12294bccc9"><td class="memTemplParams" colspan="2">template&lt;typename FunctionType , typename ReduceType &gt; </td></tr>
<tr class="memitem:ga3b5df1c3139afa10b171ec12294bccc9"><td class="memTemplItemLeft" align="right" valign="top">ReduceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#ga3b5df1c3139afa10b171ec12294bccc9">fold_reduce</a> (size_t begin, size_t end, const FunctionType &amp;fn, ReduceType base=ReduceType())</td></tr>
<tr class="separator:ga3b5df1c3139afa10b171ec12294bccc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7962653131f407609d083726b076eb74"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename FunctionType &gt; </td></tr>
<tr class="memitem:ga7962653131f407609d083726b076eb74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__threading.html#ga7962653131f407609d083726b076eb74">parallel_for</a> (RandomAccessIterator iter_begin, RandomAccessIterator iter_end, const FunctionType &amp;fn, std::random_access_iterator_tag=typename std::iterator_traits&lt; RandomAccessIterator &gt;::iterator_category())</td></tr>
<tr class="separator:ga7962653131f407609d083726b076eb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade42955781626642fc721b24ce67cfb5"><td class="memItemLeft" align="right" valign="top"><a id="ade42955781626642fc721b24ce67cfb5"></a>
<a class="el" href="classturi_1_1thread.html">thread</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ade42955781626642fc721b24ce67cfb5">launch_in_new_thread</a> (const boost::function&lt; void(void)&gt; &amp;f, size_t cpuid=size_t(-1))</td></tr>
<tr class="memdesc:ade42955781626642fc721b24ce67cfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs f in a new thread. convenience function for creating a new thread quickly. <br /></td></tr>
<tr class="separator:ade42955781626642fc721b24ce67cfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50858708e6b493a8725bbb40d992bff4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga50858708e6b493a8725bbb40d992bff4">download_url</a> (std::string url, std::string output_file)</td></tr>
<tr class="separator:ga50858708e6b493a8725bbb40d992bff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae775e307f6819797b5508a362f3a7853"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; int, bool, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gae775e307f6819797b5508a362f3a7853">download_url</a> (std::string url)</td></tr>
<tr class="separator:gae775e307f6819797b5508a362f3a7853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bb1f3b0e8696eb7a9e54404d14ef3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ab5bb1f3b0e8696eb7a9e54404d14ef3a">get_curl_error_string</a> (int status)</td></tr>
<tr class="separator:ab5bb1f3b0e8696eb7a9e54404d14ef3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd9dba3d987eefb44d8a272d0030497"><td class="memItemLeft" align="right" valign="top">Aws::S3::S3Client&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga7cd9dba3d987eefb44d8a272d0030497">init_aws_sdk_with_turi_env</a> (<a class="el" href="structturi_1_1s3url.html">s3url</a> &amp;parsed_url)</td></tr>
<tr class="separator:ga7cd9dba3d987eefb44d8a272d0030497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff7eac62175d5e5bac69a32ba1fee75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga5ff7eac62175d5e5bac69a32ba1fee75">get_s3_file_last_modified</a> (const std::string &amp;url)</td></tr>
<tr class="separator:ga5ff7eac62175d5e5bac69a32ba1fee75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d061c799a90c5c6a03728ef3de03d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1list__objects__response.html">list_objects_response</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga5d061c799a90c5c6a03728ef3de03d07">list_objects</a> (std::string s3_url, std::string proxy=&quot;&quot;)</td></tr>
<tr class="separator:ga5d061c799a90c5c6a03728ef3de03d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga234867c61a56b4fa2622e0f672084360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1list__objects__response.html">list_objects_response</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga234867c61a56b4fa2622e0f672084360">list_directory</a> (std::string s3_url, std::string proxy=&quot;&quot;)</td></tr>
<tr class="separator:ga234867c61a56b4fa2622e0f672084360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b22e913c89f6de93fbbd479c4dbbe9c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga4b22e913c89f6de93fbbd479c4dbbe9c">delete_object</a> (std::string s3_url, std::string proxy=&quot;&quot;)</td></tr>
<tr class="separator:ga4b22e913c89f6de93fbbd479c4dbbe9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga717b2264a5a6bb05f6c2435b9cb4e7cc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga717b2264a5a6bb05f6c2435b9cb4e7cc">delete_prefix</a> (std::string s3_url, std::string proxy=&quot;&quot;)</td></tr>
<tr class="separator:ga717b2264a5a6bb05f6c2435b9cb4e7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814071ebbbb49a2ba27bace0540a09db"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga814071ebbbb49a2ba27bace0540a09db">sanitize_s3_url</a> (const std::string &amp;url)</td></tr>
<tr class="separator:ga814071ebbbb49a2ba27bace0540a09db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6d447052f83d9bbc19c83ba1765351"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga6c6d447052f83d9bbc19c83ba1765351">parse_s3url</a> (const std::string &amp;url, <a class="el" href="structturi_1_1s3url.html">s3url</a> &amp;ret, std::string &amp;err_msg)</td></tr>
<tr class="separator:ga6c6d447052f83d9bbc19c83ba1765351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a3799347c103129ae70805e0161a6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga5a3799347c103129ae70805e0161a6ff">set_upload_timeout</a> (long timeout)</td></tr>
<tr class="separator:ga5a3799347c103129ae70805e0161a6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c38590a0ad13fa63e4d25a366b653a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga2c38590a0ad13fa63e4d25a366b653a3">set_download_timeout</a> (long timeout)</td></tr>
<tr class="separator:ga2c38590a0ad13fa63e4d25a366b653a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77744d8898a95679d4f8c399767728b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga77744d8898a95679d4f8c399767728b0">sanitize_url</a> (std::string url)</td></tr>
<tr class="separator:ga77744d8898a95679d4f8c399767728b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a39d09df58879b880f0ba2102ec047f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga6a39d09df58879b880f0ba2102ec047f">get_system_user_name</a> ()</td></tr>
<tr class="separator:ga6a39d09df58879b880f0ba2102ec047f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a7014c73f094ce56bb700d684fd08d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga49a7014c73f094ce56bb700d684fd08d">get_temp_name</a> (const std::string &amp;prefix=&quot;&quot;, bool _prefer_hdfs=false)</td></tr>
<tr class="separator:ga49a7014c73f094ce56bb700d684fd08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bea12507112de131eebd578bccfcb89"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga8bea12507112de131eebd578bccfcb89">get_temp_name_prefer_hdfs</a> (const std::string &amp;prefix=&quot;&quot;)</td></tr>
<tr class="separator:ga8bea12507112de131eebd578bccfcb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga843b3c39ee4383fdbe606debcf5273c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga843b3c39ee4383fdbe606debcf5273c7">delete_temp_file</a> (std::string s)</td></tr>
<tr class="separator:ga843b3c39ee4383fdbe606debcf5273c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a38eeb40011aa24012d90a46e53689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga97a38eeb40011aa24012d90a46e53689">delete_temp_files</a> (std::vector&lt; std::string &gt; files)</td></tr>
<tr class="separator:ga97a38eeb40011aa24012d90a46e53689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc7f2e18c38aae6132d2da2b50a08d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#gaadc7f2e18c38aae6132d2da2b50a08d8">reap_unused_temp_files</a> ()</td></tr>
<tr class="separator:gaadc7f2e18c38aae6132d2da2b50a08d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9148e7456c812a233d184699e377c959"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga9148e7456c812a233d184699e377c959">reap_current_process_temp_files</a> ()</td></tr>
<tr class="separator:ga9148e7456c812a233d184699e377c959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga904c193b58d4fefe5737c11a8bd2f961"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga904c193b58d4fefe5737c11a8bd2f961">get_temp_directories</a> ()</td></tr>
<tr class="separator:ga904c193b58d4fefe5737c11a8bd2f961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938d93ca534d16a0946cba20516890f7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fileio.html#ga938d93ca534d16a0946cba20516890f7">num_temp_directories</a> ()</td></tr>
<tr class="separator:ga938d93ca534d16a0946cba20516890f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d9fd43fcb1100a7727348c160ee618"><td class="memTemplParams" colspan="2">template&lt;typename OutArcType , typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga28d9fd43fcb1100a7727348c160ee618"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#ga28d9fd43fcb1100a7727348c160ee618">serialize_iterator</a> (OutArcType &amp;oarc, RandomAccessIterator begin, RandomAccessIterator end)</td></tr>
<tr class="memdesc:ga28d9fd43fcb1100a7727348c160ee618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the contents between the iterators begin and end.  <a href="group__group__serialization.html#ga28d9fd43fcb1100a7727348c160ee618">More...</a><br /></td></tr>
<tr class="separator:ga28d9fd43fcb1100a7727348c160ee618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadddae6e8816fdec445adc5b3d1814a31"><td class="memTemplParams" colspan="2">template&lt;typename OutArcType , typename InputIterator &gt; </td></tr>
<tr class="memitem:gadddae6e8816fdec445adc5b3d1814a31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#gadddae6e8816fdec445adc5b3d1814a31">serialize_iterator</a> (OutArcType &amp;oarc, InputIterator begin, InputIterator end, size_t vsize)</td></tr>
<tr class="memdesc:gadddae6e8816fdec445adc5b3d1814a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes the contents between the iterators begin and end.  <a href="group__group__serialization.html#gadddae6e8816fdec445adc5b3d1814a31">More...</a><br /></td></tr>
<tr class="separator:gadddae6e8816fdec445adc5b3d1814a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02a0b56eec87ca656509579520c36b9c"><td class="memTemplParams" colspan="2">template&lt;typename InArcType , typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga02a0b56eec87ca656509579520c36b9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#ga02a0b56eec87ca656509579520c36b9c">deserialize_iterator</a> (InArcType &amp;iarc, OutputIterator result)</td></tr>
<tr class="memdesc:ga02a0b56eec87ca656509579520c36b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accompanying function to <a class="el" href="group__group__serialization.html#ga28d9fd43fcb1100a7727348c160ee618" title="Serializes the contents between the iterators begin and end. ">serialize_iterator()</a> Reads elements from the stream and writes it to the output iterator.  <a href="group__group__serialization.html#ga02a0b56eec87ca656509579520c36b9c">More...</a><br /></td></tr>
<tr class="separator:ga02a0b56eec87ca656509579520c36b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ff5a70d5a9b9c65a94eb432c2b5ee33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8ff5a70d5a9b9c65a94eb432c2b5ee33"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#ga8ff5a70d5a9b9c65a94eb432c2b5ee33">serialize_to_string</a> (const T &amp;t)</td></tr>
<tr class="memdesc:ga8ff5a70d5a9b9c65a94eb432c2b5ee33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a object to a string.  <a href="group__group__serialization.html#ga8ff5a70d5a9b9c65a94eb432c2b5ee33">More...</a><br /></td></tr>
<tr class="separator:ga8ff5a70d5a9b9c65a94eb432c2b5ee33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfa7b3064bbe1c7b3cd195d1063760aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadfa7b3064bbe1c7b3cd195d1063760aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__serialization.html#gadfa7b3064bbe1c7b3cd195d1063760aa">deserialize_from_string</a> (const std::string &amp;s, T &amp;t)</td></tr>
<tr class="memdesc:gadfa7b3064bbe1c7b3cd195d1063760aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes a object from a string.  <a href="group__group__serialization.html#gadfa7b3064bbe1c7b3cd195d1063760aa">More...</a><br /></td></tr>
<tr class="separator:gadfa7b3064bbe1c7b3cd195d1063760aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa10744bd79ea1690d46f800c003c2a94"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename TransformFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gaa10744bd79ea1690d46f800c003c2a94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#gaa10744bd79ea1690d46f800c003c2a94">transform</a> (S &amp;&amp;input, T &amp;&amp;output, TransformFn transformfn, std::set&lt; size_t &gt; constraint_segments=std::set&lt; size_t &gt;())</td></tr>
<tr class="separator:gaa10744bd79ea1690d46f800c003c2a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d2d6771502a9e4b3dcc6518611fbe95"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename FilterFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga9d2d6771502a9e4b3dcc6518611fbe95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#ga9d2d6771502a9e4b3dcc6518611fbe95">copy_if</a> (S &amp;&amp;input, T &amp;&amp;output, FilterFn filterfn, std::set&lt; size_t &gt; constraint_segments=std::set&lt; size_t &gt;(), size_t random_seed=size_t(-1))</td></tr>
<tr class="separator:ga9d2d6771502a9e4b3dcc6518611fbe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d178d3bf3b12b8bfcae1b24e2e56e0a"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename FilterFn , typename TransformFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga4d178d3bf3b12b8bfcae1b24e2e56e0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#ga4d178d3bf3b12b8bfcae1b24e2e56e0a">copy_transform_if</a> (S &amp;&amp;input, T &amp;&amp;output, FilterFn filterfn, TransformFn transformfn, std::set&lt; size_t &gt; constraint_segments=std::set&lt; size_t &gt;(), size_t random_seed=size_t(-1))</td></tr>
<tr class="separator:ga4d178d3bf3b12b8bfcae1b24e2e56e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad750d10d75a759cde25e098d0105271b"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename FilterFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gad750d10d75a759cde25e098d0105271b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#gad750d10d75a759cde25e098d0105271b">split</a> (S &amp;&amp;input, T &amp;&amp;output1, T &amp;&amp;output2, FilterFn filterfn, size_t random_seed=std::time(NULL))</td></tr>
<tr class="separator:gad750d10d75a759cde25e098d0105271b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga085e14fe4c4747d6be6088737cec74e8"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename SWriter , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;SWriter&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga085e14fe4c4747d6be6088737cec74e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#ga085e14fe4c4747d6be6088737cec74e8">copy</a> (Iterator begin, Iterator end, SWriter &amp;&amp;writer)</td></tr>
<tr class="separator:ga085e14fe4c4747d6be6088737cec74e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebfc93a81ed0e7cd138f107f26e0ad2c"><td class="memTemplParams" colspan="2">template&lt;typename S , typename Iterator , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gaebfc93a81ed0e7cd138f107f26e0ad2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#gaebfc93a81ed0e7cd138f107f26e0ad2c">copy</a> (S &amp;&amp;array, Iterator output, size_t limit=(size_t)(-1))</td></tr>
<tr class="separator:gaebfc93a81ed0e7cd138f107f26e0ad2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73eec4b557bb91e92b781c26df159a6"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename S , typename FunctionType , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gad73eec4b557bb91e92b781c26df159a6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; ResultType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#gad73eec4b557bb91e92b781c26df159a6">reduce</a> (S &amp;&amp;input, FunctionType f, ResultType init=ResultType())</td></tr>
<tr class="separator:gad73eec4b557bb91e92b781c26df159a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e52ecf89923b7a8dd68db7840576e69"><td class="memTemplParams" colspan="2">template&lt;typename S1 , typename S2 , typename T , typename TransformFn , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S1&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S2&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga3e52ecf89923b7a8dd68db7840576e69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#ga3e52ecf89923b7a8dd68db7840576e69">binary_transform</a> (S1 &amp;&amp;input1, S2 &amp;&amp;input2, T &amp;&amp;output, TransformFn transformfn)</td></tr>
<tr class="separator:ga3e52ecf89923b7a8dd68db7840576e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385afe1bdc7987d31b716bd117aec241"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;S&gt;::value&gt;::type, typename  = typename std::enable_if&lt;sframe_impl::is_sarray_like&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga385afe1bdc7987d31b716bd117aec241"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__eager__algorithms.html#ga385afe1bdc7987d31b716bd117aec241">copy_range</a> (S &amp;&amp;input, T &amp;&amp;output, size_t start, size_t step, size_t end)</td></tr>
<tr class="separator:ga385afe1bdc7987d31b716bd117aec241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dfdcf9d3e54751fde1eafafd5b15e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__csv__utils.html#ga6dfdcf9d3e54751fde1eafafd5b15e2d">parallel_dataframe_iterate</a> (const <a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a> &amp;df, std::function&lt; void(<a class="el" href="classturi_1_1dataframe__row__iterator.html">dataframe_row_iterator</a> &amp;iter, size_t startrow, size_t endrow)&gt; partialrowfn)</td></tr>
<tr class="separator:ga6dfdcf9d3e54751fde1eafafd5b15e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa75ddff4dad3bde4e20c01bb4f038464"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__groupby__aggregate.html#gaa75ddff4dad3bde4e20c01bb4f038464">get_builtin_group_aggregator</a> (const std::string &amp;)</td></tr>
<tr class="separator:gaa75ddff4dad3bde4e20c01bb4f038464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f524221cf7cf02af960b90b93f120a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__groupby__aggregate.html#ga77f524221cf7cf02af960b90b93f120a">group</a> (<a class="el" href="classturi_1_1sframe.html">sframe</a> sframe_in, std::string key_column)</td></tr>
<tr class="separator:ga77f524221cf7cf02af960b90b93f120a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c719d63eb3444a673e8899c33c8496e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__groupby__aggregate.html#ga8c719d63eb3444a673e8899c33c8496e">groupby_aggregate</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;source, const std::vector&lt; std::string &gt; &amp;<a class="el" href="group__set__and__map.html#ga918b8235a3af13f02053fdf76c17ae83">keys</a>, const std::vector&lt; std::string &gt; &amp;group_output_columns, const std::vector&lt; std::pair&lt; std::vector&lt; std::string &gt;, std::shared_ptr&lt; <a class="el" href="classturi_1_1group__aggregate__value.html">group_aggregate_value</a> &gt;&gt;&gt; &amp;groups, size_t max_buffer_size=<a class="el" href="group__sframe__main.html#gaff6a4d5002d4a34ebd125418f019ef9f">SFRAME_GROUPBY_BUFFER_NUM_ROWS</a>)</td></tr>
<tr class="separator:ga8c719d63eb3444a673e8899c33c8496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa67328df13fb59f29d719ce7f6773a37"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__csv__utils.html#gaa67328df13fb59f29d719ce7f6773a37">eol_safe_getline</a> (std::istream &amp;is, std::string &amp;t)</td></tr>
<tr class="separator:gaa67328df13fb59f29d719ce7f6773a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c2dfa066b365cb7c087850b50a8371"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__csv__utils.html#ga47c2dfa066b365cb7c087850b50a8371">parse_csvs_to_sframe</a> (const std::string &amp;url, <a class="el" href="structturi_1_1csv__line__tokenizer.html">csv_line_tokenizer</a> &amp;tokenizer, <a class="el" href="structturi_1_1csv__file__handling__options.html">csv_file_handling_options</a> options, <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;frame, std::string frame_sidx_file=&quot;&quot;)</td></tr>
<tr class="separator:ga47c2dfa066b365cb7c087850b50a8371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5effb8e7794162f936f3d8d290b8032a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1index__file__information.html">index_file_information</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__internal.html#ga5effb8e7794162f936f3d8d290b8032a">read_index_file</a> (std::string index_file)</td></tr>
<tr class="separator:ga5effb8e7794162f936f3d8d290b8032a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3ed495f597573f2f3ecea79eefc6ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1group__index__file__information.html">group_index_file_information</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__internal.html#ga9f3ed495f597573f2f3ecea79eefc6ef">read_array_group_index_file</a> (std::string group_index_file)</td></tr>
<tr class="separator:ga9f3ed495f597573f2f3ecea79eefc6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga825377fbe8e33e782110c290c315d811"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__internal.html#ga825377fbe8e33e782110c290c315d811">write_array_group_index_file</a> (std::string group_index_file, const <a class="el" href="structturi_1_1group__index__file__information.html">group_index_file_information</a> &amp;info)</td></tr>
<tr class="separator:ga825377fbe8e33e782110c290c315d811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89888b7d7f2cff8698491a033d219084"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__internal.html#ga89888b7d7f2cff8698491a033d219084">parse_v2_segment_filename</a> (std::string fname)</td></tr>
<tr class="separator:ga89888b7d7f2cff8698491a033d219084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f23d791bd1d986c61cd39748ff2a09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga25f23d791bd1d986c61cd39748ff2a09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sarray__block__iterator.html">sarray_block_iterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga25f23d791bd1d986c61cd39748ff2a09">make_sarray_block_iterator</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt; &gt; &amp;data)</td></tr>
<tr class="separator:ga25f23d791bd1d986c61cd39748ff2a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd8b556a3ee14f1d63177cb56fdd14e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a3cd8b556a3ee14f1d63177cb56fdd14e">sframe_fast_compact</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;sf)</td></tr>
<tr class="separator:a3cd8b556a3ee14f1d63177cb56fdd14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916db418123be432c2fa91d4e2e04a7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a916db418123be432c2fa91d4e2e04a7c">sframe_compact</a> (<a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;sf, size_t segment_threshold)</td></tr>
<tr class="separator:a916db418123be432c2fa91d4e2e04a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6297d191a2e0f8845ea5f57bc125c4cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6297d191a2e0f8845ea5f57bc125c4cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a6297d191a2e0f8845ea5f57bc125c4cf">sarray_fast_compact</a> (<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt; &amp;column)</td></tr>
<tr class="separator:a6297d191a2e0f8845ea5f57bc125c4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af794f279568f80357f1a09d391510b2f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af794f279568f80357f1a09d391510b2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#af794f279568f80357f1a09d391510b2f">sarray_compact</a> (<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt; &amp;column, size_t segment_threshold)</td></tr>
<tr class="separator:af794f279568f80357f1a09d391510b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf172c11fbe7e659f98d883fdc0385c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaf172c11fbe7e659f98d883fdc0385c33">read_sframe_index_file</a> (std::string index_file)</td></tr>
<tr class="separator:gaf172c11fbe7e659f98d883fdc0385c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c729f5d7f2ff91f18a07fb3a2461f21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga0c729f5d7f2ff91f18a07fb3a2461f21">write_sframe_index_file</a> (std::string index_file, const <a class="el" href="structturi_1_1sframe__index__file__information.html">sframe_index_file_information</a> &amp;info)</td></tr>
<tr class="separator:ga0c729f5d7f2ff91f18a07fb3a2461f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e670aefa314e5d8c485de2c9e898a4b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga0e670aefa314e5d8c485de2c9e898a4b">sframe_row_to_csv</a> (const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;row, char *buf, size_t buflen)</td></tr>
<tr class="separator:ga0e670aefa314e5d8c485de2c9e898a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f05872e737224f8a66cfb9c12dff5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaf4f05872e737224f8a66cfb9c12dff5b">sframe_row_to_json</a> (const std::vector&lt; std::string &gt; &amp;column_names, const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;column_values, JSONNode &amp;node)</td></tr>
<tr class="separator:gaf4f05872e737224f8a66cfb9c12dff5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a3099662541190a08f5960a6758b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga83a3099662541190a08f5960a6758b01">sframe_save_naive</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;sf, std::string index_file)</td></tr>
<tr class="separator:ga83a3099662541190a08f5960a6758b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6169fd1854357f44ad1495dd02042a6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga6169fd1854357f44ad1495dd02042a6e">sframe_save_blockwise</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;sf, std::string index_file)</td></tr>
<tr class="separator:ga6169fd1854357f44ad1495dd02042a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c67fe18486ede18477e1c2edf4c9b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga3c67fe18486ede18477e1c2edf4c9b6d">sframe_save</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;sf, std::string index_file)</td></tr>
<tr class="separator:ga3c67fe18486ede18477e1c2edf4c9b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab39ab3d51730ade54ff39d465cd088a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gab39ab3d51730ade54ff39d465cd088a9">sframe_save_weak_reference</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;sf, std::string index_file)</td></tr>
<tr class="separator:gab39ab3d51730ade54ff39d465cd088a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6274ff53e5e6cdee836ea44e9524003a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga6274ff53e5e6cdee836ea44e9524003a">shuffle</a> (<a class="el" href="classturi_1_1sframe.html">sframe</a> sframe_in, size_t n, std::function&lt; size_t(const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;)&gt; hash_fn, std::function&lt; void(const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;, size_t)&gt; emit_call_back=std::function&lt; void(const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;, size_t)&gt;())</td></tr>
<tr class="separator:ga6274ff53e5e6cdee836ea44e9524003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga021ecc9d5e8e5483c70cf666749a6ced"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__compute.html#ga021ecc9d5e8e5483c70cf666749a6ced">hilbert_index_to_coordinate</a> (size_t s, size_t n)</td></tr>
<tr class="separator:ga021ecc9d5e8e5483c70cf666749a6ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa91b7bcebf08f381ae9ddfe0ba58fc46"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__compute.html#gaa91b7bcebf08f381ae9ddfe0ba58fc46">coordinate_to_hilbert_index</a> (std::pair&lt; size_t, size_t &gt; coord, size_t n)</td></tr>
<tr class="separator:gaa91b7bcebf08f381ae9ddfe0ba58fc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7621d1f2b3e2bfec3fc2dd6f97c1efcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__main.html#ga7621d1f2b3e2bfec3fc2dd6f97c1efcc">save_sgraph_to_json</a> (const <a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, std::string targetfile)</td></tr>
<tr class="separator:ga7621d1f2b3e2bfec3fc2dd6f97c1efcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ef9da0e05c69bf0b824e20ac66ed9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__main.html#ga76ef9da0e05c69bf0b824e20ac66ed9b">save_sgraph_to_csv</a> (const <a class="el" href="classturi_1_1sgraph.html">sgraph</a> &amp;g, std::string targetdir)</td></tr>
<tr class="separator:ga76ef9da0e05c69bf0b824e20ac66ed9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga326f55a2e76d8679966233cb2597a845"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga326f55a2e76d8679966233cb2597a845">get_local_ip</a> (bool print=true)</td></tr>
<tr class="separator:ga326f55a2e76d8679966233cb2597a845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce42155cbf6336409bfefcb603fffd7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga6ce42155cbf6336409bfefcb603fffd7">get_local_ip_as_str</a> (bool print=true)</td></tr>
<tr class="separator:ga6ce42155cbf6336409bfefcb603fffd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45990906bbd14e040226282c8b1b3bf1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga45990906bbd14e040226282c8b1b3bf1">get_free_tcp_port</a> ()</td></tr>
<tr class="separator:ga45990906bbd14e040226282c8b1b3bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec90d32dd2853a7a6d0ab348ee99cf5c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process__management.html#gaec90d32dd2853a7a6d0ab348ee99cf5c">get_parent_pid</a> ()</td></tr>
<tr class="separator:gaec90d32dd2853a7a6d0ab348ee99cf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae881ed75b07502551ff0d650a7fb4836"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ae881ed75b07502551ff0d650a7fb4836">get_my_pid</a> ()</td></tr>
<tr class="separator:ae881ed75b07502551ff0d650a7fb4836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d1427f3f5d16cddd0ba4b2ade43b68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process__management.html#ga31d1427f3f5d16cddd0ba4b2ade43b68">wait_for_parent_exit</a> (size_t parent_pid)</td></tr>
<tr class="separator:ga31d1427f3f5d16cddd0ba4b2ade43b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce426914b88ffd7fc91dfe13155b768"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process__management.html#ga9ce426914b88ffd7fc91dfe13155b768">is_process_running</a> (size_t pid)</td></tr>
<tr class="separator:ga9ce426914b88ffd7fc91dfe13155b768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8878be5d5e527b2a0b4f34126e93c0c5"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process__management.html#ga8878be5d5e527b2a0b4f34126e93c0c5">getenv_str</a> (const char *variable_name)</td></tr>
<tr class="separator:ga8878be5d5e527b2a0b4f34126e93c0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef88f7b1b9f09282d7ff2db1c11ed7e8"><td class="memItemLeft" align="right" valign="top">rdtsc_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaef88f7b1b9f09282d7ff2db1c11ed7e8">estimate_ticks_per_second</a> ()</td></tr>
<tr class="separator:gaef88f7b1b9f09282d7ff2db1c11ed7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6071c25cb81f5d2e5a99b13a53e6b48"><td class="memItemLeft" align="right" valign="top">rdtsc_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gae6071c25cb81f5d2e5a99b13a53e6b48">rdtsc</a> (void)</td></tr>
<tr class="separator:gae6071c25cb81f5d2e5a99b13a53e6b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d871f90185cac5c95fdb5c1aa3d88f"><td class="memItemLeft" align="right" valign="top">void EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ab9d871f90185cac5c95fdb5c1aa3d88f">configure_global_environment</a> (std::string argv0)</td></tr>
<tr class="separator:ab9d871f90185cac5c95fdb5c1aa3d88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a4ccf353c5cfe791a994b8015c0756"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2a4ccf353c5cfe791a994b8015c0756"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ac2a4ccf353c5cfe791a994b8015c0756">is_power_of_2</a> (const T &amp;x, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:ac2a4ccf353c5cfe791a994b8015c0756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825e793e44ba6ffa40e49e617620aee3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a825e793e44ba6ffa40e49e617620aee3"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a825e793e44ba6ffa40e49e617620aee3">bit_on</a> (T x, unsigned int bit, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:a825e793e44ba6ffa40e49e617620aee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57edf3dc1770310d695a5044dfefa445"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57edf3dc1770310d695a5044dfefa445"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a57edf3dc1770310d695a5044dfefa445">bit_off</a> (T x, unsigned int bit, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:a57edf3dc1770310d695a5044dfefa445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90a672c9c68e811c3bad2a78718d856"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae90a672c9c68e811c3bad2a78718d856"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ae90a672c9c68e811c3bad2a78718d856">set_bit_off</a> (T &amp;x, unsigned int bit, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:ae90a672c9c68e811c3bad2a78718d856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b07f83c28df8b76eccd2b581be5a87"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8b07f83c28df8b76eccd2b581be5a87"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#aa8b07f83c28df8b76eccd2b581be5a87">set_bit_on</a> (T &amp;x, unsigned int bit, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:aa8b07f83c28df8b76eccd2b581be5a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9f4fdffa17cc02e3f1200dd1b2aa23"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb9f4fdffa17cc02e3f1200dd1b2aa23"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#afb9f4fdffa17cc02e3f1200dd1b2aa23">flip_bit</a> (T &amp;x, unsigned int bit, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:afb9f4fdffa17cc02e3f1200dd1b2aa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2c6175e32dbeb0927d5fcfe3903943"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e2c6175e32dbeb0927d5fcfe3903943"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a1e2c6175e32dbeb0927d5fcfe3903943">bit_mask</a> (unsigned int n_bits, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:a1e2c6175e32dbeb0927d5fcfe3903943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4523487693a307060894e1e82db47654"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4523487693a307060894e1e82db47654"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a4523487693a307060894e1e82db47654">bit_mask</a> (size_t index_begin, unsigned int index_end, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:a4523487693a307060894e1e82db47654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3fc0a7fbd4acedcfe0961d6f4b3b39"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd3fc0a7fbd4acedcfe0961d6f4b3b39"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#afd3fc0a7fbd4acedcfe0961d6f4b3b39">num_bits_on</a> (T v, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:afd3fc0a7fbd4acedcfe0961d6f4b3b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e5046873151c5cba6294c03a39a3a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8e5046873151c5cba6294c03a39a3a4"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ac8e5046873151c5cba6294c03a39a3a4">n_trailing_zeros</a> (T v, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:ac8e5046873151c5cba6294c03a39a3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285e0576c00feceff6a7ea794ada1e42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a285e0576c00feceff6a7ea794ada1e42"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a285e0576c00feceff6a7ea794ada1e42">n_trailing_ones</a> (const T &amp;v, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:a285e0576c00feceff6a7ea794ada1e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099a2e1c2a154bf57ec26b704ed19d47"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a099a2e1c2a154bf57ec26b704ed19d47"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a099a2e1c2a154bf57ec26b704ed19d47">index_first_on_bit</a> (const T &amp;v, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:a099a2e1c2a154bf57ec26b704ed19d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf24bec9135a748a2bfa0ba11274abc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf24bec9135a748a2bfa0ba11274abc4"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#aaf24bec9135a748a2bfa0ba11274abc4">n_leading_zeros</a> (T v, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:aaf24bec9135a748a2bfa0ba11274abc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10551f02caef79c883e68d9b9297c71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab10551f02caef79c883e68d9b9297c71"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ab10551f02caef79c883e68d9b9297c71">n_leading_ones</a> (T v, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:ab10551f02caef79c883e68d9b9297c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236bc9bd292f41e87a06d55d83ea661d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a236bc9bd292f41e87a06d55d83ea661d"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a236bc9bd292f41e87a06d55d83ea661d">index_last_on_bit</a> (const T &amp;v, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:a236bc9bd292f41e87a06d55d83ea661d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b861f6c79684a64017182939866328"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a36b861f6c79684a64017182939866328"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a36b861f6c79684a64017182939866328">bitwise_log2_ceil</a> (const T &amp;v, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:a36b861f6c79684a64017182939866328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e89fa9579461a581d5d391b41ef614"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99e89fa9579461a581d5d391b41ef614"><td class="memTemplItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a99e89fa9579461a581d5d391b41ef614">bitwise_log2_floor</a> (const T &amp;v, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:a99e89fa9579461a581d5d391b41ef614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe28dbfc0d19d447e74ea77b4f858181"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe28dbfc0d19d447e74ea77b4f858181"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#abe28dbfc0d19d447e74ea77b4f858181">bitwise_pow2_mod</a> (const T &amp;v, unsigned pow2_idx, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:abe28dbfc0d19d447e74ea77b4f858181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17984781be5bb7adafe78ee2a6633dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad17984781be5bb7adafe78ee2a6633dc"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ad17984781be5bb7adafe78ee2a6633dc">first_n_bits_on</a> (const T &amp;v, unsigned int top_bit, _ENABLE_IF_UINT(T))</td></tr>
<tr class="separator:ad17984781be5bb7adafe78ee2a6633dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13e56e6235c6d9102a595e5a6551b0f"><td class="memItemLeft" align="right" valign="top">static uint128_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#gac13e56e6235c6d9102a595e5a6551b0f">hash128</a> (const char *s, size_t len)</td></tr>
<tr class="separator:gac13e56e6235c6d9102a595e5a6551b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga833de63737cec44cbd085928d4cb3b9b"><td class="memItemLeft" align="right" valign="top">static uint128_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga833de63737cec44cbd085928d4cb3b9b">hash128</a> (const std::string &amp;s)</td></tr>
<tr class="separator:ga833de63737cec44cbd085928d4cb3b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e95d8baebc2863b759b2002df6e2a3"><td class="memItemLeft" align="right" valign="top">static uint128_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#gaf9e95d8baebc2863b759b2002df6e2a3">hash128</a> (uint128_t v)</td></tr>
<tr class="separator:gaf9e95d8baebc2863b759b2002df6e2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae05675fd8f8fad394c4529f8a09f301"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaae05675fd8f8fad394c4529f8a09f301"><td class="memTemplItemLeft" align="right" valign="top">static uint128_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Hashing.html#gaae05675fd8f8fad394c4529f8a09f301">hash128</a> (const T &amp;v, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;sizeof(T)&lt;=8 &gt;::type *=0)</td></tr>
<tr class="separator:gaae05675fd8f8fad394c4529f8a09f301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080f8d56f65d94c54911dc72b3fcf032"><td class="memItemLeft" align="right" valign="top">static uint128_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga080f8d56f65d94c54911dc72b3fcf032">hash128</a> (uint64_t v)</td></tr>
<tr class="separator:ga080f8d56f65d94c54911dc72b3fcf032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga042f54564f1e4ea2b71eca7b135408ee"><td class="memItemLeft" align="right" valign="top">uint128_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga042f54564f1e4ea2b71eca7b135408ee">hash128</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;v)</td></tr>
<tr class="separator:ga042f54564f1e4ea2b71eca7b135408ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c6589a051b82bdb0746f3474c787f34"><td class="memItemLeft" align="right" valign="top">uint128_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga5c6589a051b82bdb0746f3474c787f34">hash128</a> (const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;v)</td></tr>
<tr class="separator:ga5c6589a051b82bdb0746f3474c787f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8db82e370c2cbb5f5799e83ce4993c64"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga8db82e370c2cbb5f5799e83ce4993c64">hash64</a> (const char *s, size_t len)</td></tr>
<tr class="separator:ga8db82e370c2cbb5f5799e83ce4993c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9307a9dac555cf5ee918e687f7eaef"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#gace9307a9dac555cf5ee918e687f7eaef">hash64</a> (const std::string &amp;s)</td></tr>
<tr class="separator:gace9307a9dac555cf5ee918e687f7eaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8ba44bad1642eab25d806c25a71c48"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#gaea8ba44bad1642eab25d806c25a71c48">hash64</a> (uint64_t v1, uint64_t v2)</td></tr>
<tr class="separator:gaea8ba44bad1642eab25d806c25a71c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f52a6c5161ca0a38cd6a065d83b8bb6"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga2f52a6c5161ca0a38cd6a065d83b8bb6">hash64</a> (uint64_t v1, uint64_t v2, uint64_t v3)</td></tr>
<tr class="separator:ga2f52a6c5161ca0a38cd6a065d83b8bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17a058e5f5a170433e33c6a29f64bfba"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga17a058e5f5a170433e33c6a29f64bfba">hash64</a> (uint128_t v)</td></tr>
<tr class="separator:ga17a058e5f5a170433e33c6a29f64bfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c8074ce6502b8b8377e438be458d38"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga73c8074ce6502b8b8377e438be458d38"><td class="memTemplItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga73c8074ce6502b8b8377e438be458d38">hash64</a> (const T &amp;v, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;sizeof(T)&lt;=8 &gt;::type *=0)</td></tr>
<tr class="separator:ga73c8074ce6502b8b8377e438be458d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00faa8f67cda7ebc57189704940bc34e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga00faa8f67cda7ebc57189704940bc34e">hash64</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;v)</td></tr>
<tr class="separator:ga00faa8f67cda7ebc57189704940bc34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dff69810f736e74d0e28891036da1a0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga5dff69810f736e74d0e28891036da1a0">hash64</a> (const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;v)</td></tr>
<tr class="separator:ga5dff69810f736e74d0e28891036da1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86e46ecdaf34b60260baded755c9e98a"><td class="memItemLeft" align="right" valign="top">static uint128_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga86e46ecdaf34b60260baded755c9e98a">hash128_combine</a> (uint128_t h1, uint128_t h2)</td></tr>
<tr class="separator:ga86e46ecdaf34b60260baded755c9e98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf9506b3bf4600b7fd989b6e8ca2c6de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabf9506b3bf4600b7fd989b6e8ca2c6de"><td class="memTemplItemLeft" align="right" valign="top">static uint128_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Hashing.html#gabf9506b3bf4600b7fd989b6e8ca2c6de">hash128_update</a> (uint128_t h, const T &amp;v)</td></tr>
<tr class="separator:gabf9506b3bf4600b7fd989b6e8ca2c6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa06596de86daa1007e026da61596c650"><td class="memItemLeft" align="right" valign="top">static uint128_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#gaa06596de86daa1007e026da61596c650">hash128</a> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="separator:gaa06596de86daa1007e026da61596c650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58686531b3a3c6cd2ba4c21d0e12f70d"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga58686531b3a3c6cd2ba4c21d0e12f70d">hash64_combine</a> (uint64_t h1, uint64_t h2)</td></tr>
<tr class="separator:ga58686531b3a3c6cd2ba4c21d0e12f70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f89e342a5cecb1d4c49c2a53f5b880"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga02f89e342a5cecb1d4c49c2a53f5b880">hash64_proportion_cutoff</a> (double proportion)</td></tr>
<tr class="separator:ga02f89e342a5cecb1d4c49c2a53f5b880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab923908a4686417dcf08ec92189b389"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaab923908a4686417dcf08ec92189b389"><td class="memTemplItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Hashing.html#gaab923908a4686417dcf08ec92189b389">hash64_update</a> (uint64_t h1, const T &amp;t)</td></tr>
<tr class="separator:gaab923908a4686417dcf08ec92189b389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5747bf77bc6fd3b767301568b47bba99"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#ga5747bf77bc6fd3b767301568b47bba99">hash64</a> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="separator:ga5747bf77bc6fd3b767301568b47bba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf536e4ae0a680d7e6752684a393ed259"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#gaf536e4ae0a680d7e6752684a393ed259">simple_random_mapping</a> (size_t index, size_t seed)</td></tr>
<tr class="separator:gaf536e4ae0a680d7e6752684a393ed259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14606329a9cab2d9e8613c1b83434c4"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#gac14606329a9cab2d9e8613c1b83434c4">index_hash</a> (uint64_t idx)</td></tr>
<tr class="separator:gac14606329a9cab2d9e8613c1b83434c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2fda34436a6e82e0eec28faf731ca00"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hashing.html#gac2fda34436a6e82e0eec28faf731ca00">reverse_index_hash</a> (uint64_t idx)</td></tr>
<tr class="separator:gac2fda34436a6e82e0eec28faf731ca00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab66ffb2f6cc64aeda89914d5a1eee4ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LessThan &gt; </td></tr>
<tr class="memitem:gab66ffb2f6cc64aeda89914d5a1eee4ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gab66ffb2f6cc64aeda89914d5a1eee4ba">extract_and_sort_top_k</a> (std::vector&lt; T &gt; &amp;v, size_t top_k, LessThan less_than)</td></tr>
<tr class="separator:gab66ffb2f6cc64aeda89914d5a1eee4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f5c8bed80f073bc71a67c4256f32c6b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8f5c8bed80f073bc71a67c4256f32c6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga8f5c8bed80f073bc71a67c4256f32c6b">extract_and_sort_top_k</a> (std::vector&lt; T &gt; &amp;v, size_t top_k)</td></tr>
<tr class="separator:ga8f5c8bed80f073bc71a67c4256f32c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963920bf11ee9d5069b14395b6e81cab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a963920bf11ee9d5069b14395b6e81cab">sigmoid</a> (double x)</td></tr>
<tr class="separator:a963920bf11ee9d5069b14395b6e81cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e4555283ef5773a9e2d0f7d9a35ada"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ad7e4555283ef5773a9e2d0f7d9a35ada">log1pe</a> (double x)</td></tr>
<tr class="separator:ad7e4555283ef5773a9e2d0f7d9a35ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6395f16416d199a2df25a21c31cdb0c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a6395f16416d199a2df25a21c31cdb0c2">log1pen</a> (double x)</td></tr>
<tr class="separator:a6395f16416d199a2df25a21c31cdb0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5600b7667813008a0a49e09e63ef3dc4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a5600b7667813008a0a49e09e63ef3dc4">log1me</a> (double x)</td></tr>
<tr class="separator:a5600b7667813008a0a49e09e63ef3dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89243ba817f3e0649f932f3d8519278e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a89243ba817f3e0649f932f3d8519278e">log1men</a> (double x)</td></tr>
<tr class="separator:a89243ba817f3e0649f932f3d8519278e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0877f2ccb7dbec498442c05d2a8af5a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a0877f2ccb7dbec498442c05d2a8af5a6">logem1</a> (double x)</td></tr>
<tr class="separator:a0877f2ccb7dbec498442c05d2a8af5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a04229ebad06076c37abc50d640c5e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a15a04229ebad06076c37abc50d640c5e">log1pe_deriviative</a> (double x)</td></tr>
<tr class="separator:a15a04229ebad06076c37abc50d640c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54021649246b9412defe52a7dce47e0c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a54021649246b9412defe52a7dce47e0c">log1pen_deriviative</a> (double x)</td></tr>
<tr class="separator:a54021649246b9412defe52a7dce47e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf635a8e0c8dccabee631e325b1eaa255"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaf635a8e0c8dccabee631e325b1eaa255">md5</a> (std::string val)</td></tr>
<tr class="separator:gaf635a8e0c8dccabee631e325b1eaa255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddf7bdfb5e773522e655b1df71f4e483"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaddf7bdfb5e773522e655b1df71f4e483">md5_raw</a> (std::string val)</td></tr>
<tr class="separator:gaddf7bdfb5e773522e655b1df71f4e483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af1928fccc818e6de7fd5fe6678e290"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7af1928fccc818e6de7fd5fe6678e290"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga7af1928fccc818e6de7fd5fe6678e290">set_union</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ga7af1928fccc818e6de7fd5fe6678e290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee4d699f48042a67ed1f71e1e6be3fb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaee4d699f48042a67ed1f71e1e6be3fb0"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gaee4d699f48042a67ed1f71e1e6be3fb0">set_union</a> (const std::set&lt; T &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:gaee4d699f48042a67ed1f71e1e6be3fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0d7468f40a2e70e35c89894650e91f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7f0d7468f40a2e70e35c89894650e91f"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga7f0d7468f40a2e70e35c89894650e91f">set_intersect</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ga7f0d7468f40a2e70e35c89894650e91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa640004c1b66ee7deee72aad2be1a1fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa640004c1b66ee7deee72aad2be1a1fd"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gaa640004c1b66ee7deee72aad2be1a1fd">set_difference</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:gaa640004c1b66ee7deee72aad2be1a1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f10ce6cf55bc8398732e39e505f40d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0f10ce6cf55bc8398732e39e505f40d8"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga0f10ce6cf55bc8398732e39e505f40d8">set_difference</a> (const std::set&lt; T &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:ga0f10ce6cf55bc8398732e39e505f40d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49cf0fc8a07964035ba1367163c76530"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga49cf0fc8a07964035ba1367163c76530"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::set&lt; T &gt;, std::set&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga49cf0fc8a07964035ba1367163c76530">set_partition</a> (const std::set&lt; T &gt; &amp;s, const std::set&lt; T &gt; &amp;partition)</td></tr>
<tr class="separator:ga49cf0fc8a07964035ba1367163c76530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ed37ec6a7d868f3f2bed57e3892fa5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga30ed37ec6a7d868f3f2bed57e3892fa5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga30ed37ec6a7d868f3f2bed57e3892fa5">set_disjoint</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ga30ed37ec6a7d868f3f2bed57e3892fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf05159a05408682fac0235c67617ccd6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf05159a05408682fac0235c67617ccd6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gaf05159a05408682fac0235c67617ccd6">set_equal</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:gaf05159a05408682fac0235c67617ccd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d160954cde68b1d8162674cc7bb2b4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1d160954cde68b1d8162674cc7bb2b4b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga1d160954cde68b1d8162674cc7bb2b4b">includes</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ga1d160954cde68b1d8162674cc7bb2b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64dd1de70d4064f285d74b84e3c225ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga64dd1de70d4064f285d74b84e3c225ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga64dd1de70d4064f285d74b84e3c225ed">is_subset</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ga64dd1de70d4064f285d74b84e3c225ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9725deb1ff553a82756f512004c63764"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9725deb1ff553a82756f512004c63764"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga9725deb1ff553a82756f512004c63764">is_superset</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ga9725deb1ff553a82756f512004c63764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d21432dcd23a6b815e3500fe003a6e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad4d21432dcd23a6b815e3500fe003a6e"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c&lt; boost::is_output_streamable&lt; T &gt;::value, std::ostream &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gad4d21432dcd23a6b815e3500fe003a6e">operator&lt;&lt;</a> (std::ostream &amp;out, const std::set&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:gad4d21432dcd23a6b815e3500fe003a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b57858a31a68a940133ccb5efcc30a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6b57858a31a68a940133ccb5efcc30a8"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c&lt; boost::is_output_streamable&lt; T &gt;::value, std::ostream &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga6b57858a31a68a940133ccb5efcc30a8">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:ga6b57858a31a68a940133ccb5efcc30a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc7d174128bc4ee0b190bf3ea1d22a4"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:gadcc7d174128bc4ee0b190bf3ea1d22a4"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gadcc7d174128bc4ee0b190bf3ea1d22a4">safe_get</a> (const std::map&lt; Key, T &gt; &amp;map, const Key &amp;key)</td></tr>
<tr class="separator:gadcc7d174128bc4ee0b190bf3ea1d22a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab451c4895d8fcc07bfd1db5133ed6d65"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:gab451c4895d8fcc07bfd1db5133ed6d65"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gab451c4895d8fcc07bfd1db5133ed6d65">safe_get</a> (const std::map&lt; Key, T &gt; &amp;map, const Key &amp;key, const T default_value)</td></tr>
<tr class="separator:gab451c4895d8fcc07bfd1db5133ed6d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390c075c51a2138b191a32c386e47123"><td class="memTemplParams" colspan="2">template&lt;typename OldKey , typename NewKey , typename T &gt; </td></tr>
<tr class="memitem:ga390c075c51a2138b191a32c386e47123"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; NewKey, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga390c075c51a2138b191a32c386e47123">rekey</a> (const std::map&lt; OldKey, T &gt; &amp;map, const std::map&lt; OldKey, NewKey &gt; &amp;key_map)</td></tr>
<tr class="separator:ga390c075c51a2138b191a32c386e47123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5f4841ffe82f3d489e6324df5fc55bb"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename OldT , typename NewT &gt; </td></tr>
<tr class="memitem:gaa5f4841ffe82f3d489e6324df5fc55bb"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, NewT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gaa5f4841ffe82f3d489e6324df5fc55bb">remap</a> (const std::map&lt; Key, OldT &gt; &amp;map, const std::map&lt; OldT, NewT &gt; &amp;val_map)</td></tr>
<tr class="separator:gaa5f4841ffe82f3d489e6324df5fc55bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe09ee740affe37455854c94dab256d"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:ga1fe09ee740affe37455854c94dab256d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga1fe09ee740affe37455854c94dab256d">remap</a> (std::map&lt; Key, T &gt; &amp;map, const std::map&lt; T, T &gt; &amp;val_map)</td></tr>
<tr class="separator:ga1fe09ee740affe37455854c94dab256d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga182022e0aedf35610cbd83df4d00b970"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:ga182022e0aedf35610cbd83df4d00b970"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga182022e0aedf35610cbd83df4d00b970">map_union</a> (const std::map&lt; Key, T &gt; &amp;a, const std::map&lt; Key, T &gt; &amp;b)</td></tr>
<tr class="separator:ga182022e0aedf35610cbd83df4d00b970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7c215e30f5cf8cfc448e41fd42ea3f"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:ga5a7c215e30f5cf8cfc448e41fd42ea3f"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga5a7c215e30f5cf8cfc448e41fd42ea3f">map_intersect</a> (const std::map&lt; Key, T &gt; &amp;a, const std::map&lt; Key, T &gt; &amp;b)</td></tr>
<tr class="separator:ga5a7c215e30f5cf8cfc448e41fd42ea3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070f56a9f638dd89ae3abd29ecc51ced"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:ga070f56a9f638dd89ae3abd29ecc51ced"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga070f56a9f638dd89ae3abd29ecc51ced">map_intersect</a> (const std::map&lt; Key, T &gt; &amp;m, const std::set&lt; Key &gt; &amp;<a class="el" href="group__set__and__map.html#ga918b8235a3af13f02053fdf76c17ae83">keys</a>)</td></tr>
<tr class="separator:ga070f56a9f638dd89ae3abd29ecc51ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd7a849a12403c9f817f6c828d610e71"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:gafd7a849a12403c9f817f6c828d610e71"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gafd7a849a12403c9f817f6c828d610e71">map_difference</a> (const std::map&lt; Key, T &gt; &amp;a, const std::map&lt; Key, T &gt; &amp;b)</td></tr>
<tr class="separator:gafd7a849a12403c9f817f6c828d610e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918b8235a3af13f02053fdf76c17ae83"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:ga918b8235a3af13f02053fdf76c17ae83"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; Key &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga918b8235a3af13f02053fdf76c17ae83">keys</a> (const std::map&lt; Key, T &gt; &amp;map)</td></tr>
<tr class="separator:ga918b8235a3af13f02053fdf76c17ae83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc412c824b0e2e840804ae166a479660"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:gadc412c824b0e2e840804ae166a479660"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Key &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gadc412c824b0e2e840804ae166a479660">keys_as_vector</a> (const std::map&lt; Key, T &gt; &amp;map)</td></tr>
<tr class="separator:gadc412c824b0e2e840804ae166a479660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4a5ba603bdef39e4c11f7d8692741c7"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:gaa4a5ba603bdef39e4c11f7d8692741c7"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gaa4a5ba603bdef39e4c11f7d8692741c7">values</a> (const std::map&lt; Key, T &gt; &amp;map)</td></tr>
<tr class="separator:gaa4a5ba603bdef39e4c11f7d8692741c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a53927dac9074547de03decf58eb40f"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:ga1a53927dac9074547de03decf58eb40f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga1a53927dac9074547de03decf58eb40f">values</a> (const std::map&lt; Key, T &gt; &amp;m, const std::set&lt; Key &gt; &amp;<a class="el" href="group__set__and__map.html#ga918b8235a3af13f02053fdf76c17ae83">keys</a>)</td></tr>
<tr class="separator:ga1a53927dac9074547de03decf58eb40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e027c432c0d1a7cac066ffb79b84dab"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:ga1e027c432c0d1a7cac066ffb79b84dab"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga1e027c432c0d1a7cac066ffb79b84dab">values</a> (const std::map&lt; Key, T &gt; &amp;m, const std::vector&lt; Key &gt; &amp;<a class="el" href="group__set__and__map.html#ga918b8235a3af13f02053fdf76c17ae83">keys</a>)</td></tr>
<tr class="separator:ga1e027c432c0d1a7cac066ffb79b84dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30e237a4d484b7780a44c2e4cdaeae71"><td class="memTemplParams" colspan="2">template&lt;typename Key &gt; </td></tr>
<tr class="memitem:ga30e237a4d484b7780a44c2e4cdaeae71"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, Key &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga30e237a4d484b7780a44c2e4cdaeae71">make_identity_map</a> (const std::set&lt; Key &gt; &amp;<a class="el" href="group__set__and__map.html#ga918b8235a3af13f02053fdf76c17ae83">keys</a>)</td></tr>
<tr class="separator:ga30e237a4d484b7780a44c2e4cdaeae71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d7b597ea46dad671b1e43a24c51b890"><td class="memTemplParams" colspan="2">
template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:ga4d7b597ea46dad671b1e43a24c51b890"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga4d7b597ea46dad671b1e43a24c51b890">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; Key, T &gt; &amp;m)</td></tr>
<tr class="memdesc:ga4d7b597ea46dad671b1e43a24c51b890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a map to the supplied stream. <br /></td></tr>
<tr class="separator:ga4d7b597ea46dad671b1e43a24c51b890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68acecae6e338898b59a4dc3884c5e5f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga68acecae6e338898b59a4dc3884c5e5f">trim</a> (const std::string &amp;str)</td></tr>
<tr class="separator:ga68acecae6e338898b59a4dc3884c5e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa74f7686ce2ca604b7f3a23fde8d5cb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa74f7686ce2ca604b7f3a23fde8d5cb0"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gaa74f7686ce2ca604b7f3a23fde8d5cb0">tostr</a> (const T &amp;t)</td></tr>
<tr class="separator:gaa74f7686ce2ca604b7f3a23fde8d5cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff6be992cb56daab2c3ea2b1e397dd1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0ff6be992cb56daab2c3ea2b1e397dd1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#ga0ff6be992cb56daab2c3ea2b1e397dd1">fromstr</a> (const std::string &amp;str)</td></tr>
<tr class="separator:ga0ff6be992cb56daab2c3ea2b1e397dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae49bfa1e11f3b5f2cb2c9627759788"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gaaae49bfa1e11f3b5f2cb2c9627759788">pad_number</a> (const size_t number, const size_t npad, const char pad_value='0')</td></tr>
<tr class="separator:gaaae49bfa1e11f3b5f2cb2c9627759788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad301875a885916024640226070ea0e4d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__set__and__map.html#gad301875a885916024640226070ea0e4d">strsplit</a> (const std::string &amp;str, const std::string &amp;splitchars, const bool auto_trim=false)</td></tr>
<tr class="separator:gad301875a885916024640226070ea0e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8d7c3f0f04ede23f92e66a341b8dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a0e8d7c3f0f04ede23f92e66a341b8dcb">_add_directory_to_deleter</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a0e8d7c3f0f04ede23f92e66a341b8dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae717505f642d859bacec10acbaf25ff2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ae717505f642d859bacec10acbaf25ff2">_get_unique_directory</a> (const std::string &amp;file, size_t line)</td></tr>
<tr class="separator:ae717505f642d859bacec10acbaf25ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4a1db7b70b67cf04197f3f7e6c95e9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gadc4a1db7b70b67cf04197f3f7e6c95e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gadc4a1db7b70b67cf04197f3f7e6c95e9">_save_and_load_object</a> (T &amp;dest, const U &amp;src, std::string dir)</td></tr>
<tr class="separator:gadc4a1db7b70b67cf04197f3f7e6c95e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0e2ccadc441f5863ce350a4a13cbb7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structturi_1_1ml__data__entry.html">ml_data_entry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a6d0e2ccadc441f5863ce350a4a13cbb7">translate_row_to_ml_data_entry</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;metadata, const std::vector&lt; <a class="el" href="structturi_1_1ml__data__entry__global__index.html">ml_data_entry_global_index</a> &gt; &amp;row)</td></tr>
<tr class="separator:a6d0e2ccadc441f5863ce350a4a13cbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd4ccaf03d4989c964b7d73653ef907"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structturi_1_1ml__data__entry.html">ml_data_entry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a2bd4ccaf03d4989c964b7d73653ef907">translate_row_to_ml_data_entry</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;metadata, const DenseVector &amp;row)</td></tr>
<tr class="separator:a2bd4ccaf03d4989c964b7d73653ef907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7543f0279215f40b8abdda5293e40f22"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structturi_1_1ml__data__entry.html">ml_data_entry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a7543f0279215f40b8abdda5293e40f22">translate_row_to_ml_data_entry</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;metadata, const SparseVector &amp;v)</td></tr>
<tr class="separator:a7543f0279215f40b8abdda5293e40f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449a1ee8679d98e9f4684d08d68b2e13"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a449a1ee8679d98e9f4684d08d68b2e13">translate_row_to_original</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;metadata, const DenseVector &amp;v)</td></tr>
<tr class="separator:a449a1ee8679d98e9f4684d08d68b2e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7148fa32f1857a7cc4df132c2f64af84"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a7148fa32f1857a7cc4df132c2f64af84">translate_row_to_original</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;metadata, const SparseVector &amp;v)</td></tr>
<tr class="separator:a7148fa32f1857a7cc4df132c2f64af84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ca8b3f0780a24c2d25863013d95d8e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#aa4ca8b3f0780a24c2d25863013d95d8e">translate_row_to_original</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;metadata, const std::vector&lt; <a class="el" href="structturi_1_1ml__data__entry__global__index.html">ml_data_entry_global_index</a> &gt; &amp;row)</td></tr>
<tr class="separator:aa4ca8b3f0780a24c2d25863013d95d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a473f1d62e742337465699da6367965"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a>, <a class="el" href="classturi_1_1ml__data.html">ml_data</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a8a473f1d62e742337465699da6367965">make_random_sframe_and_ml_data</a> (size_t n_rows, std::string column_types, bool create_target_column=false, bool target_column_categorical=false)</td></tr>
<tr class="separator:a8a473f1d62e742337465699da6367965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4c7093dd9c45bb94ea622b5e2d1751"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a5d4c7093dd9c45bb94ea622b5e2d1751">ml_testing_equals</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;v1, const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;v2)</td></tr>
<tr class="separator:a5d4c7093dd9c45bb94ea622b5e2d1751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e181638a581021583e9fb60c0c7a29"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a12e181638a581021583e9fb60c0c7a29">varmap_to_flexmap</a> (const variant_map_type &amp;map)</td></tr>
<tr class="separator:a12e181638a581021583e9fb60c0c7a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2b8f5911ab7feba4b935b857be0cc6"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a4b2b8f5911ab7feba4b935b857be0cc6">flexmap_to_varmap</a> (const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;map)</td></tr>
<tr class="separator:a4b2b8f5911ab7feba4b935b857be0cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d20f39e4623982dbe2b03fedbdf1374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a1d20f39e4623982dbe2b03fedbdf1374">create_unity_global_singleton</a> (<a class="el" href="classturi_1_1toolkit__function__registry.html">toolkit_function_registry</a> *_toolkit_functions, <a class="el" href="classturi_1_1toolkit__class__registry.html">toolkit_class_registry</a> *_classes)</td></tr>
<tr class="separator:a1d20f39e4623982dbe2b03fedbdf1374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2aa7d0c17d793a41e0d2e0fa4411a04"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1unity__global.html">unity_global</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ae2aa7d0c17d793a41e0d2e0fa4411a04">get_unity_global_singleton</a> ()</td></tr>
<tr class="separator:ae2aa7d0c17d793a41e0d2e0fa4411a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49aa840d12810de2e59ee965256b9713"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a49aa840d12810de2e59ee965256b9713">get_variant_which_name</a> (int i)</td></tr>
<tr class="separator:a49aa840d12810de2e59ee965256b9713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8eec97edcf72c280999c2f5e327e12"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc8eec97edcf72c280999c2f5e327e12"><td class="memTemplItemLeft" align="right" valign="top">static T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#adc8eec97edcf72c280999c2f5e327e12">variant_get_ref</a> (<a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;v)</td></tr>
<tr class="separator:adc8eec97edcf72c280999c2f5e327e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8290f1526266dd5dfc96b95110c4c0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e8290f1526266dd5dfc96b95110c4c0"><td class="memTemplItemLeft" align="right" valign="top">static const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a6e8290f1526266dd5dfc96b95110c4c0">variant_get_ref</a> (const <a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;v)</td></tr>
<tr class="separator:a6e8290f1526266dd5dfc96b95110c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f64942a3fd22be6c4823c5107a2bde"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95f64942a3fd22be6c4823c5107a2bde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a95f64942a3fd22be6c4823c5107a2bde">variant_set_value</a> (<a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;v, const T &amp;f)</td></tr>
<tr class="separator:a95f64942a3fd22be6c4823c5107a2bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4089b0a7d421bba15b1510e3816c11ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4089b0a7d421bba15b1510e3816c11ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a4089b0a7d421bba15b1510e3816c11ab">to_variant</a> (const T &amp;f)</td></tr>
<tr class="separator:a4089b0a7d421bba15b1510e3816c11ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895255301986d2f7bc3aa81a460e0f14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a895255301986d2f7bc3aa81a460e0f14"><td class="memTemplItemLeft" align="right" valign="top">std::decay&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a895255301986d2f7bc3aa81a460e0f14">variant_get_value</a> (const <a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;v)</td></tr>
<tr class="separator:a895255301986d2f7bc3aa81a460e0f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a1cd29c1b4f2058389f782411e6b1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ab2a1cd29c1b4f2058389f782411e6b1a">variant_deep_save</a> (const <a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;v, <a class="el" href="classturi_1_1oarchive.html">oarchive</a> &amp;oarc)</td></tr>
<tr class="separator:ab2a1cd29c1b4f2058389f782411e6b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9ab2fd16f9f9abcc4fde3f86e4b428"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade9ab2fd16f9f9abcc4fde3f86e4b428"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ade9ab2fd16f9f9abcc4fde3f86e4b428">variant_deep_save</a> (const T &amp;v, <a class="el" href="classturi_1_1oarchive.html">oarchive</a> &amp;oarc)</td></tr>
<tr class="separator:ade9ab2fd16f9f9abcc4fde3f86e4b428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1166aee6a6372142009d91bdd6a13d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a8f1166aee6a6372142009d91bdd6a13d">variant_deep_load</a> (<a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;v, <a class="el" href="classturi_1_1iarchive.html">iarchive</a> &amp;iarc)</td></tr>
<tr class="separator:a8f1166aee6a6372142009d91bdd6a13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3693451f85e001eb5311f4dcaceda27a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3693451f85e001eb5311f4dcaceda27a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a3693451f85e001eb5311f4dcaceda27a">variant_deep_load</a> (T &amp;v, <a class="el" href="classturi_1_1iarchive.html">iarchive</a> &amp;iarc)</td></tr>
<tr class="separator:a3693451f85e001eb5311f4dcaceda27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aac567773d5068dce533ce7420be04c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a2aac567773d5068dce533ce7420be04c">add_metadata</a> (CoreML::Specification::Model &amp;model_spec, const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;context)</td></tr>
<tr class="separator:a2aac567773d5068dce533ce7420be04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f198ba330dd013625dbf4b410a2567"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; coreml::MLModelWrapper &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#af8f198ba330dd013625dbf4b410a2567">export_linear_regression_as_model_asset</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;metadata, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;coefs, const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;context)</td></tr>
<tr class="separator:af8f198ba330dd013625dbf4b410a2567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219221c1a9c8d5c4eaa144d26a71418e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; coreml::MLModelWrapper &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a219221c1a9c8d5c4eaa144d26a71418e">export_linear_svm_as_model_asset</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;metadata, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;coefs, const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;context)</td></tr>
<tr class="separator:a219221c1a9c8d5c4eaa144d26a71418e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5b914fec49a52404c26b980ee6f44a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; coreml::MLModelWrapper &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#abb5b914fec49a52404c26b980ee6f44a">export_logistic_model_as_model_asset</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;metadata, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;coefs, const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;context)</td></tr>
<tr class="separator:abb5b914fec49a52404c26b980ee6f44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8f75adab79449ded48cf73fff58ac7"><td class="memItemLeft" align="right" valign="top">void EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a2f8f75adab79449ded48cf73fff58ac7">export_linear_regression_as_model_asset</a> (const std::string &amp;filename, const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;metadata, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;coefs, const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;context)</td></tr>
<tr class="separator:a2f8f75adab79449ded48cf73fff58ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2291d40ba400f9fed0fbcd55c20810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#aef2291d40ba400f9fed0fbcd55c20810">setup_pipeline_from_mldata</a> (CoreML::Pipeline &amp;pipeline, std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; metadata)</td></tr>
<tr class="separator:aef2291d40ba400f9fed0fbcd55c20810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea2a6da92509b0b7ae9f23a17b38154"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; coreml::MLModelWrapper &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#aeea2a6da92509b0b7ae9f23a17b38154">export_object_detector_model</a> (<a class="el" href="classturi_1_1neural__net_1_1pipeline__spec.html">neural_net::pipeline_spec</a> pipeline, size_t num_classes, size_t num_predictions, <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a> class_labels, float confidence_threshold, float iou_threshold, bool include_non_maximum_suppression, bool use_nms_layer, bool use_most_confident_class)</td></tr>
<tr class="separator:aeea2a6da92509b0b7ae9f23a17b38154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c70151020bc0f0c9dddcfe8c83e7095"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; coreml::MLModelWrapper &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a3c70151020bc0f0c9dddcfe8c83e7095">export_activity_classifier_model</a> (const <a class="el" href="classturi_1_1neural__net_1_1model__spec.html">neural_net::model_spec</a> &amp;nn_spec, size_t prediction_window, const <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a> &amp;features, size_t lstm_hidden_layer_size, const <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a> &amp;class_labels, const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;target)</td></tr>
<tr class="separator:a3c70151020bc0f0c9dddcfe8c83e7095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8813fec2c1c8be93a8d50d2c11379a0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; coreml::MLModelWrapper &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ae8813fec2c1c8be93a8d50d2c11379a0">export_style_transfer_model</a> (const <a class="el" href="classturi_1_1neural__net_1_1model__spec.html">neural_net::model_spec</a> &amp;nn_spec, size_t image_width, size_t image_height, bool include_flexible_shape, std::string content_feature, std::string style_feature, size_t num_styles)</td></tr>
<tr class="separator:ae8813fec2c1c8be93a8d50d2c11379a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30665b30c12e6d5ee807e5e68eae9bd8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; coreml::MLModelWrapper &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a30665b30c12e6d5ee807e5e68eae9bd8">export_drawing_classifier_model</a> (const <a class="el" href="classturi_1_1neural__net_1_1model__spec.html">neural_net::model_spec</a> &amp;nn_spec, const <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a> &amp;features, const <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a> &amp;class_labels, const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;target)</td></tr>
<tr class="separator:a30665b30c12e6d5ee807e5e68eae9bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf17c7990e00eab46358ea2f7865faee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#acf17c7990e00eab46358ea2f7865faee">to_flat_dict</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;dict_or_list, const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;separator, const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;undefined_string, std::function&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>(const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;)&gt; nonnumeric_value_handler)</td></tr>
<tr class="separator:acf17c7990e00eab46358ea2f7865faee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dee7eafcb0830112b307af255480aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a47dee7eafcb0830112b307af255480aa">to_flat_dict</a> (const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;input, const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;separator, const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;undefined_string, const std::string &amp;image_policy=&quot;error&quot;, const std::string &amp;datetime_policy=&quot;error&quot;)</td></tr>
<tr class="separator:a47dee7eafcb0830112b307af255480aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540a5abba9cb87b36865e3a15c87de31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a540a5abba9cb87b36865e3a15c87de31">to_sarray_of_flat_dictionaries</a> (<a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> input, const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;sep, const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;undefined_string, const std::string &amp;image_policy=&quot;error&quot;, const std::string &amp;datetime_policy=&quot;error&quot;)</td></tr>
<tr class="separator:a540a5abba9cb87b36865e3a15c87de31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0897de203f0665490c3e558b3b8375b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0897de203f0665490c3e558b3b8375b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__util.html#ga8750328f64c9b85845e920eecaf7094e">GL_HOT_INLINE</a> std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#ac0897de203f0665490c3e558b3b8375b">find_slice_boundary_indices</a> (const std::vector&lt; std::pair&lt; size_t, T &gt; &gt; &amp;v, size_t item_index_lb, size_t item_index_ub)</td></tr>
<tr class="separator:ac0897de203f0665490c3e558b3b8375b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845719d1ce226dde6c31d2aa468d8836"><td class="memTemplParams" colspan="2">template&lt;typename T , typename SliceInitFunction , typename RowProcessFunction , typename ElementProcessFunction , typename SliceFinalizeFunction &gt; </td></tr>
<tr class="memitem:a845719d1ce226dde6c31d2aa468d8836"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a845719d1ce226dde6c31d2aa468d8836">iterate_through_sparse_item_array_by_slice</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; std::vector&lt; std::pair&lt; size_t, T &gt; &gt; &gt; &gt; &amp;data, const std::vector&lt; size_t &gt; &amp;slice_delimiters, SliceInitFunction &amp;&amp;init_slice, RowProcessFunction &amp;&amp;preprocess_row, ElementProcessFunction &amp;&amp;process_element, SliceFinalizeFunction &amp;&amp;finalize_slice)</td></tr>
<tr class="separator:a845719d1ce226dde6c31d2aa468d8836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7dc62f726e970d8994a01a66175a538"><td class="memTemplParams" colspan="2">template&lt;typename T , typename RowProcessFunction &gt; </td></tr>
<tr class="memitem:aa7dc62f726e970d8994a01a66175a538"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#aa7dc62f726e970d8994a01a66175a538">iterate_through_sparse_item_array</a> (const std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; std::vector&lt; std::pair&lt; size_t, T &gt; &gt; &gt; &gt; &amp;data, RowProcessFunction &amp;&amp;process_row)</td></tr>
<tr class="separator:aa7dc62f726e970d8994a01a66175a538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b93738530621930c5a07a906a5b1865"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b93738530621930c5a07a906a5b1865"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; std::vector&lt; std::pair&lt; size_t, T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a4b93738530621930c5a07a906a5b1865">transpose_sparse_sarray</a> (std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; std::vector&lt; std::pair&lt; size_t, T &gt; &gt; &gt; &gt; data, const std::vector&lt; size_t &gt; &amp;item_counts, size_t max_memory_usage)</td></tr>
<tr class="separator:a4b93738530621930c5a07a906a5b1865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad3530418c9bcd52e3cec371f245a8b"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename ComparisonFunction , typename AccumulateFunction &gt; </td></tr>
<tr class="memitem:ga0ad3530418c9bcd52e3cec371f245a8b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga0ad3530418c9bcd52e3cec371f245a8b">accumulate_intersection</a> (InputIterator1 first1, const InputIterator1 &amp;last1, InputIterator2 first2, const InputIterator2 &amp;last2, const ComparisonFunction &amp;less_than_operator, const AccumulateFunction &amp;accumulate_matching_pair)</td></tr>
<tr class="separator:ga0ad3530418c9bcd52e3cec371f245a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a245b6f97ff63864fcad59c40c1b47f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename AccumulateFunction &gt; </td></tr>
<tr class="memitem:ga1a245b6f97ff63864fcad59c40c1b47f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga1a245b6f97ff63864fcad59c40c1b47f">accumulate_intersection</a> (InputIterator1 first1, const InputIterator1 &amp;last1, InputIterator2 first2, const InputIterator2 &amp;last2, const AccumulateFunction &amp;accumulate_matching_pair)</td></tr>
<tr class="separator:ga1a245b6f97ff63864fcad59c40c1b47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ea40acb9aa1c215739d74870dca949"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 &gt; </td></tr>
<tr class="memitem:ga42ea40acb9aa1c215739d74870dca949"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga42ea40acb9aa1c215739d74870dca949">count_intersection</a> (InputIterator1 first1, const InputIterator1 &amp;last1, InputIterator2 first2, const InputIterator2 &amp;last2)</td></tr>
<tr class="separator:ga42ea40acb9aa1c215739d74870dca949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d7dc2175a0f5f56d4b297c3b1a0009"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename ComparisonFunction &gt; </td></tr>
<tr class="memitem:ga89d7dc2175a0f5f56d4b297c3b1a0009"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga89d7dc2175a0f5f56d4b297c3b1a0009">count_intersection</a> (InputIterator1 first1, const InputIterator1 &amp;last1, InputIterator2 first2, const InputIterator2 &amp;last2, const ComparisonFunction &amp;less_than_operator)</td></tr>
<tr class="separator:ga89d7dc2175a0f5f56d4b297c3b1a0009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486ff4586cf47da4af0cdc0908cb71d6"><td class="memItemLeft" align="right" valign="top"><a id="a486ff4586cf47da4af0cdc0908cb71d6"></a>
std::shared_ptr&lt; <a class="el" href="classturi_1_1neural__net_1_1Image.html">neural_net::Image</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a486ff4586cf47da4af0cdc0908cb71d6">wrap_image</a> (const <a class="el" href="classturi_1_1image__type.html">image_type</a> &amp;image)</td></tr>
<tr class="memdesc:a486ff4586cf47da4af0cdc0908cb71d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from the Turi <a class="el" href="classturi_1_1image__type.html">image_type</a> to the neural_net Image type. <br /></td></tr>
<tr class="separator:a486ff4586cf47da4af0cdc0908cb71d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa230f5663cb3d54930f7b834176edddd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#gaa230f5663cb3d54930f7b834176edddd">get_unique_values</a> (std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; indexed_column)</td></tr>
<tr class="separator:gaa230f5663cb3d54930f7b834176edddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be1372202e9256374e877793887e8af"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga5be1372202e9256374e877793887e8af">make_unique</a> (std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt; indexed_column)</td></tr>
<tr class="separator:ga5be1372202e9256374e877793887e8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54025cc8bf2e793927c0202ebcb68ed3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classturi_1_1sframe.html">sframe</a>, <a class="el" href="classturi_1_1sframe.html">sframe</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga54025cc8bf2e793927c0202ebcb68ed3">split_sframe_on_index</a> (const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;src, std::function&lt; bool(size_t)&gt; switch_function)</td></tr>
<tr class="separator:ga54025cc8bf2e793927c0202ebcb68ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf55b6675b70fe0932c3c6dff099edab3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#gaf55b6675b70fe0932c3c6dff099edab3">matrix_to_sarray</a> (const Eigen::MatrixXd &amp;m)</td></tr>
<tr class="separator:gaf55b6675b70fe0932c3c6dff099edab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18a4682bfe16de1db8594e334d57e7ab"><td class="memTemplParams" colspan="2">template&lt;typename GenFunction &gt; </td></tr>
<tr class="memitem:ga18a4682bfe16de1db8594e334d57e7ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classturi_1_1sframe.html">sframe</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__toolkit__util.html#ga18a4682bfe16de1db8594e334d57e7ab">sframe_from_ranged_generator</a> (const std::vector&lt; std::string &gt; &amp;column_names, const std::vector&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;column_types, size_t num_rows, GenFunction &amp;&amp;generator_function)</td></tr>
<tr class="separator:ga18a4682bfe16de1db8594e334d57e7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f956da5b0f586de1140168890dfb1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a96f956da5b0f586de1140168890dfb1a">print_training_device</a> (std::vector&lt; std::string &gt; gpu_names)</td></tr>
<tr class="separator:a96f956da5b0f586de1140168890dfb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a239e289c661e697c9191abaaae05981d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a> = <a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>()</td></tr>
<tr class="separator:a239e289c661e697c9191abaaae05981d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465691d12234a4c54e292f97dda0ac80"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a465691d12234a4c54e292f97dda0ac80">DIR_ARCHIVE_INI_FILE</a></td></tr>
<tr class="separator:a465691d12234a4c54e292f97dda0ac80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7d5834c43f10bb674f0008616ff805"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#a1b7d5834c43f10bb674f0008616ff805">DIR_ARCHIVE_OBJECTS_BIN</a></td></tr>
<tr class="separator:a1b7d5834c43f10bb674f0008616ff805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a14c814ad647a718e7ff20ef2999653"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga0a14c814ad647a718e7ff20ef2999653">SFRAME_DEFAULT_NUM_SEGMENTS</a></td></tr>
<tr class="separator:ga0a14c814ad647a718e7ff20ef2999653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga147c13dd9ac3f4bb564fcacaea1a62be"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga147c13dd9ac3f4bb564fcacaea1a62be">DEFAULT_SARRAY_READER_BUFFER_SIZE</a></td></tr>
<tr class="separator:ga147c13dd9ac3f4bb564fcacaea1a62be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4060e1d00eabb1bf74af3ecaef1751e"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gab4060e1d00eabb1bf74af3ecaef1751e">SARRAY_FROM_FILE_BATCH_SIZE</a></td></tr>
<tr class="separator:gab4060e1d00eabb1bf74af3ecaef1751e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafbbdb0b7e14990e3abf78a1b0ae97bb"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaafbbdb0b7e14990e3abf78a1b0ae97bb">MIN_SEGMENT_LENGTH</a></td></tr>
<tr class="separator:gaafbbdb0b7e14990e3abf78a1b0ae97bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf080605fa1c42e579713cada9700010d"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaf080605fa1c42e579713cada9700010d">SFRAME_WRITER_BUFFER_HARD_LIMIT</a></td></tr>
<tr class="separator:gaf080605fa1c42e579713cada9700010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d679053bcafb2d07b4bd63fc78ea174"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga5d679053bcafb2d07b4bd63fc78ea174">SFRAME_FILE_HANDLE_POOL_SIZE</a></td></tr>
<tr class="separator:ga5d679053bcafb2d07b4bd63fc78ea174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257d1eac7da7cc34d1b09b4ad4a449c7"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga257d1eac7da7cc34d1b09b4ad4a449c7">SFRAME_BLOCK_MANAGER_BLOCK_BUFFER_COUNT</a></td></tr>
<tr class="separator:ga257d1eac7da7cc34d1b09b4ad4a449c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b7d344bc4cb3d49e53eb022da16599"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga24b7d344bc4cb3d49e53eb022da16599">COMPRESSION_DISABLE_THRESHOLD</a></td></tr>
<tr class="separator:ga24b7d344bc4cb3d49e53eb022da16599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga113eafeb25d60f776d0c163bab66fc75"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga113eafeb25d60f776d0c163bab66fc75">SFRAME_DEFAULT_BLOCK_SIZE</a></td></tr>
<tr class="separator:ga113eafeb25d60f776d0c163bab66fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71cf727dd3ad628263a73b11c6ad6528"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga71cf727dd3ad628263a73b11c6ad6528">SARRAY_WRITER_INITAL_ELEMENTS_PER_BLOCK</a></td></tr>
<tr class="separator:ga71cf727dd3ad628263a73b11c6ad6528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7281e1bb0446ea33004e78d51ea8c6a7"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga7281e1bb0446ea33004e78d51ea8c6a7">SARRAY_WRITER_MIN_ELEMENTS_PER_BLOCK</a></td></tr>
<tr class="separator:ga7281e1bb0446ea33004e78d51ea8c6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2819cfa91c11a627de6d70fd495e0c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga4c2819cfa91c11a627de6d70fd495e0c">SFRAME_WRITER_MAX_BUFFERED_CELLS_PER_BLOCK</a></td></tr>
<tr class="separator:ga4c2819cfa91c11a627de6d70fd495e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga729ab9b4f8306e0ef9680da74c255edb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga729ab9b4f8306e0ef9680da74c255edb">SFRAME_WRITER_MAX_BUFFERED_CELLS</a></td></tr>
<tr class="separator:ga729ab9b4f8306e0ef9680da74c255edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11bc6cff209078df4dd9481be5a83733"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga11bc6cff209078df4dd9481be5a83733">SFRAME_MAX_BLOCKS_IN_CACHE</a></td></tr>
<tr class="separator:ga11bc6cff209078df4dd9481be5a83733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdaf1bdee34727191c837f382bd50e1e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gacdaf1bdee34727191c837f382bd50e1e">SFRAME_CSV_PARSER_READ_SIZE</a></td></tr>
<tr class="separator:gacdaf1bdee34727191c837f382bd50e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff6a4d5002d4a34ebd125418f019ef9f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaff6a4d5002d4a34ebd125418f019ef9f">SFRAME_GROUPBY_BUFFER_NUM_ROWS</a></td></tr>
<tr class="separator:gaff6a4d5002d4a34ebd125418f019ef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5db85f6ab9cbc4112c4c5297bd3d32"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gaac5db85f6ab9cbc4112c4c5297bd3d32">SFRAME_SHUFFLE_BUCKET_SIZE</a></td></tr>
<tr class="separator:gaac5db85f6ab9cbc4112c4c5297bd3d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga072fdea3589d0e65e0f0c71380864190"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga072fdea3589d0e65e0f0c71380864190">SFRAME_JOIN_BUFFER_NUM_CELLS</a></td></tr>
<tr class="separator:ga072fdea3589d0e65e0f0c71380864190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8df491acb63b1cf8e7f8ab0d719eda8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gad8df491acb63b1cf8e7f8ab0d719eda8">SFRAME_IO_READ_LOCK</a></td></tr>
<tr class="separator:gad8df491acb63b1cf8e7f8ab0d719eda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62082f167c51467e2e6842214d89070a"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga62082f167c51467e2e6842214d89070a">SFRAME_IO_LOCK_FILE_SIZE_THRESHOLD</a></td></tr>
<tr class="separator:ga62082f167c51467e2e6842214d89070a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae18272fca6572c6d7515da8e8470e68a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gae18272fca6572c6d7515da8e8470e68a">SFRAME_SORT_PIVOT_ESTIMATION_SAMPLE_SIZE</a></td></tr>
<tr class="separator:gae18272fca6572c6d7515da8e8470e68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83377e8db5ff62da684b96411aaebc08"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga83377e8db5ff62da684b96411aaebc08">SFRAME_SORT_MAX_SEGMENTS</a></td></tr>
<tr class="separator:ga83377e8db5ff62da684b96411aaebc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be7965a1407dd92f588ccfc23a15ade"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#ga2be7965a1407dd92f588ccfc23a15ade">SFRAME_COMPACTION_THRESHOLD</a></td></tr>
<tr class="separator:ga2be7965a1407dd92f588ccfc23a15ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada49853579a049f753b1e39ce1669315"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sframe__main.html#gada49853579a049f753b1e39ce1669315">FAST_COMPACT_BLOCKS_IN_SMALL_SEGMENT</a></td></tr>
<tr class="separator:gada49853579a049f753b1e39ce1669315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc2ec4c1b9133efa5b133b70066a06e4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__main.html#gacc2ec4c1b9133efa5b133b70066a06e4">SGRAPH_TRIPLE_APPLY_LOCK_ARRAY_SIZE</a></td></tr>
<tr class="separator:gacc2ec4c1b9133efa5b133b70066a06e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44898c8cb3937ab7bd60519333b12a3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__main.html#gaf44898c8cb3937ab7bd60519333b12a3">SGRAPH_BATCH_TRIPLE_APPLY_LOCK_ARRAY_SIZE</a></td></tr>
<tr class="separator:gaf44898c8cb3937ab7bd60519333b12a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3b74b2a0841f9710d6216963504b92c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__main.html#gac3b74b2a0841f9710d6216963504b92c">SGRAPH_TRIPLE_APPLY_EDGE_BATCH_SIZE</a></td></tr>
<tr class="separator:gac3b74b2a0841f9710d6216963504b92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga475961ad116f79e6eda67e1da11c8183"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__main.html#ga475961ad116f79e6eda67e1da11c8183">SGRAPH_DEFAULT_NUM_PARTITIONS</a></td></tr>
<tr class="separator:ga475961ad116f79e6eda67e1da11c8183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f1f371663b47e7e732b6a8659a1b9da"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__main.html#ga9f1f371663b47e7e732b6a8659a1b9da">SGRAPH_INGRESS_VID_BUFFER_SIZE</a></td></tr>
<tr class="separator:ga9f1f371663b47e7e732b6a8659a1b9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9472a9f9707e4c406223f64b712a57"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sgraph__main.html#ga3d9472a9f9707e4c406223f64b712a57">SGRAPH_HILBERT_CURVE_PARALLEL_FOR_NUM_THREADS</a></td></tr>
<tr class="separator:ga3d9472a9f9707e4c406223f64b712a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3497457f9cc0ff907b406a901c9a82a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#af3497457f9cc0ff907b406a901c9a82a">DEFAULT_NUM_PYLAMBDA_WORKERS</a></td></tr>
<tr class="separator:af3497457f9cc0ff907b406a901c9a82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa645decb0a71f2af50301f4dcb336496"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceturi.html#aa645decb0a71f2af50301f4dcb336496">DEFAULT_NUM_GRAPH_LAMBDA_WORKERS</a></td></tr>
<tr class="separator:aa645decb0a71f2af50301f4dcb336496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf63b6ae12f1d3be45226d113d0ed1114"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mldata.html#gaf63b6ae12f1d3be45226d113d0ed1114">ml_missing_value_action</a> : int </td></tr>
<tr class="separator:gaf63b6ae12f1d3be45226d113d0ed1114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7beaf7388ecc8bb34821c4a0b38b292f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mldata.html#ga7beaf7388ecc8bb34821c4a0b38b292f">ml_column_mode</a> : int </td></tr>
<tr class="separator:ga7beaf7388ecc8bb34821c4a0b38b292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5579cc837c0c1dd19fe7508945b21e7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mldata.html#gae5579cc837c0c1dd19fe7508945b21e7">mode_is_categorical</a> (<a class="el" href="group__mldata.html#ga7beaf7388ecc8bb34821c4a0b38b292f">ml_column_mode</a> mode)</td></tr>
<tr class="separator:gae5579cc837c0c1dd19fe7508945b21e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b982e837dafb8732be1d217e67bd79"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mldata.html#gaf7b982e837dafb8732be1d217e67bd79">mode_has_fixed_size</a> (<a class="el" href="group__mldata.html#ga7beaf7388ecc8bb34821c4a0b38b292f">ml_column_mode</a> mode)</td></tr>
<tr class="separator:gaf7b982e837dafb8732be1d217e67bd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga063ca313544fff079f668f77fa255089"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mldata.html#ga063ca313544fff079f668f77fa255089">mode_is_indexed</a> (<a class="el" href="group__mldata.html#ga7beaf7388ecc8bb34821c4a0b38b292f">ml_column_mode</a> mode)</td></tr>
<tr class="separator:ga063ca313544fff079f668f77fa255089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa90807aacaf964777f174bde4526e902"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mldata.html#gaa90807aacaf964777f174bde4526e902">column_mode_enum_to_name</a> (<a class="el" href="group__mldata.html#ga7beaf7388ecc8bb34821c4a0b38b292f">ml_column_mode</a> mode)</td></tr>
<tr class="separator:gaa90807aacaf964777f174bde4526e902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SKD. </p>
<p>This file implements a collection of routines that operate and behave uniformly on all supported protocols. (currently, HDFS, S3, local fs)</p>
<p>Provides a generic interface to call cython functions (which can in turn call python functions) from the C++ code and properly handle exceptions.</p>
<h1><a class="el" href="classturi_1_1ml__data.html">ml_data</a> layout format </h1>
<p>The rows are stored in segments of a vector of entry_value structs, where entry_value encloses a union of an index_value and a double_value. Thus it is 8 bytes. Each vector contains up to row_block_size rows. The data is stored as an sarray&lt;vector&lt;entry_value&gt; &gt;</p>
<h2>Raw data layout </h2>
<p>Each vector is simply laid out as</p>
<p>| row 1 | row 2 | ... | row n |</p>
<p>where n &lt;= row_block_size.</p>
<p>Each row is laid out according to the "mode" of the columns, determined by column_metadata::mode. mode can be NUMERIC, CATEGORICAL, NUMERIC_VECTOR, CATEGORICAL_VECTOR, and7 DICTIONARY. The last three of these can hold multiple values.</p>
<h1>ROW FORMAT (from ml_data.hpp) </h1>
<p><a class="el" href="classturi_1_1ml__data.html">ml_data</a> loads data from an existing sframe, indexes it by mapping all categorical values to unique indices in 0, 1,2,...,n, and records statistics about the values. It then puts it into an efficient row-based data storage structure for use in regression and learning algorithms. The row based storage structure is designed for fast iteration through the rows and target.</p>
<p>The rows are stored in segments of a vector of entry_value structs, where entry_value encloses a union of an index_value and a double_value. Thus it is 8 bytes. Each vector contains up to ROW_BLOCK_SIZE rows. The data is stored as an sarray&lt;vector&lt;entry_value&gt; &gt;</p>
<h2>Raw data layout </h2>
<p>Each vector is simply laid out as</p>
<p>| &lt;row_size&gt; row 1 | &lt;row_size&gt; row 2 | ... | &lt;row_size&gt; row n |</p>
<p>The row size variable is present if CATEGORICAL_VECTOR or DICTIONARY are defined types, as these may induce variable sized rows. Otherwise, the row sizes are constant and determined from the metadata, thus this does not need to be there.</p>
<p>where n &lt;= ROW_BLOCK_SIZE.</p>
<p>Each row is laid out according to the "mode" of the columns, determined by column_metadata::mode. mode can be NUMERIC, CATEGORICAL, NUMERIC_VECTOR, CATEGORICAL_VECTOR, and DICTIONARY. The last three of these can hold multiple values.</p>
<h2>Row layout </h2>
<p>Each row takes a block of data entries laid out according to mode:</p>
<p>NUMERIC:</p>
<p>... | value | ...</p>
<p>CATEGORICAL:</p>
<p>... | index | ...</p>
<p>NUMERIC_VECTOR:</p>
<p>... | value1 value2 ... | ...</p>
<p>CATEGORICAL_VECTOR:</p>
<p>... | length index1 index2 ... | ...</p>
<p>DICTIONARY:</p>
<p>... | length index1 value1 index2 value2 ... | ...</p>
<p>example: {0 : 2.1, 1 : 8.5} would be ... | 2 0 2.1 1 8.5 | ...</p>
<p>Since the number of columns, and the mode of each column is constant across rows, the values are all laid out sequentially; for example, a row with columns (numeric, numeric_vector, dictionary) would be</p>
<p>... || row_size | value | v1 v2 ... | length k1 v1 k2 v2 ... || ...</p>
<p>Thus a row of [1.0, [2.0, 4.0], {0 : 2.1, 1 : 8.5}] would appear as</p>
<p>... || 8 | 1.0 | 2.0 4.0 | 2 0 2.1 1 8.5 || ... = ... || 8 1.0 2.0 4.0 2 0 2.1 1 8.5 || ...</p>
<p>Similarly, a row with columns (numeric, numeric_vector, categorical) would be</p>
<p>... || value | v1 v2 ... | k1 || ...</p><ul>
<li>And a row of [1.0, [2.0, 4.0], 8] would appear as</li>
</ul>
<p>... || 1.0 | 2 2.0 4.0 | 8 || ... = ... || 1.0 2 2.0 4.0 8 || ... Since ROW_BLOCK_SIZE are stored together in a vector&lt;entry_value&gt;, iterating through rows is extremely fast.</p>
<h1>target access </h1>
<p>If a target column is present, it is stored as the LAST element in exactly the same way as a regular numeric value.</p>
<p>TODO:</p><ul>
<li>Replace spmat with flex_dict for each document</li>
<li>Parallelize over documents. Trim zeros at the end of each sample.</li>
<li>Try map, <a class="el" href="classturi_1_1hopscotch__map.html">hopscotch_map</a> for spmat.</li>
<li>change predict_counts and sample_counts API to be able to handle both training set and validation set? That way we aren't starting from scratch on the validation set.</li>
<li>combine all the word alias computation into one method</li>
<li>use Eigen Vector instead of matrices with one row.</li>
<li>Make sure to use const auto&amp; where appropriate.</li>
<li>Choose whether to use w, s, t, d, psdw, etc.</li>
<li>Track MH acceptance ratio</li>
<li>Consider using row-order Eigen matrices and checking for speedup (at least for CGS word_topic_counts?) </li>
</ul>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a6ae2ab6a167bcb565888c5584ddc56ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae2ab6a167bcb565888c5584ddc56ac">&#9670;&nbsp;</a></span>condition_variable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classturi_1_1conditional.html">conditional</a> <a class="el" href="namespaceturi.html#a6ae2ab6a167bcb565888c5584ddc56ac">turi::condition_variable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience typedef to be equivalent to the std::condition_variable </p>

<p class="definition">Definition at line <a class="el" href="pthread__tools_8hpp_source.html#l01099">1099</a> of file <a class="el" href="pthread__tools_8hpp_source.html">pthread_tools.hpp</a>.</p>

</div>
</div>
<a id="a62b96181769442a107940d85d2f5e59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b96181769442a107940d85d2f5e59b">&#9670;&nbsp;</a></span>is_model_descendent</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceturi.html#a62b96181769442a107940d85d2f5e59b">turi::is_model_descendent</a> = typedef std::is_convertible&lt;T*, <a class="el" href="classturi_1_1model__base.html">model_base</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_model_descendent&lt;T&gt;::value is true if *T is a descendent of <a class="el" href="classturi_1_1model__base.html">model_base</a>, or is <a class="el" href="classturi_1_1model__base.html">model_base</a> itself.</p>
<div class="fragment"><div class="line">is_model_descendent&lt;flexible_type&gt;::value <span class="comment">// false</span></div><div class="line">is_model_descendent&lt;svariant_converter_imple_model*&gt;::value <span class="comment">// true</span></div><div class="line">is_model_descendent&lt;svariant_converter_imple_model&gt;::value <span class="comment">// false</span></div><div class="line">is_model_descendent&lt;model_base*&gt;::value <span class="comment">// true</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="variant__converter_8hpp_source.html#l00071">71</a> of file <a class="el" href="variant__converter_8hpp_source.html">variant_converter.hpp</a>.</p>

</div>
</div>
<a id="adc8f5592bc6ffb76005399e580c12519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8f5592bc6ffb76005399e580c12519">&#9670;&nbsp;</a></span>is_variant_member</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceturi.html#adc8f5592bc6ffb76005399e580c12519">turi::is_variant_member</a> = typedef boost::mpl::contains&lt;variant_type::types, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_variant_member&lt;T&gt;::value is true if T is a type contained by the variant_type, and is false otherwise.</p>
<div class="fragment"><div class="line">is_variant_member&lt;unity_sarray_base*&gt;::value <span class="comment">// true</span></div><div class="line">is_variant_member&lt;size_t&gt;::value <span class="comment">// false</span></div><div class="line">is_variant_member&lt;flexible_type&gt;::value <span class="comment">// true</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="variant__converter_8hpp_source.html#l00057">57</a> of file <a class="el" href="variant__converter_8hpp_source.html">variant_converter.hpp</a>.</p>

</div>
</div>
<a id="ad2f01fc93cbbadcab29068fd9b6947ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f01fc93cbbadcab29068fd9b6947ec">&#9670;&nbsp;</a></span>lambda_triple_apply_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(<a class="el" href="structturi_1_1edge__triple.html">edge_triple</a>&amp;)&gt; <a class="el" href="namespaceturi.html#ad2f01fc93cbbadcab29068fd9b6947ec">turi::lambda_triple_apply_fn</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the triple apply lambda function. </p>

<p class="definition">Definition at line <a class="el" href="sgraph__triple__apply__typedefs_8hpp_source.html#l00026">26</a> of file <a class="el" href="sgraph__triple__apply__typedefs_8hpp_source.html">sgraph_triple_apply_typedefs.hpp</a>.</p>

</div>
</div>
<a id="a133f01ff63e13b5b78b761e5c78e0c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133f01ff63e13b5b78b761e5c78e0c25">&#9670;&nbsp;</a></span>variant_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::make_recursive_variant&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>, std::shared_ptr&lt;<a class="el" href="classturi_1_1unity__sgraph__base.html">unity_sgraph_base</a>&gt;, <a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a>, std::shared_ptr&lt;<a class="el" href="classturi_1_1model__base.html">model_base</a>&gt;, std::shared_ptr&lt;unity_sframe_base&gt;, std::shared_ptr&lt;unity_sarray_base&gt;, std::map&lt;std::string, boost::recursive_variant_&gt;, std::vector&lt;boost::recursive_variant_&gt;, boost::recursive_wrapper&lt;<a class="el" href="structturi_1_1function__closure__info.html">function_closure_info</a>&gt; &gt;::type <a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">turi::variant_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A variant object that can be communicated between Python and C++ which contains either a </p><ul>
<li><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> </li>
<li>std::shared_ptr&lt;unity_sgraph&gt; </li>
<li><a class="el" href="structturi_1_1dataframe__t.html">dataframe_t</a> </li>
<li>model </li>
<li>std::shared_ptr&lt;unity_sframe&gt; </li>
<li>std::shared_ptr&lt;unity_sarray&gt; </li>
<li>std::map&lt;variant&gt; </li>
<li>std::vector&lt;variant&gt;</li>
</ul>
<p>See the boost variant documentation for details.</p>
<p>The variant should not be accessed directly. See <a class="el" href="namespaceturi.html#a4089b0a7d421bba15b1510e3816c11ab">to_variant</a> and <a class="el" href="namespaceturi.html#a895255301986d2f7bc3aa81a460e0f14">variant_get_value</a> for powerful ways to extract or store values from a variant. </p>

<p class="definition">Definition at line <a class="el" href="variant_8hpp_source.html#l00024">24</a> of file <a class="el" href="variant_8hpp_source.html">variant.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a232ed812da2796b7bd317ea4b3a21f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232ed812da2796b7bd317ea4b3a21f76">&#9670;&nbsp;</a></span>flex_type_enum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">turi::flex_type_enum</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An enumeration over the possible types the flexible type can contain.</p>
<dl class="section note"><dt>Note</dt><dd>Renumber this at your own risk.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceturi.html#a532ea655972eb0b72dc40ad14fd82075">flex_type_enum_from_name</a> </dd>
<dd>
<a class="el" href="namespaceturi.html#a65de5f31193ee46ccb4cfd60cddfaaa6">flex_type_enum_to_name</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a232ed812da2796b7bd317ea4b3a21f76a5d5cd46919fa987731fb2edefe0f2a0c"></a>INTEGER&#160;</td><td class="fielddoc"><p>Integer type. Stored type is the <a class="el" href="group__group__flexible__type__types.html#ga7936350fa49b122a09c32b26922fd658">flex_int</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a232ed812da2796b7bd317ea4b3a21f76ae738c26bf4ce1037fa81b039a915cbf6"></a>FLOAT&#160;</td><td class="fielddoc"><p>64-bit floating point type. Stored type is the <a class="el" href="group__group__flexible__type__types.html#gadcf31f61cc0e0b82bdc9d886fa163e86">flex_float</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a232ed812da2796b7bd317ea4b3a21f76a63b588d5559f64f89a416e656880b949"></a>STRING&#160;</td><td class="fielddoc"><p>String type. Stored type is the <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a232ed812da2796b7bd317ea4b3a21f76a87752381b583740610f1dfeb07fdad7e"></a>VECTOR&#160;</td><td class="fielddoc"><p>Numeric vector type. Stored type is the <a class="el" href="group__group__flexible__type__types.html#gae3209fbbd62e8deaeff5fdb24965f2ac">flex_vec</a>. This is deprecated. </p>
</td></tr>
<tr><td class="fieldname"><a id="a232ed812da2796b7bd317ea4b3a21f76a298cb25408234de02baf2085803a464a"></a>LIST&#160;</td><td class="fielddoc"><p>Recursive List type. Stored type is the <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a232ed812da2796b7bd317ea4b3a21f76ad7f73f951e7f6c4ed5e17c4204f4032e"></a>DICT&#160;</td><td class="fielddoc"><p>Recursive Dictionary type. Stored type is the <a class="el" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a232ed812da2796b7bd317ea4b3a21f76aa3eb957bd02f4780a599d5ec4464ca46"></a>DATETIME&#160;</td><td class="fielddoc"><p>Date-Time type. Stored type is the <a class="el" href="structturi_1_1flex__date__time.html">flex_date_time</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a232ed812da2796b7bd317ea4b3a21f76a0db45d2a4141101bdfe48e3314cfbca3"></a>UNDEFINED&#160;</td><td class="fielddoc"><p>Undefined / Missing Value type. Stored type is the <a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a232ed812da2796b7bd317ea4b3a21f76a23a12f67f614b5518c7f1c2465bf95e3"></a>IMAGE&#160;</td><td class="fielddoc"><p>Image type. Stored type is the <a class="el" href="group__group__flexible__type__types.html#ga40bb1656bebeb5ab0e3cd138c09e5995">flex_image</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a232ed812da2796b7bd317ea4b3a21f76a260c729a53b25b0587857d9a6ca1b6ab"></a>ND_VECTOR&#160;</td><td class="fielddoc"><p>Numeric vector type. Stored type is the <a class="el" href="group__group__flexible__type__types.html#gac2900ffa5e2fef35d706e307db74d859">flex_nd_vec</a> </p>
</td></tr>
</table>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_2build_2src_2core_2storage_2sframe_interface_2unity_sframe_8hpp-example.html#a0">/build/src/core/storage/sframe_interface/unity_sframe.hpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="flexible__type__base__types_8hpp_source.html#l00332">332</a> of file <a class="el" href="flexible__type__base__types_8hpp_source.html">flexible_type_base_types.hpp</a>.</p>

</div>
</div>
<a id="a9a91663acc51ef53b8d40f4efe12b1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a91663acc51ef53b8d40f4efe12b1be">&#9670;&nbsp;</a></span>Format</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1be">turi::Format</a> : size_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Possible image formats stored in the image type </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9a91663acc51ef53b8d40f4efe12b1bea92769fe7c40229f4301d6125e0a9e928"></a>JPG&#160;</td><td class="fielddoc"><p>JPEG Compressed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a91663acc51ef53b8d40f4efe12b1bea55505ba281b015ec31f03ccb151b2a34"></a>PNG&#160;</td><td class="fielddoc"><p>PNG Compressed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a91663acc51ef53b8d40f4efe12b1bea7bd5775f0cb56bfb85009a49a87d9835"></a>RAW_ARRAY&#160;</td><td class="fielddoc"><p>Not Compressed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a91663acc51ef53b8d40f4efe12b1bea0db45d2a4141101bdfe48e3314cfbca3"></a>UNDEFINED&#160;</td><td class="fielddoc"><p>Unknown. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="image__type_8hpp_source.html#l00022">22</a> of file <a class="el" href="image__type_8hpp_source.html">image_type.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0e8d7c3f0f04ede23f92e66a341b8dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8d7c3f0f04ede23f92e66a341b8dcb">&#9670;&nbsp;</a></span>_add_directory_to_deleter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::_add_directory_to_deleter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The directories we use for our temporary archives should be unique and everything, but we don't want hundreds of these lying around. Thus add them to a list with which we delete when the program exits; this function does that. </p>

</div>
</div>
<a id="ae717505f642d859bacec10acbaf25ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae717505f642d859bacec10acbaf25ff2">&#9670;&nbsp;</a></span>_get_unique_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::_get_unique_directory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a unique directory name. </p>

</div>
</div>
<a id="a2aac567773d5068dce533ce7420be04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aac567773d5068dce533ce7420be04c">&#9670;&nbsp;</a></span>add_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::add_metadata </td>
          <td>(</td>
          <td class="paramtype">CoreML::Specification::Model &amp;&#160;</td>
          <td class="paramname"><em>model_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add short description, metadata to the model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>CoreML specification model </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Dictionary of context passed from python. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a086b1dff0f102785fb75fddf9fb9b436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086b1dff0f102785fb75fddf9fb9b436">&#9670;&nbsp;</a></span>atomic_increment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T turi::atomic_increment </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>increment</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_integral&lt; U &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Atomically increments the value, and returns the value of the atomic prior to this operation. Equivalent to</p>
<p>old_value = value; value += increment; return value; </p>

<p class="definition">Definition at line <a class="el" href="atomic__ops_8hpp_source.html#l00292">292</a> of file <a class="el" href="atomic__ops_8hpp_source.html">atomic_ops.hpp</a>.</p>

</div>
</div>
<a id="aadecbb3af09801b00cab2f2a2bafa11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadecbb3af09801b00cab2f2a2bafa11d">&#9670;&nbsp;</a></span>atomic_increment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = int&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T turi::atomic_increment </td>
          <td>(</td>
          <td class="paramtype">volatile T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>increment</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &amp;&amp;std::is_integral&lt; U &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Atomically increments the value, and returns the value of the atomic prior to this operation. Equivalent to</p>
<p>old_value = value; value += increment; return value;</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="atomic__ops_8hpp_source.html#l00307">307</a> of file <a class="el" href="atomic__ops_8hpp_source.html">atomic_ops.hpp</a>.</p>

</div>
</div>
<a id="a744006aadcfef2e6ff34c7b2ac8e76c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744006aadcfef2e6ff34c7b2ac8e76c5">&#9670;&nbsp;</a></span>atomic_set_max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T turi::atomic_set_max </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>max_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically sets the max, returning the value of the atomic prior to setting the max value, or the existing value if nothing changed. Atomic equivalent to:</p>
<p>old_max_value = max_value; max_value = std::max(max_value, new_value); return old_max_value; </p>

<p class="definition">Definition at line <a class="el" href="atomic__ops_8hpp_source.html#l00176">176</a> of file <a class="el" href="atomic__ops_8hpp_source.html">atomic_ops.hpp</a>.</p>

</div>
</div>
<a id="aecd991361ce193704dfdf10108cf013b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd991361ce193704dfdf10108cf013b">&#9670;&nbsp;</a></span>atomic_set_max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T turi::atomic_set_max </td>
          <td>(</td>
          <td class="paramtype">volatile T &amp;&#160;</td>
          <td class="paramname"><em>max_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically sets the max, returning the value of the atomic prior to this operation, or the existing value if nothing changed. Atomic equivalent to:</p>
<p>old_max_value = max_value; max_value = std::max(max_value, new_value); return old_max_value;</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="atomic__ops_8hpp_source.html#l00207">207</a> of file <a class="el" href="atomic__ops_8hpp_source.html">atomic_ops.hpp</a>.</p>

</div>
</div>
<a id="ab229d7b848f9bdc386c756d57cacfa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab229d7b848f9bdc386c756d57cacfa17">&#9670;&nbsp;</a></span>atomic_set_min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T turi::atomic_set_min </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically sets the min, returning the value of the atomic prior to this operation. Atomic equivalent to:</p>
<p>old_min_value = min_value; min_value = std::min(min_value, new_value); return old_min_value;</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="atomic__ops_8hpp_source.html#l00236">236</a> of file <a class="el" href="atomic__ops_8hpp_source.html">atomic_ops.hpp</a>.</p>

</div>
</div>
<a id="a71ba5183fe200d8080585aeaad049748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ba5183fe200d8080585aeaad049748">&#9670;&nbsp;</a></span>atomic_set_min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T turi::atomic_set_min </td>
          <td>(</td>
          <td class="paramtype">volatile T &amp;&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically sets the min, returning the value of the atomic prior to this operation. Atomic equivalent to:</p>
<p>old_min_value = min_value; min_value = std::min(min_value, new_value); return old_min_value;</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="atomic__ops_8hpp_source.html#l00265">265</a> of file <a class="el" href="atomic__ops_8hpp_source.html">atomic_ops.hpp</a>.</p>

</div>
</div>
<a id="a1e2c6175e32dbeb0927d5fcfe3903943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2c6175e32dbeb0927d5fcfe3903943">&#9670;&nbsp;</a></span>bit_mask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T turi::bit_mask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a bitwise mask of the first n_bits customised to type T. For example, bit_bask&lt;uint16_t&gt;(5) &amp; (000101011101011101 b) returns 11101 b.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the mask to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_bits</td><td>Index of the bit to flip. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00125">125</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a4523487693a307060894e1e82db47654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4523487693a307060894e1e82db47654">&#9670;&nbsp;</a></span>bit_mask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T turi::bit_mask </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a bitwise mask of a segment of bits, [index_begin, index_end).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the mask to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_begin</td><td>Start of interval. </td></tr>
    <tr><td class="paramname">index_end</td><td>End of interval. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00140">140</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a57edf3dc1770310d695a5044dfefa445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57edf3dc1770310d695a5044dfefa445">&#9670;&nbsp;</a></span>bit_off()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool turi::bit_off </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if a bit is off. Other bits are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Unsigned integer to test. </td></tr>
    <tr><td class="paramname">bit</td><td>Index of the bit to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00075">75</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a825e793e44ba6ffa40e49e617620aee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825e793e44ba6ffa40e49e617620aee3">&#9670;&nbsp;</a></span>bit_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool turi::bit_on </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if a bit is on. Other bits are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Unsigned integer to test. </td></tr>
    <tr><td class="paramname">bit</td><td>Index of the bit to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00063">63</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a36b861f6c79684a64017182939866328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b861f6c79684a64017182939866328">&#9670;&nbsp;</a></span>bitwise_log2_ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int turi::bitwise_log2_ceil </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the rounded up version of the bitwise log base two of the number. For example, 00010000 returns 4, and 00010001 returns 5. If v is zero, zero is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Unsigned integer value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00356">356</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a99e89fa9579461a581d5d391b41ef614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e89fa9579461a581d5d391b41ef614">&#9670;&nbsp;</a></span>bitwise_log2_floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int turi::bitwise_log2_floor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the rounded down version of the bitwise log base two of the number. For example, 00010000 returns 4, 00011111 returns 4, and 00100000 returns 5. If v is zero, zero is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Unsigned integer value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00369">369</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="abe28dbfc0d19d447e74ea77b4f858181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe28dbfc0d19d447e74ea77b4f858181">&#9670;&nbsp;</a></span>bitwise_pow2_mod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T turi::bitwise_pow2_mod </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pow2_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the modulus of v rounded to the pow2_idx bit. It is the same as v % (2 ** pow2_idx). For example, bitwise_pow2_mod(10, 3) = 10 % 8 = 2.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Unsigned integer value. </td></tr>
    <tr><td class="paramname">pow2_idx</td><td>Power of 2 with which to take the mod. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00383">383</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a38d7a190d06b8c451159379b0648ee6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d7a190d06b8c451159379b0648ee6c">&#9670;&nbsp;</a></span>boost_parse_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::boost_parse_image </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1be">Format</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>image_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the image information, set width, height and channels using boost_gil. </p>

</div>
</div>
<a id="a156b50aa4a360da0f21c4797e608a685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156b50aa4a360da0f21c4797e608a685">&#9670;&nbsp;</a></span>boost_read_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::boost_read_image </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1be">Format</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>image_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format_string</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the content of jpeg image and return the pixel array into out_data Only works with local files. </p>

</div>
</div>
<a id="a8056e26a070ff45a1bf1232aa463dd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8056e26a070ff45a1bf1232aa463dd1e">&#9670;&nbsp;</a></span>capi_server_initializer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;turi::unity_server_initializer&gt; turi::capi_server_initializer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The server initializer function.</p>
<p>This function creates the server initializer for the C-API, which is what determines which models and functions are registered to the unity sever, which then determines what models are packaged in the framework and available from the C-API.</p>
<p>In some cases, it may be desirable to have a custom server initializer, for example if only a subset of the models are needed. In this case, define the macro CAPI_DISABLE_DEFAULT_SERVER_INITIALIZER and create a custom implementation of that function to be compiled in. In addition, the CMakeLists.txt </p>

</div>
</div>
<a id="ab9d871f90185cac5c95fdb5c1aa3d88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d871f90185cac5c95fdb5c1aa3d88f">&#9670;&nbsp;</a></span>configure_global_environment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EXPORT turi::configure_global_environment </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>argv0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the system global environment. This should be the first thing (or close to the first thing) called on program startup. </p>

</div>
</div>
<a id="a1d20f39e4623982dbe2b03fedbdf1374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d20f39e4623982dbe2b03fedbdf1374">&#9670;&nbsp;</a></span>create_unity_global_singleton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::create_unity_global_singleton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1toolkit__function__registry.html">toolkit_function_registry</a> *&#160;</td>
          <td class="paramname"><em>_toolkit_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1toolkit__class__registry.html">toolkit_class_registry</a> *&#160;</td>
          <td class="paramname"><em>_classes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the <a class="el" href="classturi_1_1unity__global.html">unity_global</a> singleton, passing in the arguments into the <a class="el" href="classturi_1_1unity__global.html">unity_global</a> constructor </p>

</div>
</div>
<a id="abdf4d2fbf53fba839b18a35d368924c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf4d2fbf53fba839b18a35d368924c6">&#9670;&nbsp;</a></span>decode_image_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::decode_image_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1image__type.html">image_type</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an image raw. </p>

</div>
</div>
<a id="a44d76d18027e4e0c8ac3141490c67e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d76d18027e4e0c8ac3141490c67e6c">&#9670;&nbsp;</a></span>encode_image_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::encode_image_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1image__type.html">image_type</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an image png if raw. </p>

</div>
</div>
<a id="ae830551f09920d9b64680bf3515a6f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae830551f09920d9b64680bf3515a6f32">&#9670;&nbsp;</a></span>escape_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::escape_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escape_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_escape_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>quote_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_quote_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>double_quote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>output_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Escapes a string from val into output. The length of the output string is in returned in output_len. Note that output.length() may be greater than the output_len.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The string to escape </td></tr>
    <tr><td class="paramname">escape_char</td><td>The escape character to use (recommended '\') </td></tr>
    <tr><td class="paramname">use_escape_char</td><td>If true, escape character is used. Note that if this is false, the resultant string may not always be parseable. </td></tr>
    <tr><td class="paramname">quote_char</td><td>The quote character to use. (recommended '"') </td></tr>
    <tr><td class="paramname">use_quote_char</td><td>If the output string should be quoted </td></tr>
    <tr><td class="paramname">double_quote</td><td>If double quotes are converted to single quotes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c70151020bc0f0c9dddcfe8c83e7095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c70151020bc0f0c9dddcfe8c83e7095">&#9670;&nbsp;</a></span>export_activity_classifier_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;coreml::MLModelWrapper&gt; turi::export_activity_classifier_model </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1neural__net_1_1model__spec.html">neural_net::model_spec</a> &amp;&#160;</td>
          <td class="paramname"><em>nn_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prediction_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a> &amp;&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lstm_hidden_layer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a> &amp;&#160;</td>
          <td class="paramname"><em>class_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wraps a trained activity classifier model_spec as a complete MLModel. </p>

</div>
</div>
<a id="a30665b30c12e6d5ee807e5e68eae9bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30665b30c12e6d5ee807e5e68eae9bd8">&#9670;&nbsp;</a></span>export_drawing_classifier_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;coreml::MLModelWrapper&gt; turi::export_drawing_classifier_model </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1neural__net_1_1model__spec.html">neural_net::model_spec</a> &amp;&#160;</td>
          <td class="paramname"><em>nn_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a> &amp;&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a> &amp;&#160;</td>
          <td class="paramname"><em>class_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wraps a trained drawing classifier model_spec as a complete MLModel. </p>

</div>
</div>
<a id="af8f198ba330dd013625dbf4b410a2567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f198ba330dd013625dbf4b410a2567">&#9670;&nbsp;</a></span>export_linear_regression_as_model_asset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;coreml::MLModelWrapper&gt; turi::export_linear_regression_as_model_asset </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Export as model asset </p>

</div>
</div>
<a id="a2f8f75adab79449ded48cf73fff58ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8f75adab79449ded48cf73fff58ac7">&#9670;&nbsp;</a></span>export_linear_regression_as_model_asset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EXPORT turi::export_linear_regression_as_model_asset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simplified versions of the above, with exported symbol visibility so that extensions can link to them. </p>

</div>
</div>
<a id="a219221c1a9c8d5c4eaa144d26a71418e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219221c1a9c8d5c4eaa144d26a71418e">&#9670;&nbsp;</a></span>export_linear_svm_as_model_asset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;coreml::MLModelWrapper&gt; turi::export_linear_svm_as_model_asset </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Export linear SVM as model asset. </p>

</div>
</div>
<a id="abb5b914fec49a52404c26b980ee6f44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5b914fec49a52404c26b980ee6f44a">&#9670;&nbsp;</a></span>export_logistic_model_as_model_asset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;coreml::MLModelWrapper&gt; turi::export_logistic_model_as_model_asset </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Export logistic regression as model asset. </p>

</div>
</div>
<a id="aeea2a6da92509b0b7ae9f23a17b38154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea2a6da92509b0b7ae9f23a17b38154">&#9670;&nbsp;</a></span>export_object_detector_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;coreml::MLModelWrapper&gt; turi::export_object_detector_model </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1neural__net_1_1pipeline__spec.html">neural_net::pipeline_spec</a>&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_classes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_predictions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__flexible__type__types.html#ga6850eab6f89c527876575257a7c271ce">flex_list</a>&#160;</td>
          <td class="paramname"><em>class_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>confidence_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>iou_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_non_maximum_suppression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_nms_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_most_confident_class</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wraps a trained object detector model_spec as a complete MLModel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn_spec</td><td>The NeuralNetwork to wrap, which must accept an input "image" with shape (3, image_height, image_width) and values in [0,1], output "confidence" with shape (num_predictions, num_classes), and "coordinates" with shape (num_predictions, 4). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8813fec2c1c8be93a8d50d2c11379a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8813fec2c1c8be93a8d50d2c11379a0">&#9670;&nbsp;</a></span>export_style_transfer_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;coreml::MLModelWrapper&gt; turi::export_style_transfer_model </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1neural__net_1_1model__spec.html">neural_net::model_spec</a> &amp;&#160;</td>
          <td class="paramname"><em>nn_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>image_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>image_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_flexible_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>content_feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>style_feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_styles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wraps a trained style transfer model_spec as a complete MLModel. </p>

</div>
</div>
<a id="ac0897de203f0665490c3e558b3b8375b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0897de203f0665490c3e558b3b8375b">&#9670;&nbsp;</a></span>find_slice_boundary_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__util.html#ga8750328f64c9b85845e920eecaf7094e">GL_HOT_INLINE</a> std::pair&lt;size_t, size_t&gt; turi::find_slice_boundary_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; size_t, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item_index_lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item_index_ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a sorted sparse vector of (index, value) pairs, efficiently find and return a pair of indices (i1, i2) in the vector such that (item_index_lb &lt;= v[i].first &lt; item_index_ub) for all i = (i1, ..., i2 - 1), and false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="utilities_8hpp_source.html#l00026">26</a> of file <a class="el" href="utilities_8hpp_source.html">utilities.hpp</a>.</p>

</div>
</div>
<a id="ad17984781be5bb7adafe78ee2a6633dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17984781be5bb7adafe78ee2a6633dc">&#9670;&nbsp;</a></span>first_n_bits_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool turi::first_n_bits_on </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>top_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the first n bits of v are on.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Unsigned integer value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00394">394</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a532ea655972eb0b72dc40ad14fd82075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532ea655972eb0b72dc40ad14fd82075">&#9670;&nbsp;</a></span>flex_type_enum_from_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> turi::flex_type_enum_from_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the printable name of a <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> type, returns its corresponding <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> enumeration value. Reverse of <a class="el" href="namespaceturi.html#a65de5f31193ee46ccb4cfd60cddfaaa6">flex_type_enum_to_name</a>. </p>

<p class="definition">Definition at line <a class="el" href="flexible__type__base__types_8hpp_source.html#l00750">750</a> of file <a class="el" href="flexible__type__base__types_8hpp_source.html">flexible_type_base_types.hpp</a>.</p>

</div>
</div>
<a id="a65de5f31193ee46ccb4cfd60cddfaaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65de5f31193ee46ccb4cfd60cddfaaa6">&#9670;&nbsp;</a></span>flex_type_enum_to_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* turi::flex_type_enum_to_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>en</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a printable name of a flex_type_enum. Reverse of <a class="el" href="namespaceturi.html#a532ea655972eb0b72dc40ad14fd82075">flex_type_enum_from_name</a> </p>

<p class="definition">Definition at line <a class="el" href="flexible__type__base__types_8hpp_source.html#l00719">719</a> of file <a class="el" href="flexible__type__base__types_8hpp_source.html">flexible_type_base_types.hpp</a>.</p>

</div>
</div>
<a id="a95083e63ff7e20e03de8833909a699f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95083e63ff7e20e03de8833909a699f1">&#9670;&nbsp;</a></span>flex_type_has_binary_op()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::flex_type_has_binary_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if numeric operators between these types are supported. if a and b are flexible_types and flex_type_has_binary_op(a.get_type(), b.get_type(), op) is true, this means. that a op= b and a op b is false. op is any of '+','-','*','/','','&lt;','&gt;','='</p>
<p>'&lt;' is the less than operator, and '&gt;' is the greater than operator. '=' is the equality comparison operator. Suceeding on '&lt;' or '&gt;' implies that the less than or equal operator (&lt;=) and the greater than or equal operator (&gt;=) will also succeed</p>
<p>For instance given <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> a, b </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespaceturi.html#a95083e63ff7e20e03de8833909a699f1">flex_type_has_binary_op</a>(a, b, <span class="charliteral">&#39;+&#39;</span>)) {</div><div class="line">  a += b <span class="comment">// will succeed</span></div><div class="line">  a + b  <span class="comment">// will succeed</span></div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">  a += b <span class="comment">// will fail</span></div><div class="line">  a + b  <span class="comment">// will fail</span></div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="flexible__type__base__types_8hpp_source.html#l00393">393</a> of file <a class="el" href="flexible__type__base__types_8hpp_source.html">flexible_type_base_types.hpp</a>.</p>

</div>
</div>
<a id="a5163d800c1557ce946f305d93665dbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5163d800c1557ce946f305d93665dbc1">&#9670;&nbsp;</a></span>flex_type_is_convertible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::flex_type_is_convertible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a>&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if one flexible type is convertable to the other. </p>

<p class="definition">Definition at line <a class="el" href="flexible__type__base__types_8hpp_source.html#l00353">353</a> of file <a class="el" href="flexible__type__base__types_8hpp_source.html">flexible_type_base_types.hpp</a>.</p>

</div>
</div>
<a id="ac50d334ec1920c64f0eb5e5753a2683e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50d334ec1920c64f0eb5e5753a2683e">&#9670;&nbsp;</a></span>flexible_type_to_json()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JSONNode turi::flexible_type_to_json </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper utility for converting from <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> to json. TODO: Fill in details </p>

<p class="definition">Definition at line <a class="el" href="json__util_8hpp_source.html#l00016">16</a> of file <a class="el" href="json__util_8hpp_source.html">json_util.hpp</a>.</p>

</div>
</div>
<a id="a4b2b8f5911ab7feba4b935b857be0cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2b8f5911ab7feba4b935b857be0cc6">&#9670;&nbsp;</a></span>flexmap_to_varmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a>&gt; turi::flexmap_to_varmap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast each flexible type to variant type. </p>

<p class="definition">Definition at line <a class="el" href="toolkit__util_8hpp_source.html#l00046">46</a> of file <a class="el" href="toolkit__util_8hpp_source.html">toolkit_util.hpp</a>.</p>

</div>
</div>
<a id="afb9f4fdffa17cc02e3f1200dd1b2aa23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9f4fdffa17cc02e3f1200dd1b2aa23">&#9670;&nbsp;</a></span>flip_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void turi::flip_bit </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flips a bit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Reference to unsigned integer to change. </td></tr>
    <tr><td class="paramname">bit</td><td>Index of the bit to flip. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00111">111</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a9a238b8e9e1ac815ea7f3cd96b899a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a238b8e9e1ac815ea7f3cd96b899a18">&#9670;&nbsp;</a></span>get_common_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> turi::get_common_type </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a set of types, choose a common type that all types in the set can be converted to and preserves the most data. Not designed to be passed a set with UNDEFINED in it. </p>

<p class="definition">Definition at line <a class="el" href="flexible__type__base__types_8hpp_source.html#l00826">826</a> of file <a class="el" href="flexible__type__base__types_8hpp_source.html">flexible_type_base_types.hpp</a>.</p>

</div>
</div>
<a id="ab5bb1f3b0e8696eb7a9e54404d14ef3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5bb1f3b0e8696eb7a9e54404d14ef3a">&#9670;&nbsp;</a></span>get_curl_error_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::get_curl_error_string </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the curl error string for a curl error code returned by download_url. </p>

</div>
</div>
<a id="ae881ed75b07502551ff0d650a7fb4836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae881ed75b07502551ff0d650a7fb4836">&#9670;&nbsp;</a></span>get_my_pid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::get_my_pid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the PID of my current process. </p>

</div>
</div>
<a id="ae2aa7d0c17d793a41e0d2e0fa4411a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2aa7d0c17d793a41e0d2e0fa4411a04">&#9670;&nbsp;</a></span>get_unity_global_singleton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1unity__global.html">unity_global</a>&gt; turi::get_unity_global_singleton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a pointer to the unity global singleton </p>

</div>
</div>
<a id="a49aa840d12810de2e59ee965256b9713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49aa840d12810de2e59ee965256b9713">&#9670;&nbsp;</a></span>get_variant_which_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string turi::get_variant_which_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given variant.which() gets the name of the type inside it. </p>

<p class="definition">Definition at line <a class="el" href="variant_8hpp_source.html#l00069">69</a> of file <a class="el" href="variant_8hpp_source.html">variant.hpp</a>.</p>

</div>
</div>
<a id="a099a2e1c2a154bf57ec26b704ed19d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099a2e1c2a154bf57ec26b704ed19d47">&#9670;&nbsp;</a></span>index_first_on_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int turi::index_first_on_bit </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the index of the first on bit in v. For example, 010111011000 gives 3. Returns bitsizeof(T) if v is zero.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Unsigned integer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00260">260</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a236bc9bd292f41e87a06d55d83ea661d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236bc9bd292f41e87a06d55d83ea661d">&#9670;&nbsp;</a></span>index_last_on_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int turi::index_last_on_bit </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index of the last on bit. For example, 01101100 is 6. Returns bitsizeof(T) if v is zero.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Unsigned integer value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00343">343</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a4b4187e63c2a35218e0b8c574657012b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4187e63c2a35218e0b8c574657012b">&#9670;&nbsp;</a></span>infer_type_of_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceturi.html#a232ed812da2796b7bd317ea4b3a21f76">flex_type_enum</a> turi::infer_type_of_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to infer the most general type of an in memory vector of flexible_types. </p>

</div>
</div>
<a id="ac2a4ccf353c5cfe791a994b8015c0756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a4ccf353c5cfe791a994b8015c0756">&#9670;&nbsp;</a></span>is_power_of_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool turi::is_power_of_2 </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests if x is a power of 2 (i.e. if just one bit is on).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Unsigned integer to test. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00052">52</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="aa7dc62f726e970d8994a01a66175a538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dc62f726e970d8994a01a66175a538">&#9670;&nbsp;</a></span>iterate_through_sparse_item_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename RowProcessFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::iterate_through_sparse_item_array </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; std::vector&lt; std::pair&lt; size_t, T &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RowProcessFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>process_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates through a sparse vector sarray efficiently, calling a prescribed function on each row and on each element.</p>
<h2>Parameters: </h2>
<p>data &ndash; an sarray of vectors of (index, value) pairs. This vector must be sorted by index.</p>
<p>preprocess_row &ndash; the function called on every row. It has the signature: </p><pre class="fragment"> preprocess_row(size_t thread_idx, size_t row_idx,
                std::vector&lt;std::pair&lt;size_t, T&gt; &gt;&amp; row)
</pre><p>In this case, row_idx is the row currently being processed and row is the current row. Any modifications to row are discarded after this. </p>

<p class="definition">Definition at line <a class="el" href="utilities_8hpp_source.html#l00279">279</a> of file <a class="el" href="utilities_8hpp_source.html">utilities.hpp</a>.</p>

</div>
</div>
<a id="a845719d1ce226dde6c31d2aa468d8836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845719d1ce226dde6c31d2aa468d8836">&#9670;&nbsp;</a></span>iterate_through_sparse_item_array_by_slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SliceInitFunction , typename RowProcessFunction , typename ElementProcessFunction , typename SliceFinalizeFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::iterate_through_sparse_item_array_by_slice </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; std::vector&lt; std::pair&lt; size_t, T &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice_delimiters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceInitFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>init_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RowProcessFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>preprocess_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementProcessFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>process_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SliceFinalizeFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>finalize_slice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates through a sparse vector sarray by column slices, with possible optimizations for other functionality. Each row in <code>data</code> is assumed to be a sorted vector of (index, value) pairs, and this function does multiple passes through the data, with each pass handling a contiguous slice of the indices in each row. These slices are determined by the slice_delimiters vector.</p>
<h2>Parameters: </h2>
<p>data &ndash; an sarray of vectors of (index, value) pairs. This vector must be sorted by index.</p>
<p>slice_delimiters &ndash; A vector of length (num_slices - 1) that give the boundaries of the slices of indices. For example, [0, 5, 10, 12] would have 3 slices, with (0,5), (5, 10), and (10, 12) being the slices processed.</p>
<p>init_slice &ndash; called at the beginning of each slice, before the data is processed. init_slice has the signature </p><pre class="fragment">init_slice(size_t slice_idx, size_t item_idx_start, size_t item_idx_end)
</pre><p>where slice_idx is the slice counter (0, 1, ...), and item_idx_start and item_idx_end are taken from slice_boundaries[slice_idx] and slice_boundaries[slice_idx - 1].</p>
<p>preprocess_row &ndash; the function called on every row. It has the signature: </p><pre class="fragment"> preprocess_row(size_t thread_idx, size_t row_idx,
                size_t slice_item_idx_start, size_t slice_item_idx_end,
                std::vector&lt;std::pair&lt;size_t, T&gt; &gt;&amp; row)
</pre><p>In this case, row_idx is the row currently being processed, slice_item_idx_start and slice_item_idx_end are taken from the current slice, and row is the current row. The row can be modified, but any resulting modifications must preserve the sorted nature. If the row is empty upon return, then processing all future elements is skipped.</p>
<p>process_element &ndash; the function called on every element. It has the signature: </p><pre class="fragment"> process_element(size_t thread_idx, size_t row_idx,
                 size_t item_idx_start, size_t item_idx_end,
                 size_t item_idx, const T&amp; value)
</pre><p>In this case, row_idx is the row currently being processed, item_idx_start and item_idx_end are taken from the slice, item_idx is the index of the value in the row, and value is the value.</p>
<p>finalize_slice &ndash; the function called at the end of every slice. It has the same signature as init_slice: </p><pre class="fragment"> finalize_slice(size_t slice_idx, size_t item_idx_start, size_t item_idx_end)</pre> 
<p class="definition">Definition at line <a class="el" href="utilities_8hpp_source.html#l00146">146</a> of file <a class="el" href="utilities_8hpp_source.html">utilities.hpp</a>.</p>

</div>
</div>
<a id="a5600b7667813008a0a49e09e63ef3dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5600b7667813008a0a49e09e63ef3dc4">&#9670;&nbsp;</a></span>log1me()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double turi::log1me </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Numerically stable version of log(1 - exp(x) ) </p>

<p class="definition">Definition at line <a class="el" href="logit__math_8hpp_source.html#l00056">56</a> of file <a class="el" href="logit__math_8hpp_source.html">logit_math.hpp</a>.</p>

</div>
</div>
<a id="a89243ba817f3e0649f932f3d8519278e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89243ba817f3e0649f932f3d8519278e">&#9670;&nbsp;</a></span>log1men()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double turi::log1men </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Numerically stable version of log(1 - exp(-x) ) </p>

<p class="definition">Definition at line <a class="el" href="logit__math_8hpp_source.html#l00064">64</a> of file <a class="el" href="logit__math_8hpp_source.html">logit_math.hpp</a>.</p>

</div>
</div>
<a id="ad7e4555283ef5773a9e2d0f7d9a35ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e4555283ef5773a9e2d0f7d9a35ada">&#9670;&nbsp;</a></span>log1pe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double turi::log1pe </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Numerically stable version of log(1 + exp(x) ) </p>

<p class="definition">Definition at line <a class="el" href="logit__math_8hpp_source.html#l00042">42</a> of file <a class="el" href="logit__math_8hpp_source.html">logit_math.hpp</a>.</p>

</div>
</div>
<a id="a15a04229ebad06076c37abc50d640c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a04229ebad06076c37abc50d640c5e">&#9670;&nbsp;</a></span>log1pe_deriviative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double turi::log1pe_deriviative </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Numerically stable version of d/dx (log(1 + exp(x) )) = 1 / (1 + exp(-x)) = sigmoid(x). </p>

<p class="definition">Definition at line <a class="el" href="logit__math_8hpp_source.html#l00080">80</a> of file <a class="el" href="logit__math_8hpp_source.html">logit_math.hpp</a>.</p>

</div>
</div>
<a id="a6395f16416d199a2df25a21c31cdb0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6395f16416d199a2df25a21c31cdb0c2">&#9670;&nbsp;</a></span>log1pen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double turi::log1pen </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Numerically stable version of log(1 + exp(-x) ) </p>

<p class="definition">Definition at line <a class="el" href="logit__math_8hpp_source.html#l00049">49</a> of file <a class="el" href="logit__math_8hpp_source.html">logit_math.hpp</a>.</p>

</div>
</div>
<a id="a54021649246b9412defe52a7dce47e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54021649246b9412defe52a7dce47e0c">&#9670;&nbsp;</a></span>log1pen_deriviative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double turi::log1pen_deriviative </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Numerically stable version of d/dx (log(1 + exp(-x) )) = -1 / (1 + exp(x)). </p>

<p class="definition">Definition at line <a class="el" href="logit__math_8hpp_source.html#l00088">88</a> of file <a class="el" href="logit__math_8hpp_source.html">logit_math.hpp</a>.</p>

</div>
</div>
<a id="a0877f2ccb7dbec498442c05d2a8af5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0877f2ccb7dbec498442c05d2a8af5a6">&#9670;&nbsp;</a></span>logem1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double turi::logem1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Numerically stable version of log(exp(x) - 1) </p>

<p class="definition">Definition at line <a class="el" href="logit__math_8hpp_source.html#l00072">72</a> of file <a class="el" href="logit__math_8hpp_source.html">logit_math.hpp</a>.</p>

</div>
</div>
<a id="a8a473f1d62e742337465699da6367965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a473f1d62e742337465699da6367965">&#9670;&nbsp;</a></span>make_random_sframe_and_ml_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classturi_1_1sframe.html">sframe</a>, <a class="el" href="classturi_1_1ml__data.html">ml_data</a>&gt; turi::make_random_sframe_and_ml_data </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>column_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_target_column</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>target_column_categorical</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a random SFrame for testing purposes. The column_type_info gives the types of the column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_rows</td><td>The number of observations to run the timing on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column_type_info</td><td>A string with each character denoting one type of column. The legend is as follows:</td></tr>
  </table>
  </dd>
</dl>
<p>n: numeric column. b: categorical column with 2 categories. z: categorical column with 5 categories. Z: categorical column with 10 categories. c: categorical column with 100 categories. C: categorical column with 1000000 categories. s: categorical column with short string keys and 1000 categories. S: categorical column with short string keys and 100000 categories. v: numeric vector with 10 elements. V: numeric vector with 1000 elements. u: categorical set with up to 10 elements. U: categorical set with up to 1000 elements. d: dictionary with 10 entries. D: dictionary with 100 entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">create_target_column</td><td>If true, then create a random target column as well.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of sframe, with the raw data, and an <a class="el" href="classturi_1_1ml__data.html">ml_data</a> object made from that sframe. </dd></dl>

</div>
</div>
<a id="a5d4c7093dd9c45bb94ea622b5e2d1751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4c7093dd9c45bb94ea622b5e2d1751">&#9670;&nbsp;</a></span>ml_testing_equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool turi::ml_testing_equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Better equality testing stuff. Handles out-of-order on the categorical_vector, which is assumed by <a class="el" href="classturi_1_1ml__data.html">ml_data</a>. </p>

<p class="definition">Definition at line <a class="el" href="ml_2ml__data_2testing__utils_8hpp_source.html#l00057">57</a> of file <a class="el" href="ml_2ml__data_2testing__utils_8hpp_source.html">testing_utils.hpp</a>.</p>

</div>
</div>
<a id="ab10551f02caef79c883e68d9b9297c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10551f02caef79c883e68d9b9297c71">&#9670;&nbsp;</a></span>n_leading_ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int turi::n_leading_ones </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the number of leading ones in v. For example, 11011000 has 2 leading ones. Returns bitsizeof(T) if v is (~0).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Unsigned integer value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00331">331</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="aaf24bec9135a748a2bfa0ba11274abc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf24bec9135a748a2bfa0ba11274abc4">&#9670;&nbsp;</a></span>n_leading_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int turi::n_leading_zeros </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the number of leading zeros in v. For example, 01011000 has 1 leading zero. Returns bitsizeof(T) if v is zero.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Unsigned integer value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00287">287</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a285e0576c00feceff6a7ea794ada1e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285e0576c00feceff6a7ea794ada1e42">&#9670;&nbsp;</a></span>n_trailing_ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int turi::n_trailing_ones </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the number of trailing ones in v. For example, 010111010111 has 3 trailing ones. Returns bitsizeof(T) if v is (~0).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Unsigned integer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00248">248</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="ac8e5046873151c5cba6294c03a39a3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e5046873151c5cba6294c03a39a3a4">&#9670;&nbsp;</a></span>n_trailing_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int turi::n_trailing_zeros </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the number of trailing zeros in v. For example, 010111011000 has 3 trailing zeros. Returns bitsizeof(T) if v is zero.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of v. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Unsigned integer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00206">206</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="afd3fc0a7fbd4acedcfe0961d6f4b3b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3fc0a7fbd4acedcfe0961d6f4b3b39">&#9670;&nbsp;</a></span>num_bits_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int turi::num_bits_on </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts the number of bits on in x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Unsigned integer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00154">154</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="a9df09423ccd9d8dfeccd98adf9c6287f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df09423ccd9d8dfeccd98adf9c6287f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; turi::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides printing of the <a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a>. </p>

</div>
</div>
<a id="a26f09d91617696aa2a93dae054142c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f09d91617696aa2a93dae054142c4e">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; turi::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides printing of the <a class="el" href="classturi_1_1gl__sframe.html">gl_sframe</a>. </p>

</div>
</div>
<a id="a038a75dabfb984fcb3a983de4556d68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038a75dabfb984fcb3a983de4556d68d">&#9670;&nbsp;</a></span>parse_jpeg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::parse_jpeg </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the image information, set width, height and channels using libjpeg. </p>

</div>
</div>
<a id="abac1a9b3f0a93e841933c44c72ddf2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac1a9b3f0a93e841933c44c72ddf2c5">&#9670;&nbsp;</a></span>parse_png()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::parse_png </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the image information, set width, height and channels using libpng. </p>

</div>
</div>
<a id="a96f956da5b0f586de1140168890dfb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f956da5b0f586de1140168890dfb1a">&#9670;&nbsp;</a></span>print_training_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::print_training_device </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>gpu_names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This prints the verbose statements based on GPU names it gets from the respective compute contexts. </p>

</div>
</div>
<a id="ac20946a7fa4fc493e32694f38127031a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20946a7fa4fc493e32694f38127031a">&#9670;&nbsp;</a></span>read_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1image__type.html">image_type</a> turi::read_image </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format_hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the content from url and return an image type object. Throws an exception if failing to decode as format_hint. </p>

</div>
</div>
<a id="ad334d106e681dbeb62fe12f20a9587f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad334d106e681dbeb62fe12f20a9587f8">&#9670;&nbsp;</a></span>read_raw_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::read_raw_image </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1be">Format</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format_hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read raw image data from URL, store data in data and length. Store image information such as width, height, channels, and format. </p>

</div>
</div>
<a id="a5dc576e62a6ee3e65da2ac00c3571049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc576e62a6ee3e65da2ac00c3571049">&#9670;&nbsp;</a></span>run_as_native()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::result_of&lt;F(Args...)&gt;::type turi::run_as_native </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes a function call and runs it in a native stack space. Used to get by some libjvm oddities when using coroutines.</p>
<p>Returns an exception if an exception was thrown while executing the inner task. </p>

<p class="definition">Definition at line <a class="el" href="execute__task__in__native__thread_8hpp_source.html#l00156">156</a> of file <a class="el" href="execute__task__in__native__thread_8hpp_source.html">execute_task_in_native_thread.hpp</a>.</p>

</div>
</div>
<a id="af794f279568f80357f1a09d391510b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af794f279568f80357f1a09d391510b2f">&#9670;&nbsp;</a></span>sarray_compact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::sarray_compact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>segment_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inplace compacts an SArray. Fast compact is tried first and if the number of segments do not fall below the target, a slow compaction is performed. </p>

<p class="definition">Definition at line <a class="el" href="sframe__compact__impl_8hpp_source.html#l00124">124</a> of file <a class="el" href="sframe__compact__impl_8hpp_source.html">sframe_compact_impl.hpp</a>.</p>

</div>
</div>
<a id="a6297d191a2e0f8845ea5f57bc125c4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6297d191a2e0f8845ea5f57bc125c4cf">&#9670;&nbsp;</a></span>sarray_fast_compact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool turi::sarray_fast_compact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sarray_fast_compact looks for runs of small segments (comprising of less than FAST_COMPACT_BLOCKS_IN_SMALL_SEGMENT block), and rebuilds them into bigger segments. Returns true if any compaction was performed. </p>

<p class="definition">Definition at line <a class="el" href="sframe__compact__impl_8hpp_source.html#l00049">49</a> of file <a class="el" href="sframe__compact__impl_8hpp_source.html">sframe_compact_impl.hpp</a>.</p>

</div>
</div>
<a id="ae90a672c9c68e811c3bad2a78718d856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90a672c9c68e811c3bad2a78718d856">&#9670;&nbsp;</a></span>set_bit_off()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void turi::set_bit_off </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a bit to be off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Reference to unsigned integer to change. </td></tr>
    <tr><td class="paramname">bit</td><td>Index of the bit to set off. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00087">87</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="aa8b07f83c28df8b76eccd2b581be5a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b07f83c28df8b76eccd2b581be5a87">&#9670;&nbsp;</a></span>set_bit_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void turi::set_bit_on </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ENABLE_IF_UINT(T)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a bit to be on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Reference to unsigned integer to change. </td></tr>
    <tr><td class="paramname">bit</td><td>Index of the bit to set on. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="bitops_8hpp_source.html#l00099">99</a> of file <a class="el" href="bitops_8hpp_source.html">bitops.hpp</a>.</p>

</div>
</div>
<a id="aef2291d40ba400f9fed0fbcd55c20810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2291d40ba400f9fed0fbcd55c20810">&#9670;&nbsp;</a></span>setup_pipeline_from_mldata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::setup_pipeline_from_mldata </td>
          <td>(</td>
          <td class="paramtype">CoreML::Pipeline &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt;&#160;</td>
          <td class="paramname"><em>metadata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates a pipeline from an MLData metadata object so that it takes the input in the form of the input from the mldata, then outputs it as a final vector named <b>vectorized_features</b> that can then be used by other algorithms. The pipeline is returned. The input variables of the pipeline are the same as those given in the <a class="el" href="classturi_1_1ml__data.html">ml_data</a> metadata object. The classifier or regressor needs to be added to the pipeline, along with the appropriate output variables. </p>

</div>
</div>
<a id="a916db418123be432c2fa91d4e2e04a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916db418123be432c2fa91d4e2e04a7c">&#9670;&nbsp;</a></span>sframe_compact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::sframe_compact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>segment_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inplace compacts an SFrame. Fast compact is tried first and if the number of segments do not fall below the target, a slow compaction is performed. </p>

</div>
</div>
<a id="a3cd8b556a3ee14f1d63177cb56fdd14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd8b556a3ee14f1d63177cb56fdd14e">&#9670;&nbsp;</a></span>sframe_fast_compact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool turi::sframe_fast_compact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1sframe.html">sframe</a> &amp;&#160;</td>
          <td class="paramname"><em>sf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sframe_fast_compact looks for runs of small segments (comprising of less than FAST_COMPACT_BLOCKS_IN_SMALL_SEGMENT block), and rebuilds them into bigger segments. Returns true if any compaction was performed. </p>

</div>
</div>
<a id="a963920bf11ee9d5069b14395b6e81cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963920bf11ee9d5069b14395b6e81cab">&#9670;&nbsp;</a></span>sigmoid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__util.html#ga8691ea9431a3d3a1acf2d2b7eac72b92">GL_HOT_INLINE_FLATTEN</a> double turi::sigmoid </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Numerically stable version of 1 / (1 + exp(-x));</p>
<p>If x &lt; 0, then this is equal to</p>
<p>exp(- abs(x)) / (1 + exp(-abs(x))) = 1 / (1 + exp(x))</p>
<p>If x &gt;=0, then this is equal to 1 / (1 + exp(-x)).</p>
<p>This separation into the positive and negative case is so that the code never uses the result of exp(x) where x is large and positive, which could easily result in overflow. </p>

<p class="definition">Definition at line <a class="el" href="logit__math_8hpp_source.html#l00031">31</a> of file <a class="el" href="logit__math_8hpp_source.html">logit_math.hpp</a>.</p>

</div>
</div>
<a id="a6ff3de78d5d1e8ab742cf8c185db5f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff3de78d5d1e8ab742cf8c185db5f7a">&#9670;&nbsp;</a></span>stop_log_rotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::stop_log_rotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops log rotation.</p>
<p>No-op if log rotation was not started.</p>
<p>Not safe for concurrent use. </p>

</div>
</div>
<a id="acf17c7990e00eab46358ea2f7865faee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf17c7990e00eab46358ea2f7865faee">&#9670;&nbsp;</a></span>to_flat_dict() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a> turi::to_flat_dict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dict_or_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;&#160;</td>
          <td class="paramname"><em>undefined_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>(const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>nonnumeric_value_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flattens list or dictionary types to a non-nested dictionary of (string key : numeric value) pairs. Each nested key is a concatenation of the keys in the separation with sep_char separating them. For example, if sep_char = ".", then</p>
<p>{"a" : {"b" : 1}, "c" : 2}</p>
<p>becomes</p>
<p>{"a.b" : 1, "c" : 2}.</p>
<ul>
<li>List and vector elements are handled by converting the index of the appropriate element to a string.</li>
<li>String values are handled by treating them as a single {"string_value" : 1} pair.</li>
<li>FLEX_UNDEFINED values are handled by replacing them with the string contents of <code>undefined_string</code>.</li>
<li>image and datetime types are handled by calling image_value_handler and datetime_value_handler. These functions must either throw an exception, which propegates up, return any other flexible type (e.g. dict, list, vector, etc.), or return FLEX_UNDEFINED, in which case that value is ignored. </li>
</ul>

</div>
</div>
<a id="a47dee7eafcb0830112b307af255480aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dee7eafcb0830112b307af255480aa">&#9670;&nbsp;</a></span>to_flat_dict() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flexible__type__types.html#ga408eb4413a2a629b462fb3a5d4f42c24">flex_dict</a> turi::to_flat_dict </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;&#160;</td>
          <td class="paramname"><em>separator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;&#160;</td>
          <td class="paramname"><em>undefined_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>image_policy</em> = <code>&quot;error&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>datetime_policy</em> = <code>&quot;error&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to to_flat_dict, except that image_policy and datetime_policy determine the handling of image and datetime types rather than a custom function. Currently, the only possible value for this is "error". </p>

</div>
</div>
<a id="a540a5abba9cb87b36865e3a15c87de31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540a5abba9cb87b36865e3a15c87de31">&#9670;&nbsp;</a></span>to_sarray_of_flat_dictionaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a> turi::to_sarray_of_flat_dictionaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classturi_1_1gl__sarray.html">gl_sarray</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__flexible__type__types.html#gaf154f20efeacc01dbbe38388a3067566">flex_string</a> &amp;&#160;</td>
          <td class="paramname"><em>undefined_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>image_policy</em> = <code>&quot;error&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>datetime_policy</em> = <code>&quot;error&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies to_flat_dict to all elements in an sarray, returning the transformed sarray. </p>

</div>
</div>
<a id="a4089b0a7d421bba15b1510e3816c11ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4089b0a7d421bba15b1510e3816c11ab">&#9670;&nbsp;</a></span>to_variant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> turi::to_variant </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an arbitrary value to a variant. T can be <b>alot</b> of possibilities. See the supported type list for details. </p>

<p class="definition">Definition at line <a class="el" href="variant_8hpp_source.html#l00308">308</a> of file <a class="el" href="variant_8hpp_source.html">variant.hpp</a>.</p>

</div>
</div>
<a id="a6d0e2ccadc441f5863ce350a4a13cbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0e2ccadc441f5863ce350a4a13cbb7">&#9670;&nbsp;</a></span>translate_row_to_ml_data_entry() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structturi_1_1ml__data__entry.html">ml_data_entry</a>&gt; turi::translate_row_to_ml_data_entry </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structturi_1_1ml__data__entry__global__index.html">ml_data_entry_global_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translation from one row type to another </p>

</div>
</div>
<a id="a2bd4ccaf03d4989c964b7d73653ef907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd4ccaf03d4989c964b7d73653ef907">&#9670;&nbsp;</a></span>translate_row_to_ml_data_entry() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structturi_1_1ml__data__entry.html">ml_data_entry</a>&gt; turi::translate_row_to_ml_data_entry </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector &amp;&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translation routines. </p>

</div>
</div>
<a id="a7543f0279215f40b8abdda5293e40f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7543f0279215f40b8abdda5293e40f22">&#9670;&nbsp;</a></span>translate_row_to_ml_data_entry() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structturi_1_1ml__data__entry.html">ml_data_entry</a>&gt; turi::translate_row_to_ml_data_entry </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseVector &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates the original sparse row format to the <a class="el" href="structturi_1_1ml__data__entry.html">ml_data_entry</a> vector. </p>

</div>
</div>
<a id="a449a1ee8679d98e9f4684d08d68b2e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449a1ee8679d98e9f4684d08d68b2e13">&#9670;&nbsp;</a></span>translate_row_to_original() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; turi::translate_row_to_original </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DenseVector &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates the original sparse row format to the original flexible types. </p>

</div>
</div>
<a id="a7148fa32f1857a7cc4df132c2f64af84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7148fa32f1857a7cc4df132c2f64af84">&#9670;&nbsp;</a></span>translate_row_to_original() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; turi::translate_row_to_original </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparseVector &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates the original sparse row format to the original flexible types. </p>

</div>
</div>
<a id="aa4ca8b3f0780a24c2d25863013d95d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ca8b3f0780a24c2d25863013d95d8e">&#9670;&nbsp;</a></span>translate_row_to_original() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; turi::translate_row_to_original </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classturi_1_1ml__metadata.html">ml_metadata</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structturi_1_1ml__data__entry__global__index.html">ml_data_entry_global_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate a vector of global indices to the next </p>

</div>
</div>
<a id="a4b93738530621930c5a07a906a5b1865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b93738530621930c5a07a906a5b1865">&#9670;&nbsp;</a></span>transpose_sparse_sarray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classturi_1_1sarray.html">sarray</a>&lt;std::vector&lt;std::pair&lt;size_t, T&gt; &gt; &gt; &gt; turi::transpose_sparse_sarray </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classturi_1_1sarray.html">sarray</a>&lt; std::vector&lt; std::pair&lt; size_t, T &gt; &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>item_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_memory_usage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transpose a sparse sarray of sorted vectors of entry pairs. Does it effeciently and close to within memory bounds.</p>
<p>The input data is a sarray of vectors of (column_index, value) pairs. This is then transposed to an similar sarray of vectors of (row_index, value) pairs, where each row consists of the matching values of column_index in the original sarray. The resulting vectors are sorted.</p>
<p>To do this efficiently, the number of elements for each column_index are required ahead of time. This is passed in as item_counts, which should be of size equal to the column dimension.</p>
<p>max_memory_usage gives the maximum memory allowed for the computation. The larger max_memory_usage is, the fewer passes through the data are required. </p>

<p class="definition">Definition at line <a class="el" href="utilities_8hpp_source.html#l00340">340</a> of file <a class="el" href="utilities_8hpp_source.html">utilities.hpp</a>.</p>

</div>
</div>
<a id="a2ccc44c9454b45c43047d828b57d6fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccc44c9454b45c43047d828b57d6fd1">&#9670;&nbsp;</a></span>unescape_string() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unescape_string </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>cal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_escape_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escape_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>quote_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>double_quote</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unescapes a string inplace </p>

</div>
</div>
<a id="a13115823b388e342edac6cb32fc8139a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13115823b388e342edac6cb32fc8139a">&#9670;&nbsp;</a></span>unescape_string() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::unescape_string </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>cal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escape_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>quote_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>double_quote</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unescapes a string inplace </p>

</div>
</div>
<a id="aa8e1c068cd0a8828f77ae63bc90b1274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e1c068cd0a8828f77ae63bc90b1274">&#9670;&nbsp;</a></span>unescape_string() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::unescape_string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>cal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_escape_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escape_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>quote_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>double_quote</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unescapes a string inplace, returning the new length </p>

</div>
</div>
<a id="a0526311cf92a664dffb244238f7a85f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0526311cf92a664dffb244238f7a85f1">&#9670;&nbsp;</a></span>unescape_string() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::unescape_string </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>cal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escape_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>quote_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>double_quote</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unescapes a string inplace, returning the new length </p>

</div>
</div>
<a id="a8f1166aee6a6372142009d91bdd6a13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1166aee6a6372142009d91bdd6a13d">&#9670;&nbsp;</a></span>variant_deep_load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::variant_deep_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1iarchive.html">iarchive</a> &amp;&#160;</td>
          <td class="paramname"><em>iarc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deserialize the variant type, allocate new resources for the pointer types. </p>

</div>
</div>
<a id="a3693451f85e001eb5311f4dcaceda27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3693451f85e001eb5311f4dcaceda27a">&#9670;&nbsp;</a></span>variant_deep_load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::variant_deep_load </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1iarchive.html">iarchive</a> &amp;&#160;</td>
          <td class="paramname"><em>iarc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of above for types castable to and from variant_type </p>

<p class="definition">Definition at line <a class="el" href="variant__deep__serialize_8hpp_source.html#l00040">40</a> of file <a class="el" href="variant__deep__serialize_8hpp_source.html">variant_deep_serialize.hpp</a>.</p>

</div>
</div>
<a id="ab2a1cd29c1b4f2058389f782411e6b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a1cd29c1b4f2058389f782411e6b1a">&#9670;&nbsp;</a></span>variant_deep_save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::variant_deep_save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1oarchive.html">oarchive</a> &amp;&#160;</td>
          <td class="paramname"><em>oarc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize the variant type, deep copying the pointer types. </p>

</div>
</div>
<a id="ade9ab2fd16f9f9abcc4fde3f86e4b428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9ab2fd16f9f9abcc4fde3f86e4b428">&#9670;&nbsp;</a></span>variant_deep_save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void turi::variant_deep_save </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classturi_1_1oarchive.html">oarchive</a> &amp;&#160;</td>
          <td class="paramname"><em>oarc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of above for types castable to and from variant_type </p>

<p class="definition">Definition at line <a class="el" href="variant__deep__serialize_8hpp_source.html#l00022">22</a> of file <a class="el" href="variant__deep__serialize_8hpp_source.html">variant_deep_serialize.hpp</a>.</p>

</div>
</div>
<a id="adc8eec97edcf72c280999c2f5e327e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8eec97edcf72c280999c2f5e327e12">&#9670;&nbsp;</a></span>variant_get_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T&amp; turi::variant_get_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a reference to a content of a variant. Throws if variant contains an inappropriate type. </p>

<p class="definition">Definition at line <a class="el" href="variant_8hpp_source.html#l00131">131</a> of file <a class="el" href="variant_8hpp_source.html">variant.hpp</a>.</p>

</div>
</div>
<a id="a6e8290f1526266dd5dfc96b95110c4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8290f1526266dd5dfc96b95110c4c0">&#9670;&nbsp;</a></span>variant_get_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const T&amp; turi::variant_get_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a const reference to the content of a variant. Throws if variant contains an inappropriate type. </p>

<p class="definition">Definition at line <a class="el" href="variant_8hpp_source.html#l00144">144</a> of file <a class="el" href="variant_8hpp_source.html">variant.hpp</a>.</p>

</div>
</div>
<a id="a895255301986d2f7bc3aa81a460e0f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895255301986d2f7bc3aa81a460e0f14">&#9670;&nbsp;</a></span>variant_get_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::decay&lt;T&gt;::type turi::variant_get_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads an arbitrary type from a variant. T can be <b>alot</b> of possibilities. See the supported type list for details. </p>

<p class="definition">Definition at line <a class="el" href="variant_8hpp_source.html#l00320">320</a> of file <a class="el" href="variant_8hpp_source.html">variant.hpp</a>.</p>

</div>
</div>
<a id="a95f64942a3fd22be6c4823c5107a2bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f64942a3fd22be6c4823c5107a2bde">&#9670;&nbsp;</a></span>variant_set_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void turi::variant_set_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a133f01ff63e13b5b78b761e5c78e0c25">variant_type</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores an arbitrary value in a variant </p>

<p class="definition">Definition at line <a class="el" href="variant_8hpp_source.html#l00297">297</a> of file <a class="el" href="variant_8hpp_source.html">variant.hpp</a>.</p>

</div>
</div>
<a id="a12e181638a581021583e9fb60c0c7a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e181638a581021583e9fb60c0c7a29">&#9670;&nbsp;</a></span>varmap_to_flexmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a>&gt; turi::varmap_to_flexmap </td>
          <td>(</td>
          <td class="paramtype">const variant_map_type &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract all <a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> values from the varmap into a std::map&lt;std::String, flexible_type&gt;. All other value types will be ignored. </p>

<p class="definition">Definition at line <a class="el" href="toolkit__util_8hpp_source.html#l00033">33</a> of file <a class="el" href="toolkit__util_8hpp_source.html">toolkit_util.hpp</a>.</p>

</div>
</div>
<a id="aa7681ae05529ccf8380697613715dcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7681ae05529ccf8380697613715dcf7">&#9670;&nbsp;</a></span>write_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void turi::write_image </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceturi.html#a9a91663acc51ef53b8d40f4efe12b1be">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the pixels into file as jpeg Only works with local files. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa645decb0a71f2af50301f4dcb336496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa645decb0a71f2af50301f4dcb336496">&#9670;&nbsp;</a></span>DEFAULT_NUM_GRAPH_LAMBDA_WORKERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::DEFAULT_NUM_GRAPH_LAMBDA_WORKERS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of graph lambda workers </p>

</div>
</div>
<a id="af3497457f9cc0ff907b406a901c9a82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3497457f9cc0ff907b406a901c9a82a">&#9670;&nbsp;</a></span>DEFAULT_NUM_PYLAMBDA_WORKERS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t turi::DEFAULT_NUM_PYLAMBDA_WORKERS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of pylambda workers </p>

</div>
</div>
<a id="a465691d12234a4c54e292f97dda0ac80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465691d12234a4c54e292f97dda0ac80">&#9670;&nbsp;</a></span>DIR_ARCHIVE_INI_FILE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* turi::DIR_ARCHIVE_INI_FILE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This file is the human readable INI file in the directory containing information about the archive. </p>

</div>
</div>
<a id="a1b7d5834c43f10bb674f0008616ff805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7d5834c43f10bb674f0008616ff805">&#9670;&nbsp;</a></span>DIR_ARCHIVE_OBJECTS_BIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* turi::DIR_ARCHIVE_OBJECTS_BIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This file is the binary archive used to hold serializable object. </p>

</div>
</div>
<a id="a239e289c661e697c9191abaaae05981d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239e289c661e697c9191abaaae05981d">&#9670;&nbsp;</a></span>FLEX_UNDEFINED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classturi_1_1flexible__type.html">flexible_type</a> turi::FLEX_UNDEFINED = <a class="el" href="structturi_1_1flex__undefined.html">flex_undefined</a>()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A global static variable to be used when an undefined value is needed. i.e. </p><div class="fragment"><div class="line">flexible_type f = <a class="code" href="namespaceturi.html#a239e289c661e697c9191abaaae05981d">FLEX_UNDEFINED</a>;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="flexible__type_8hpp_source.html#l01405">1405</a> of file <a class="el" href="flexible__type_8hpp_source.html">flexible_type.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceturi.html">turi</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
