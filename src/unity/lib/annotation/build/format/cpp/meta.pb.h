// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meta.proto

#ifndef PROTOBUF_meta_2eproto__INCLUDED
#define PROTOBUF_meta_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
namespace TuriCreate {
namespace Annotation {
namespace Specification {
class ActivityClassificationMeta;
class ActivityClassificationMetaDefaultTypeInternal;
extern ActivityClassificationMetaDefaultTypeInternal _ActivityClassificationMeta_default_instance_;
class AudioClassificationMeta;
class AudioClassificationMetaDefaultTypeInternal;
extern AudioClassificationMetaDefaultTypeInternal _AudioClassificationMeta_default_instance_;
class DrawingClassificationMeta;
class DrawingClassificationMetaDefaultTypeInternal;
extern DrawingClassificationMetaDefaultTypeInternal _DrawingClassificationMeta_default_instance_;
class ImageClassificationMeta;
class ImageClassificationMetaDefaultTypeInternal;
extern ImageClassificationMetaDefaultTypeInternal _ImageClassificationMeta_default_instance_;
class MetaData;
class MetaDataDefaultTypeInternal;
extern MetaDataDefaultTypeInternal _MetaData_default_instance_;
class ObjectDetectionMeta;
class ObjectDetectionMetaDefaultTypeInternal;
extern ObjectDetectionMetaDefaultTypeInternal _ObjectDetectionMeta_default_instance_;
}  // namespace Specification
}  // namespace Annotation
}  // namespace TuriCreate

namespace TuriCreate {
namespace Annotation {
namespace Specification {

namespace protobuf_meta_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_meta_2eproto

// ===================================================================

class ActivityClassificationMeta : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.ActivityClassificationMeta) */ {
 public:
  ActivityClassificationMeta();
  virtual ~ActivityClassificationMeta();

  ActivityClassificationMeta(const ActivityClassificationMeta& from);

  inline ActivityClassificationMeta& operator=(const ActivityClassificationMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityClassificationMeta& default_instance();

  static inline const ActivityClassificationMeta* internal_default_instance() {
    return reinterpret_cast<const ActivityClassificationMeta*>(
               &_ActivityClassificationMeta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ActivityClassificationMeta* other);

  // implements Message ----------------------------------------------

  inline ActivityClassificationMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivityClassificationMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivityClassificationMeta& from);
  void MergeFrom(const ActivityClassificationMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivityClassificationMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string labels = 1;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 1;
  const ::std::string& labels(int index) const;
  ::std::string* mutable_labels(int index);
  void set_labels(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_labels(int index, ::std::string&& value);
  #endif
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  ::std::string* add_labels();
  void add_labels(const ::std::string& value);
  #if LANG_CXX11
  void add_labels(::std::string&& value);
  #endif
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& labels() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_labels();

  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.ActivityClassificationMeta)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> labels_;
  mutable int _cached_size_;
  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AudioClassificationMeta : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.AudioClassificationMeta) */ {
 public:
  AudioClassificationMeta();
  virtual ~AudioClassificationMeta();

  AudioClassificationMeta(const AudioClassificationMeta& from);

  inline AudioClassificationMeta& operator=(const AudioClassificationMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const AudioClassificationMeta& default_instance();

  static inline const AudioClassificationMeta* internal_default_instance() {
    return reinterpret_cast<const AudioClassificationMeta*>(
               &_AudioClassificationMeta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AudioClassificationMeta* other);

  // implements Message ----------------------------------------------

  inline AudioClassificationMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  AudioClassificationMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AudioClassificationMeta& from);
  void MergeFrom(const AudioClassificationMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioClassificationMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string labels = 1;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 1;
  const ::std::string& labels(int index) const;
  ::std::string* mutable_labels(int index);
  void set_labels(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_labels(int index, ::std::string&& value);
  #endif
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  ::std::string* add_labels();
  void add_labels(const ::std::string& value);
  #if LANG_CXX11
  void add_labels(::std::string&& value);
  #endif
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& labels() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_labels();

  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.AudioClassificationMeta)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> labels_;
  mutable int _cached_size_;
  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DrawingClassificationMeta : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.DrawingClassificationMeta) */ {
 public:
  DrawingClassificationMeta();
  virtual ~DrawingClassificationMeta();

  DrawingClassificationMeta(const DrawingClassificationMeta& from);

  inline DrawingClassificationMeta& operator=(const DrawingClassificationMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const DrawingClassificationMeta& default_instance();

  static inline const DrawingClassificationMeta* internal_default_instance() {
    return reinterpret_cast<const DrawingClassificationMeta*>(
               &_DrawingClassificationMeta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(DrawingClassificationMeta* other);

  // implements Message ----------------------------------------------

  inline DrawingClassificationMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  DrawingClassificationMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DrawingClassificationMeta& from);
  void MergeFrom(const DrawingClassificationMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DrawingClassificationMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string labels = 1;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 1;
  const ::std::string& labels(int index) const;
  ::std::string* mutable_labels(int index);
  void set_labels(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_labels(int index, ::std::string&& value);
  #endif
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  ::std::string* add_labels();
  void add_labels(const ::std::string& value);
  #if LANG_CXX11
  void add_labels(::std::string&& value);
  #endif
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& labels() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_labels();

  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.DrawingClassificationMeta)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> labels_;
  mutable int _cached_size_;
  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageClassificationMeta : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.ImageClassificationMeta) */ {
 public:
  ImageClassificationMeta();
  virtual ~ImageClassificationMeta();

  ImageClassificationMeta(const ImageClassificationMeta& from);

  inline ImageClassificationMeta& operator=(const ImageClassificationMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const ImageClassificationMeta& default_instance();

  static inline const ImageClassificationMeta* internal_default_instance() {
    return reinterpret_cast<const ImageClassificationMeta*>(
               &_ImageClassificationMeta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ImageClassificationMeta* other);

  // implements Message ----------------------------------------------

  inline ImageClassificationMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageClassificationMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ImageClassificationMeta& from);
  void MergeFrom(const ImageClassificationMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageClassificationMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string labels = 1;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 1;
  const ::std::string& labels(int index) const;
  ::std::string* mutable_labels(int index);
  void set_labels(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_labels(int index, ::std::string&& value);
  #endif
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  ::std::string* add_labels();
  void add_labels(const ::std::string& value);
  #if LANG_CXX11
  void add_labels(::std::string&& value);
  #endif
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& labels() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_labels();

  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.ImageClassificationMeta)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> labels_;
  mutable int _cached_size_;
  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObjectDetectionMeta : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.ObjectDetectionMeta) */ {
 public:
  ObjectDetectionMeta();
  virtual ~ObjectDetectionMeta();

  ObjectDetectionMeta(const ObjectDetectionMeta& from);

  inline ObjectDetectionMeta& operator=(const ObjectDetectionMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const ObjectDetectionMeta& default_instance();

  static inline const ObjectDetectionMeta* internal_default_instance() {
    return reinterpret_cast<const ObjectDetectionMeta*>(
               &_ObjectDetectionMeta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ObjectDetectionMeta* other);

  // implements Message ----------------------------------------------

  inline ObjectDetectionMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  ObjectDetectionMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ObjectDetectionMeta& from);
  void MergeFrom(const ObjectDetectionMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObjectDetectionMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string labels = 1;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 1;
  const ::std::string& labels(int index) const;
  ::std::string* mutable_labels(int index);
  void set_labels(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_labels(int index, ::std::string&& value);
  #endif
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  ::std::string* add_labels();
  void add_labels(const ::std::string& value);
  #if LANG_CXX11
  void add_labels(::std::string&& value);
  #endif
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& labels() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_labels();

  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.ObjectDetectionMeta)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> labels_;
  mutable int _cached_size_;
  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MetaData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.MetaData) */ {
 public:
  MetaData();
  virtual ~MetaData();

  MetaData(const MetaData& from);

  inline MetaData& operator=(const MetaData& from) {
    CopyFrom(from);
    return *this;
  }

  static const MetaData& default_instance();

  enum TypeCase {
    kActivityClassification = 100,
    kAudioClassification = 101,
    kDrawingClassification = 102,
    kImageClassification = 103,
    kObjectDetection = 104,
    TYPE_NOT_SET = 0,
  };

  static inline const MetaData* internal_default_instance() {
    return reinterpret_cast<const MetaData*>(
               &_MetaData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(MetaData* other);

  // implements Message ----------------------------------------------

  inline MetaData* New() const PROTOBUF_FINAL { return New(NULL); }

  MetaData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MetaData& from);
  void MergeFrom(const MetaData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetaData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 num_examples = 1;
  void clear_num_examples();
  static const int kNumExamplesFieldNumber = 1;
  ::google::protobuf::int64 num_examples() const;
  void set_num_examples(::google::protobuf::int64 value);

  // .TuriCreate.Annotation.Specification.ActivityClassificationMeta activity_classification = 100;
  bool has_activity_classification() const;
  void clear_activity_classification();
  static const int kActivityClassificationFieldNumber = 100;
  const ::TuriCreate::Annotation::Specification::ActivityClassificationMeta& activity_classification() const;
  ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* mutable_activity_classification();
  ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* release_activity_classification();
  void set_allocated_activity_classification(::TuriCreate::Annotation::Specification::ActivityClassificationMeta* activity_classification);

  // .TuriCreate.Annotation.Specification.AudioClassificationMeta audio_classification = 101;
  bool has_audio_classification() const;
  void clear_audio_classification();
  static const int kAudioClassificationFieldNumber = 101;
  const ::TuriCreate::Annotation::Specification::AudioClassificationMeta& audio_classification() const;
  ::TuriCreate::Annotation::Specification::AudioClassificationMeta* mutable_audio_classification();
  ::TuriCreate::Annotation::Specification::AudioClassificationMeta* release_audio_classification();
  void set_allocated_audio_classification(::TuriCreate::Annotation::Specification::AudioClassificationMeta* audio_classification);

  // .TuriCreate.Annotation.Specification.DrawingClassificationMeta drawing_classification = 102;
  bool has_drawing_classification() const;
  void clear_drawing_classification();
  static const int kDrawingClassificationFieldNumber = 102;
  const ::TuriCreate::Annotation::Specification::DrawingClassificationMeta& drawing_classification() const;
  ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* mutable_drawing_classification();
  ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* release_drawing_classification();
  void set_allocated_drawing_classification(::TuriCreate::Annotation::Specification::DrawingClassificationMeta* drawing_classification);

  // .TuriCreate.Annotation.Specification.ImageClassificationMeta image_classification = 103;
  bool has_image_classification() const;
  void clear_image_classification();
  static const int kImageClassificationFieldNumber = 103;
  const ::TuriCreate::Annotation::Specification::ImageClassificationMeta& image_classification() const;
  ::TuriCreate::Annotation::Specification::ImageClassificationMeta* mutable_image_classification();
  ::TuriCreate::Annotation::Specification::ImageClassificationMeta* release_image_classification();
  void set_allocated_image_classification(::TuriCreate::Annotation::Specification::ImageClassificationMeta* image_classification);

  // .TuriCreate.Annotation.Specification.ObjectDetectionMeta object_detection = 104;
  bool has_object_detection() const;
  void clear_object_detection();
  static const int kObjectDetectionFieldNumber = 104;
  const ::TuriCreate::Annotation::Specification::ObjectDetectionMeta& object_detection() const;
  ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* mutable_object_detection();
  ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* release_object_detection();
  void set_allocated_object_detection(::TuriCreate::Annotation::Specification::ObjectDetectionMeta* object_detection);

  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.MetaData)
 private:
  void set_has_activity_classification();
  void set_has_audio_classification();
  void set_has_drawing_classification();
  void set_has_image_classification();
  void set_has_object_detection();

  inline bool has_Type() const;
  void clear_Type();
  inline void clear_has_Type();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 num_examples_;
  union TypeUnion {
    TypeUnion() {}
    ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* activity_classification_;
    ::TuriCreate::Annotation::Specification::AudioClassificationMeta* audio_classification_;
    ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* drawing_classification_;
    ::TuriCreate::Annotation::Specification::ImageClassificationMeta* image_classification_;
    ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* object_detection_;
  } Type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_meta_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ActivityClassificationMeta

// repeated string labels = 1;
inline int ActivityClassificationMeta::labels_size() const {
  return labels_.size();
}
inline void ActivityClassificationMeta::clear_labels() {
  labels_.Clear();
}
inline const ::std::string& ActivityClassificationMeta::labels(int index) const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
  return labels_.Get(index);
}
inline ::std::string* ActivityClassificationMeta::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
  return labels_.Mutable(index);
}
inline void ActivityClassificationMeta::set_labels(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
  labels_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ActivityClassificationMeta::set_labels(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
  labels_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ActivityClassificationMeta::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
}
inline void ActivityClassificationMeta::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
}
inline ::std::string* ActivityClassificationMeta::add_labels() {
  // @@protoc_insertion_point(field_add_mutable:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
  return labels_.Add();
}
inline void ActivityClassificationMeta::add_labels(const ::std::string& value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
}
#if LANG_CXX11
inline void ActivityClassificationMeta::add_labels(::std::string&& value) {
  labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
}
#endif
inline void ActivityClassificationMeta::add_labels(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
}
inline void ActivityClassificationMeta::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ActivityClassificationMeta::labels() const {
  // @@protoc_insertion_point(field_list:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ActivityClassificationMeta::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:TuriCreate.Annotation.Specification.ActivityClassificationMeta.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// AudioClassificationMeta

// repeated string labels = 1;
inline int AudioClassificationMeta::labels_size() const {
  return labels_.size();
}
inline void AudioClassificationMeta::clear_labels() {
  labels_.Clear();
}
inline const ::std::string& AudioClassificationMeta::labels(int index) const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
  return labels_.Get(index);
}
inline ::std::string* AudioClassificationMeta::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
  return labels_.Mutable(index);
}
inline void AudioClassificationMeta::set_labels(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
  labels_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AudioClassificationMeta::set_labels(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
  labels_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AudioClassificationMeta::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
}
inline void AudioClassificationMeta::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
}
inline ::std::string* AudioClassificationMeta::add_labels() {
  // @@protoc_insertion_point(field_add_mutable:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
  return labels_.Add();
}
inline void AudioClassificationMeta::add_labels(const ::std::string& value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
}
#if LANG_CXX11
inline void AudioClassificationMeta::add_labels(::std::string&& value) {
  labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
}
#endif
inline void AudioClassificationMeta::add_labels(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
}
inline void AudioClassificationMeta::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AudioClassificationMeta::labels() const {
  // @@protoc_insertion_point(field_list:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AudioClassificationMeta::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:TuriCreate.Annotation.Specification.AudioClassificationMeta.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// DrawingClassificationMeta

// repeated string labels = 1;
inline int DrawingClassificationMeta::labels_size() const {
  return labels_.size();
}
inline void DrawingClassificationMeta::clear_labels() {
  labels_.Clear();
}
inline const ::std::string& DrawingClassificationMeta::labels(int index) const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
  return labels_.Get(index);
}
inline ::std::string* DrawingClassificationMeta::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
  return labels_.Mutable(index);
}
inline void DrawingClassificationMeta::set_labels(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
  labels_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DrawingClassificationMeta::set_labels(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
  labels_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DrawingClassificationMeta::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
}
inline void DrawingClassificationMeta::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
}
inline ::std::string* DrawingClassificationMeta::add_labels() {
  // @@protoc_insertion_point(field_add_mutable:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
  return labels_.Add();
}
inline void DrawingClassificationMeta::add_labels(const ::std::string& value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
}
#if LANG_CXX11
inline void DrawingClassificationMeta::add_labels(::std::string&& value) {
  labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
}
#endif
inline void DrawingClassificationMeta::add_labels(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
}
inline void DrawingClassificationMeta::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DrawingClassificationMeta::labels() const {
  // @@protoc_insertion_point(field_list:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DrawingClassificationMeta::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:TuriCreate.Annotation.Specification.DrawingClassificationMeta.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// ImageClassificationMeta

// repeated string labels = 1;
inline int ImageClassificationMeta::labels_size() const {
  return labels_.size();
}
inline void ImageClassificationMeta::clear_labels() {
  labels_.Clear();
}
inline const ::std::string& ImageClassificationMeta::labels(int index) const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
  return labels_.Get(index);
}
inline ::std::string* ImageClassificationMeta::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
  return labels_.Mutable(index);
}
inline void ImageClassificationMeta::set_labels(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
  labels_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ImageClassificationMeta::set_labels(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
  labels_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ImageClassificationMeta::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
}
inline void ImageClassificationMeta::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
}
inline ::std::string* ImageClassificationMeta::add_labels() {
  // @@protoc_insertion_point(field_add_mutable:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
  return labels_.Add();
}
inline void ImageClassificationMeta::add_labels(const ::std::string& value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
}
#if LANG_CXX11
inline void ImageClassificationMeta::add_labels(::std::string&& value) {
  labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
}
#endif
inline void ImageClassificationMeta::add_labels(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
}
inline void ImageClassificationMeta::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImageClassificationMeta::labels() const {
  // @@protoc_insertion_point(field_list:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImageClassificationMeta::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:TuriCreate.Annotation.Specification.ImageClassificationMeta.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// ObjectDetectionMeta

// repeated string labels = 1;
inline int ObjectDetectionMeta::labels_size() const {
  return labels_.size();
}
inline void ObjectDetectionMeta::clear_labels() {
  labels_.Clear();
}
inline const ::std::string& ObjectDetectionMeta::labels(int index) const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
  return labels_.Get(index);
}
inline ::std::string* ObjectDetectionMeta::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
  return labels_.Mutable(index);
}
inline void ObjectDetectionMeta::set_labels(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
  labels_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ObjectDetectionMeta::set_labels(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
  labels_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ObjectDetectionMeta::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
}
inline void ObjectDetectionMeta::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
}
inline ::std::string* ObjectDetectionMeta::add_labels() {
  // @@protoc_insertion_point(field_add_mutable:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
  return labels_.Add();
}
inline void ObjectDetectionMeta::add_labels(const ::std::string& value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
}
#if LANG_CXX11
inline void ObjectDetectionMeta::add_labels(::std::string&& value) {
  labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
}
#endif
inline void ObjectDetectionMeta::add_labels(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
}
inline void ObjectDetectionMeta::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ObjectDetectionMeta::labels() const {
  // @@protoc_insertion_point(field_list:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ObjectDetectionMeta::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:TuriCreate.Annotation.Specification.ObjectDetectionMeta.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// MetaData

// int64 num_examples = 1;
inline void MetaData::clear_num_examples() {
  num_examples_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MetaData::num_examples() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.num_examples)
  return num_examples_;
}
inline void MetaData::set_num_examples(::google::protobuf::int64 value) {
  
  num_examples_ = value;
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.MetaData.num_examples)
}

// .TuriCreate.Annotation.Specification.ActivityClassificationMeta activity_classification = 100;
inline bool MetaData::has_activity_classification() const {
  return Type_case() == kActivityClassification;
}
inline void MetaData::set_has_activity_classification() {
  _oneof_case_[0] = kActivityClassification;
}
inline void MetaData::clear_activity_classification() {
  if (has_activity_classification()) {
    delete Type_.activity_classification_;
    clear_has_Type();
  }
}
inline  const ::TuriCreate::Annotation::Specification::ActivityClassificationMeta& MetaData::activity_classification() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.activity_classification)
  return has_activity_classification()
      ? *Type_.activity_classification_
      : ::TuriCreate::Annotation::Specification::ActivityClassificationMeta::default_instance();
}
inline ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* MetaData::mutable_activity_classification() {
  if (!has_activity_classification()) {
    clear_Type();
    set_has_activity_classification();
    Type_.activity_classification_ = new ::TuriCreate::Annotation::Specification::ActivityClassificationMeta;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.MetaData.activity_classification)
  return Type_.activity_classification_;
}
inline ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* MetaData::release_activity_classification() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.MetaData.activity_classification)
  if (has_activity_classification()) {
    clear_has_Type();
    ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* temp = Type_.activity_classification_;
    Type_.activity_classification_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MetaData::set_allocated_activity_classification(::TuriCreate::Annotation::Specification::ActivityClassificationMeta* activity_classification) {
  clear_Type();
  if (activity_classification) {
    set_has_activity_classification();
    Type_.activity_classification_ = activity_classification;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.MetaData.activity_classification)
}

// .TuriCreate.Annotation.Specification.AudioClassificationMeta audio_classification = 101;
inline bool MetaData::has_audio_classification() const {
  return Type_case() == kAudioClassification;
}
inline void MetaData::set_has_audio_classification() {
  _oneof_case_[0] = kAudioClassification;
}
inline void MetaData::clear_audio_classification() {
  if (has_audio_classification()) {
    delete Type_.audio_classification_;
    clear_has_Type();
  }
}
inline  const ::TuriCreate::Annotation::Specification::AudioClassificationMeta& MetaData::audio_classification() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.audio_classification)
  return has_audio_classification()
      ? *Type_.audio_classification_
      : ::TuriCreate::Annotation::Specification::AudioClassificationMeta::default_instance();
}
inline ::TuriCreate::Annotation::Specification::AudioClassificationMeta* MetaData::mutable_audio_classification() {
  if (!has_audio_classification()) {
    clear_Type();
    set_has_audio_classification();
    Type_.audio_classification_ = new ::TuriCreate::Annotation::Specification::AudioClassificationMeta;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.MetaData.audio_classification)
  return Type_.audio_classification_;
}
inline ::TuriCreate::Annotation::Specification::AudioClassificationMeta* MetaData::release_audio_classification() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.MetaData.audio_classification)
  if (has_audio_classification()) {
    clear_has_Type();
    ::TuriCreate::Annotation::Specification::AudioClassificationMeta* temp = Type_.audio_classification_;
    Type_.audio_classification_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MetaData::set_allocated_audio_classification(::TuriCreate::Annotation::Specification::AudioClassificationMeta* audio_classification) {
  clear_Type();
  if (audio_classification) {
    set_has_audio_classification();
    Type_.audio_classification_ = audio_classification;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.MetaData.audio_classification)
}

// .TuriCreate.Annotation.Specification.DrawingClassificationMeta drawing_classification = 102;
inline bool MetaData::has_drawing_classification() const {
  return Type_case() == kDrawingClassification;
}
inline void MetaData::set_has_drawing_classification() {
  _oneof_case_[0] = kDrawingClassification;
}
inline void MetaData::clear_drawing_classification() {
  if (has_drawing_classification()) {
    delete Type_.drawing_classification_;
    clear_has_Type();
  }
}
inline  const ::TuriCreate::Annotation::Specification::DrawingClassificationMeta& MetaData::drawing_classification() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.drawing_classification)
  return has_drawing_classification()
      ? *Type_.drawing_classification_
      : ::TuriCreate::Annotation::Specification::DrawingClassificationMeta::default_instance();
}
inline ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* MetaData::mutable_drawing_classification() {
  if (!has_drawing_classification()) {
    clear_Type();
    set_has_drawing_classification();
    Type_.drawing_classification_ = new ::TuriCreate::Annotation::Specification::DrawingClassificationMeta;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.MetaData.drawing_classification)
  return Type_.drawing_classification_;
}
inline ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* MetaData::release_drawing_classification() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.MetaData.drawing_classification)
  if (has_drawing_classification()) {
    clear_has_Type();
    ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* temp = Type_.drawing_classification_;
    Type_.drawing_classification_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MetaData::set_allocated_drawing_classification(::TuriCreate::Annotation::Specification::DrawingClassificationMeta* drawing_classification) {
  clear_Type();
  if (drawing_classification) {
    set_has_drawing_classification();
    Type_.drawing_classification_ = drawing_classification;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.MetaData.drawing_classification)
}

// .TuriCreate.Annotation.Specification.ImageClassificationMeta image_classification = 103;
inline bool MetaData::has_image_classification() const {
  return Type_case() == kImageClassification;
}
inline void MetaData::set_has_image_classification() {
  _oneof_case_[0] = kImageClassification;
}
inline void MetaData::clear_image_classification() {
  if (has_image_classification()) {
    delete Type_.image_classification_;
    clear_has_Type();
  }
}
inline  const ::TuriCreate::Annotation::Specification::ImageClassificationMeta& MetaData::image_classification() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.image_classification)
  return has_image_classification()
      ? *Type_.image_classification_
      : ::TuriCreate::Annotation::Specification::ImageClassificationMeta::default_instance();
}
inline ::TuriCreate::Annotation::Specification::ImageClassificationMeta* MetaData::mutable_image_classification() {
  if (!has_image_classification()) {
    clear_Type();
    set_has_image_classification();
    Type_.image_classification_ = new ::TuriCreate::Annotation::Specification::ImageClassificationMeta;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.MetaData.image_classification)
  return Type_.image_classification_;
}
inline ::TuriCreate::Annotation::Specification::ImageClassificationMeta* MetaData::release_image_classification() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.MetaData.image_classification)
  if (has_image_classification()) {
    clear_has_Type();
    ::TuriCreate::Annotation::Specification::ImageClassificationMeta* temp = Type_.image_classification_;
    Type_.image_classification_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MetaData::set_allocated_image_classification(::TuriCreate::Annotation::Specification::ImageClassificationMeta* image_classification) {
  clear_Type();
  if (image_classification) {
    set_has_image_classification();
    Type_.image_classification_ = image_classification;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.MetaData.image_classification)
}

// .TuriCreate.Annotation.Specification.ObjectDetectionMeta object_detection = 104;
inline bool MetaData::has_object_detection() const {
  return Type_case() == kObjectDetection;
}
inline void MetaData::set_has_object_detection() {
  _oneof_case_[0] = kObjectDetection;
}
inline void MetaData::clear_object_detection() {
  if (has_object_detection()) {
    delete Type_.object_detection_;
    clear_has_Type();
  }
}
inline  const ::TuriCreate::Annotation::Specification::ObjectDetectionMeta& MetaData::object_detection() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.object_detection)
  return has_object_detection()
      ? *Type_.object_detection_
      : ::TuriCreate::Annotation::Specification::ObjectDetectionMeta::default_instance();
}
inline ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* MetaData::mutable_object_detection() {
  if (!has_object_detection()) {
    clear_Type();
    set_has_object_detection();
    Type_.object_detection_ = new ::TuriCreate::Annotation::Specification::ObjectDetectionMeta;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.MetaData.object_detection)
  return Type_.object_detection_;
}
inline ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* MetaData::release_object_detection() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.MetaData.object_detection)
  if (has_object_detection()) {
    clear_has_Type();
    ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* temp = Type_.object_detection_;
    Type_.object_detection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MetaData::set_allocated_object_detection(::TuriCreate::Annotation::Specification::ObjectDetectionMeta* object_detection) {
  clear_Type();
  if (object_detection) {
    set_has_object_detection();
    Type_.object_detection_ = object_detection;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.MetaData.object_detection)
}

inline bool MetaData::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void MetaData::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline MetaData::TypeCase MetaData::Type_case() const {
  return MetaData::TypeCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace Specification
}  // namespace Annotation
}  // namespace TuriCreate

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_meta_2eproto__INCLUDED
