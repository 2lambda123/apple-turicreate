// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meta.proto

#ifndef PROTOBUF_meta_2eproto__INCLUDED
#define PROTOBUF_meta_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
namespace TuriCreate {
namespace Annotation {
namespace Specification {
class ActivityClassificationMeta;
class ActivityClassificationMetaDefaultTypeInternal;
extern ActivityClassificationMetaDefaultTypeInternal _ActivityClassificationMeta_default_instance_;
class AudioClassificationMeta;
class AudioClassificationMetaDefaultTypeInternal;
extern AudioClassificationMetaDefaultTypeInternal _AudioClassificationMeta_default_instance_;
class DrawingClassificationMeta;
class DrawingClassificationMetaDefaultTypeInternal;
extern DrawingClassificationMetaDefaultTypeInternal _DrawingClassificationMeta_default_instance_;
class ImageClassificationMeta;
class ImageClassificationMetaDefaultTypeInternal;
extern ImageClassificationMetaDefaultTypeInternal _ImageClassificationMeta_default_instance_;
class MetaData;
class MetaDataDefaultTypeInternal;
extern MetaDataDefaultTypeInternal _MetaData_default_instance_;
class MetaInteger;
class MetaIntegerDefaultTypeInternal;
extern MetaIntegerDefaultTypeInternal _MetaInteger_default_instance_;
class MetaString;
class MetaStringDefaultTypeInternal;
extern MetaStringDefaultTypeInternal _MetaString_default_instance_;
class ObjectDetectionMeta;
class ObjectDetectionMetaDefaultTypeInternal;
extern ObjectDetectionMetaDefaultTypeInternal _ObjectDetectionMeta_default_instance_;
}  // namespace Specification
}  // namespace Annotation
}  // namespace TuriCreate

namespace TuriCreate {
namespace Annotation {
namespace Specification {

namespace protobuf_meta_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_meta_2eproto

// ===================================================================

class MetaString : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.MetaString) */ {
 public:
  MetaString();
  virtual ~MetaString();

  MetaString(const MetaString& from);

  inline MetaString& operator=(const MetaString& from) {
    CopyFrom(from);
    return *this;
  }

  static const MetaString& default_instance();

  static inline const MetaString* internal_default_instance() {
    return reinterpret_cast<const MetaString*>(
               &_MetaString_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MetaString* other);

  // implements Message ----------------------------------------------

  inline MetaString* New() const PROTOBUF_FINAL { return New(NULL); }

  MetaString* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MetaString& from);
  void MergeFrom(const MetaString& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetaString* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string labels = 1;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 1;
  const ::std::string& labels(int index) const;
  ::std::string* mutable_labels(int index);
  void set_labels(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_labels(int index, ::std::string&& value);
  #endif
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  ::std::string* add_labels();
  void add_labels(const ::std::string& value);
  #if LANG_CXX11
  void add_labels(::std::string&& value);
  #endif
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& labels() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_labels();

  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.MetaString)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> labels_;
  mutable int _cached_size_;
  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MetaInteger : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.MetaInteger) */ {
 public:
  MetaInteger();
  virtual ~MetaInteger();

  MetaInteger(const MetaInteger& from);

  inline MetaInteger& operator=(const MetaInteger& from) {
    CopyFrom(from);
    return *this;
  }

  static const MetaInteger& default_instance();

  static inline const MetaInteger* internal_default_instance() {
    return reinterpret_cast<const MetaInteger*>(
               &_MetaInteger_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MetaInteger* other);

  // implements Message ----------------------------------------------

  inline MetaInteger* New() const PROTOBUF_FINAL { return New(NULL); }

  MetaInteger* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MetaInteger& from);
  void MergeFrom(const MetaInteger& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetaInteger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 labels = 1;
  int labels_size() const;
  void clear_labels();
  static const int kLabelsFieldNumber = 1;
  ::google::protobuf::int64 labels(int index) const;
  void set_labels(int index, ::google::protobuf::int64 value);
  void add_labels(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      labels() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_labels();

  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.MetaInteger)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > labels_;
  mutable int _labels_cached_byte_size_;
  mutable int _cached_size_;
  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActivityClassificationMeta : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.ActivityClassificationMeta) */ {
 public:
  ActivityClassificationMeta();
  virtual ~ActivityClassificationMeta();

  ActivityClassificationMeta(const ActivityClassificationMeta& from);

  inline ActivityClassificationMeta& operator=(const ActivityClassificationMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityClassificationMeta& default_instance();

  enum LabelCase {
    kStrings = 1,
    kIntegers = 2,
    LABEL_NOT_SET = 0,
  };

  static inline const ActivityClassificationMeta* internal_default_instance() {
    return reinterpret_cast<const ActivityClassificationMeta*>(
               &_ActivityClassificationMeta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ActivityClassificationMeta* other);

  // implements Message ----------------------------------------------

  inline ActivityClassificationMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  ActivityClassificationMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ActivityClassificationMeta& from);
  void MergeFrom(const ActivityClassificationMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivityClassificationMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TuriCreate.Annotation.Specification.MetaString strings = 1;
  bool has_strings() const;
  void clear_strings();
  static const int kStringsFieldNumber = 1;
  const ::TuriCreate::Annotation::Specification::MetaString& strings() const;
  ::TuriCreate::Annotation::Specification::MetaString* mutable_strings();
  ::TuriCreate::Annotation::Specification::MetaString* release_strings();
  void set_allocated_strings(::TuriCreate::Annotation::Specification::MetaString* strings);

  // .TuriCreate.Annotation.Specification.MetaInteger integers = 2;
  bool has_integers() const;
  void clear_integers();
  static const int kIntegersFieldNumber = 2;
  const ::TuriCreate::Annotation::Specification::MetaInteger& integers() const;
  ::TuriCreate::Annotation::Specification::MetaInteger* mutable_integers();
  ::TuriCreate::Annotation::Specification::MetaInteger* release_integers();
  void set_allocated_integers(::TuriCreate::Annotation::Specification::MetaInteger* integers);

  LabelCase Label_case() const;
  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.ActivityClassificationMeta)
 private:
  void set_has_strings();
  void set_has_integers();

  inline bool has_Label() const;
  void clear_Label();
  inline void clear_has_Label();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union LabelUnion {
    LabelUnion() {}
    ::TuriCreate::Annotation::Specification::MetaString* strings_;
    ::TuriCreate::Annotation::Specification::MetaInteger* integers_;
  } Label_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AudioClassificationMeta : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.AudioClassificationMeta) */ {
 public:
  AudioClassificationMeta();
  virtual ~AudioClassificationMeta();

  AudioClassificationMeta(const AudioClassificationMeta& from);

  inline AudioClassificationMeta& operator=(const AudioClassificationMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const AudioClassificationMeta& default_instance();

  enum LabelCase {
    kStrings = 1,
    kIntegers = 2,
    LABEL_NOT_SET = 0,
  };

  static inline const AudioClassificationMeta* internal_default_instance() {
    return reinterpret_cast<const AudioClassificationMeta*>(
               &_AudioClassificationMeta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AudioClassificationMeta* other);

  // implements Message ----------------------------------------------

  inline AudioClassificationMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  AudioClassificationMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AudioClassificationMeta& from);
  void MergeFrom(const AudioClassificationMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioClassificationMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TuriCreate.Annotation.Specification.MetaString strings = 1;
  bool has_strings() const;
  void clear_strings();
  static const int kStringsFieldNumber = 1;
  const ::TuriCreate::Annotation::Specification::MetaString& strings() const;
  ::TuriCreate::Annotation::Specification::MetaString* mutable_strings();
  ::TuriCreate::Annotation::Specification::MetaString* release_strings();
  void set_allocated_strings(::TuriCreate::Annotation::Specification::MetaString* strings);

  // .TuriCreate.Annotation.Specification.MetaInteger integers = 2;
  bool has_integers() const;
  void clear_integers();
  static const int kIntegersFieldNumber = 2;
  const ::TuriCreate::Annotation::Specification::MetaInteger& integers() const;
  ::TuriCreate::Annotation::Specification::MetaInteger* mutable_integers();
  ::TuriCreate::Annotation::Specification::MetaInteger* release_integers();
  void set_allocated_integers(::TuriCreate::Annotation::Specification::MetaInteger* integers);

  LabelCase Label_case() const;
  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.AudioClassificationMeta)
 private:
  void set_has_strings();
  void set_has_integers();

  inline bool has_Label() const;
  void clear_Label();
  inline void clear_has_Label();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union LabelUnion {
    LabelUnion() {}
    ::TuriCreate::Annotation::Specification::MetaString* strings_;
    ::TuriCreate::Annotation::Specification::MetaInteger* integers_;
  } Label_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DrawingClassificationMeta : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.DrawingClassificationMeta) */ {
 public:
  DrawingClassificationMeta();
  virtual ~DrawingClassificationMeta();

  DrawingClassificationMeta(const DrawingClassificationMeta& from);

  inline DrawingClassificationMeta& operator=(const DrawingClassificationMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const DrawingClassificationMeta& default_instance();

  enum LabelCase {
    kStrings = 1,
    kIntegers = 2,
    LABEL_NOT_SET = 0,
  };

  static inline const DrawingClassificationMeta* internal_default_instance() {
    return reinterpret_cast<const DrawingClassificationMeta*>(
               &_DrawingClassificationMeta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DrawingClassificationMeta* other);

  // implements Message ----------------------------------------------

  inline DrawingClassificationMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  DrawingClassificationMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DrawingClassificationMeta& from);
  void MergeFrom(const DrawingClassificationMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DrawingClassificationMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TuriCreate.Annotation.Specification.MetaString strings = 1;
  bool has_strings() const;
  void clear_strings();
  static const int kStringsFieldNumber = 1;
  const ::TuriCreate::Annotation::Specification::MetaString& strings() const;
  ::TuriCreate::Annotation::Specification::MetaString* mutable_strings();
  ::TuriCreate::Annotation::Specification::MetaString* release_strings();
  void set_allocated_strings(::TuriCreate::Annotation::Specification::MetaString* strings);

  // .TuriCreate.Annotation.Specification.MetaInteger integers = 2;
  bool has_integers() const;
  void clear_integers();
  static const int kIntegersFieldNumber = 2;
  const ::TuriCreate::Annotation::Specification::MetaInteger& integers() const;
  ::TuriCreate::Annotation::Specification::MetaInteger* mutable_integers();
  ::TuriCreate::Annotation::Specification::MetaInteger* release_integers();
  void set_allocated_integers(::TuriCreate::Annotation::Specification::MetaInteger* integers);

  LabelCase Label_case() const;
  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.DrawingClassificationMeta)
 private:
  void set_has_strings();
  void set_has_integers();

  inline bool has_Label() const;
  void clear_Label();
  inline void clear_has_Label();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union LabelUnion {
    LabelUnion() {}
    ::TuriCreate::Annotation::Specification::MetaString* strings_;
    ::TuriCreate::Annotation::Specification::MetaInteger* integers_;
  } Label_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageClassificationMeta : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.ImageClassificationMeta) */ {
 public:
  ImageClassificationMeta();
  virtual ~ImageClassificationMeta();

  ImageClassificationMeta(const ImageClassificationMeta& from);

  inline ImageClassificationMeta& operator=(const ImageClassificationMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const ImageClassificationMeta& default_instance();

  enum LabelCase {
    kStrings = 1,
    kIntegers = 2,
    LABEL_NOT_SET = 0,
  };

  static inline const ImageClassificationMeta* internal_default_instance() {
    return reinterpret_cast<const ImageClassificationMeta*>(
               &_ImageClassificationMeta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ImageClassificationMeta* other);

  // implements Message ----------------------------------------------

  inline ImageClassificationMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageClassificationMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ImageClassificationMeta& from);
  void MergeFrom(const ImageClassificationMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageClassificationMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TuriCreate.Annotation.Specification.MetaString strings = 1;
  bool has_strings() const;
  void clear_strings();
  static const int kStringsFieldNumber = 1;
  const ::TuriCreate::Annotation::Specification::MetaString& strings() const;
  ::TuriCreate::Annotation::Specification::MetaString* mutable_strings();
  ::TuriCreate::Annotation::Specification::MetaString* release_strings();
  void set_allocated_strings(::TuriCreate::Annotation::Specification::MetaString* strings);

  // .TuriCreate.Annotation.Specification.MetaInteger integers = 2;
  bool has_integers() const;
  void clear_integers();
  static const int kIntegersFieldNumber = 2;
  const ::TuriCreate::Annotation::Specification::MetaInteger& integers() const;
  ::TuriCreate::Annotation::Specification::MetaInteger* mutable_integers();
  ::TuriCreate::Annotation::Specification::MetaInteger* release_integers();
  void set_allocated_integers(::TuriCreate::Annotation::Specification::MetaInteger* integers);

  LabelCase Label_case() const;
  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.ImageClassificationMeta)
 private:
  void set_has_strings();
  void set_has_integers();

  inline bool has_Label() const;
  void clear_Label();
  inline void clear_has_Label();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union LabelUnion {
    LabelUnion() {}
    ::TuriCreate::Annotation::Specification::MetaString* strings_;
    ::TuriCreate::Annotation::Specification::MetaInteger* integers_;
  } Label_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObjectDetectionMeta : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.ObjectDetectionMeta) */ {
 public:
  ObjectDetectionMeta();
  virtual ~ObjectDetectionMeta();

  ObjectDetectionMeta(const ObjectDetectionMeta& from);

  inline ObjectDetectionMeta& operator=(const ObjectDetectionMeta& from) {
    CopyFrom(from);
    return *this;
  }

  static const ObjectDetectionMeta& default_instance();

  enum LabelCase {
    kStrings = 1,
    kIntegers = 2,
    LABEL_NOT_SET = 0,
  };

  static inline const ObjectDetectionMeta* internal_default_instance() {
    return reinterpret_cast<const ObjectDetectionMeta*>(
               &_ObjectDetectionMeta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ObjectDetectionMeta* other);

  // implements Message ----------------------------------------------

  inline ObjectDetectionMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  ObjectDetectionMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ObjectDetectionMeta& from);
  void MergeFrom(const ObjectDetectionMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObjectDetectionMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TuriCreate.Annotation.Specification.MetaString strings = 1;
  bool has_strings() const;
  void clear_strings();
  static const int kStringsFieldNumber = 1;
  const ::TuriCreate::Annotation::Specification::MetaString& strings() const;
  ::TuriCreate::Annotation::Specification::MetaString* mutable_strings();
  ::TuriCreate::Annotation::Specification::MetaString* release_strings();
  void set_allocated_strings(::TuriCreate::Annotation::Specification::MetaString* strings);

  // .TuriCreate.Annotation.Specification.MetaInteger integers = 2;
  bool has_integers() const;
  void clear_integers();
  static const int kIntegersFieldNumber = 2;
  const ::TuriCreate::Annotation::Specification::MetaInteger& integers() const;
  ::TuriCreate::Annotation::Specification::MetaInteger* mutable_integers();
  ::TuriCreate::Annotation::Specification::MetaInteger* release_integers();
  void set_allocated_integers(::TuriCreate::Annotation::Specification::MetaInteger* integers);

  LabelCase Label_case() const;
  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.ObjectDetectionMeta)
 private:
  void set_has_strings();
  void set_has_integers();

  inline bool has_Label() const;
  void clear_Label();
  inline void clear_has_Label();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  union LabelUnion {
    LabelUnion() {}
    ::TuriCreate::Annotation::Specification::MetaString* strings_;
    ::TuriCreate::Annotation::Specification::MetaInteger* integers_;
  } Label_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_meta_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MetaData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:TuriCreate.Annotation.Specification.MetaData) */ {
 public:
  MetaData();
  virtual ~MetaData();

  MetaData(const MetaData& from);

  inline MetaData& operator=(const MetaData& from) {
    CopyFrom(from);
    return *this;
  }

  static const MetaData& default_instance();

  enum TypeCase {
    kActivityClassification = 100,
    kAudioClassification = 101,
    kDrawingClassification = 102,
    kImageClassification = 103,
    kObjectDetection = 104,
    TYPE_NOT_SET = 0,
  };

  static inline const MetaData* internal_default_instance() {
    return reinterpret_cast<const MetaData*>(
               &_MetaData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(MetaData* other);

  // implements Message ----------------------------------------------

  inline MetaData* New() const PROTOBUF_FINAL { return New(NULL); }

  MetaData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MetaData& from);
  void MergeFrom(const MetaData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetaData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 num_examples = 1;
  void clear_num_examples();
  static const int kNumExamplesFieldNumber = 1;
  ::google::protobuf::int64 num_examples() const;
  void set_num_examples(::google::protobuf::int64 value);

  // .TuriCreate.Annotation.Specification.ActivityClassificationMeta activity_classification = 100;
  bool has_activity_classification() const;
  void clear_activity_classification();
  static const int kActivityClassificationFieldNumber = 100;
  const ::TuriCreate::Annotation::Specification::ActivityClassificationMeta& activity_classification() const;
  ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* mutable_activity_classification();
  ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* release_activity_classification();
  void set_allocated_activity_classification(::TuriCreate::Annotation::Specification::ActivityClassificationMeta* activity_classification);

  // .TuriCreate.Annotation.Specification.AudioClassificationMeta audio_classification = 101;
  bool has_audio_classification() const;
  void clear_audio_classification();
  static const int kAudioClassificationFieldNumber = 101;
  const ::TuriCreate::Annotation::Specification::AudioClassificationMeta& audio_classification() const;
  ::TuriCreate::Annotation::Specification::AudioClassificationMeta* mutable_audio_classification();
  ::TuriCreate::Annotation::Specification::AudioClassificationMeta* release_audio_classification();
  void set_allocated_audio_classification(::TuriCreate::Annotation::Specification::AudioClassificationMeta* audio_classification);

  // .TuriCreate.Annotation.Specification.DrawingClassificationMeta drawing_classification = 102;
  bool has_drawing_classification() const;
  void clear_drawing_classification();
  static const int kDrawingClassificationFieldNumber = 102;
  const ::TuriCreate::Annotation::Specification::DrawingClassificationMeta& drawing_classification() const;
  ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* mutable_drawing_classification();
  ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* release_drawing_classification();
  void set_allocated_drawing_classification(::TuriCreate::Annotation::Specification::DrawingClassificationMeta* drawing_classification);

  // .TuriCreate.Annotation.Specification.ImageClassificationMeta image_classification = 103;
  bool has_image_classification() const;
  void clear_image_classification();
  static const int kImageClassificationFieldNumber = 103;
  const ::TuriCreate::Annotation::Specification::ImageClassificationMeta& image_classification() const;
  ::TuriCreate::Annotation::Specification::ImageClassificationMeta* mutable_image_classification();
  ::TuriCreate::Annotation::Specification::ImageClassificationMeta* release_image_classification();
  void set_allocated_image_classification(::TuriCreate::Annotation::Specification::ImageClassificationMeta* image_classification);

  // .TuriCreate.Annotation.Specification.ObjectDetectionMeta object_detection = 104;
  bool has_object_detection() const;
  void clear_object_detection();
  static const int kObjectDetectionFieldNumber = 104;
  const ::TuriCreate::Annotation::Specification::ObjectDetectionMeta& object_detection() const;
  ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* mutable_object_detection();
  ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* release_object_detection();
  void set_allocated_object_detection(::TuriCreate::Annotation::Specification::ObjectDetectionMeta* object_detection);

  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:TuriCreate.Annotation.Specification.MetaData)
 private:
  void set_has_activity_classification();
  void set_has_audio_classification();
  void set_has_drawing_classification();
  void set_has_image_classification();
  void set_has_object_detection();

  inline bool has_Type() const;
  void clear_Type();
  inline void clear_has_Type();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 num_examples_;
  union TypeUnion {
    TypeUnion() {}
    ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* activity_classification_;
    ::TuriCreate::Annotation::Specification::AudioClassificationMeta* audio_classification_;
    ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* drawing_classification_;
    ::TuriCreate::Annotation::Specification::ImageClassificationMeta* image_classification_;
    ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* object_detection_;
  } Type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_meta_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// MetaString

// repeated string labels = 1;
inline int MetaString::labels_size() const {
  return labels_.size();
}
inline void MetaString::clear_labels() {
  labels_.Clear();
}
inline const ::std::string& MetaString::labels(int index) const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaString.labels)
  return labels_.Get(index);
}
inline ::std::string* MetaString::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.MetaString.labels)
  return labels_.Mutable(index);
}
inline void MetaString::set_labels(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.MetaString.labels)
  labels_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MetaString::set_labels(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.MetaString.labels)
  labels_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MetaString::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TuriCreate.Annotation.Specification.MetaString.labels)
}
inline void MetaString::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TuriCreate.Annotation.Specification.MetaString.labels)
}
inline ::std::string* MetaString::add_labels() {
  // @@protoc_insertion_point(field_add_mutable:TuriCreate.Annotation.Specification.MetaString.labels)
  return labels_.Add();
}
inline void MetaString::add_labels(const ::std::string& value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.MetaString.labels)
}
#if LANG_CXX11
inline void MetaString::add_labels(::std::string&& value) {
  labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.MetaString.labels)
}
#endif
inline void MetaString::add_labels(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TuriCreate.Annotation.Specification.MetaString.labels)
}
inline void MetaString::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TuriCreate.Annotation.Specification.MetaString.labels)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MetaString::labels() const {
  // @@protoc_insertion_point(field_list:TuriCreate.Annotation.Specification.MetaString.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MetaString::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:TuriCreate.Annotation.Specification.MetaString.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// MetaInteger

// repeated int64 labels = 1;
inline int MetaInteger::labels_size() const {
  return labels_.size();
}
inline void MetaInteger::clear_labels() {
  labels_.Clear();
}
inline ::google::protobuf::int64 MetaInteger::labels(int index) const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaInteger.labels)
  return labels_.Get(index);
}
inline void MetaInteger::set_labels(int index, ::google::protobuf::int64 value) {
  labels_.Set(index, value);
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.MetaInteger.labels)
}
inline void MetaInteger::add_labels(::google::protobuf::int64 value) {
  labels_.Add(value);
  // @@protoc_insertion_point(field_add:TuriCreate.Annotation.Specification.MetaInteger.labels)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
MetaInteger::labels() const {
  // @@protoc_insertion_point(field_list:TuriCreate.Annotation.Specification.MetaInteger.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
MetaInteger::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:TuriCreate.Annotation.Specification.MetaInteger.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// ActivityClassificationMeta

// .TuriCreate.Annotation.Specification.MetaString strings = 1;
inline bool ActivityClassificationMeta::has_strings() const {
  return Label_case() == kStrings;
}
inline void ActivityClassificationMeta::set_has_strings() {
  _oneof_case_[0] = kStrings;
}
inline void ActivityClassificationMeta::clear_strings() {
  if (has_strings()) {
    delete Label_.strings_;
    clear_has_Label();
  }
}
inline  const ::TuriCreate::Annotation::Specification::MetaString& ActivityClassificationMeta::strings() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.ActivityClassificationMeta.strings)
  return has_strings()
      ? *Label_.strings_
      : ::TuriCreate::Annotation::Specification::MetaString::default_instance();
}
inline ::TuriCreate::Annotation::Specification::MetaString* ActivityClassificationMeta::mutable_strings() {
  if (!has_strings()) {
    clear_Label();
    set_has_strings();
    Label_.strings_ = new ::TuriCreate::Annotation::Specification::MetaString;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.ActivityClassificationMeta.strings)
  return Label_.strings_;
}
inline ::TuriCreate::Annotation::Specification::MetaString* ActivityClassificationMeta::release_strings() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.ActivityClassificationMeta.strings)
  if (has_strings()) {
    clear_has_Label();
    ::TuriCreate::Annotation::Specification::MetaString* temp = Label_.strings_;
    Label_.strings_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivityClassificationMeta::set_allocated_strings(::TuriCreate::Annotation::Specification::MetaString* strings) {
  clear_Label();
  if (strings) {
    set_has_strings();
    Label_.strings_ = strings;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.ActivityClassificationMeta.strings)
}

// .TuriCreate.Annotation.Specification.MetaInteger integers = 2;
inline bool ActivityClassificationMeta::has_integers() const {
  return Label_case() == kIntegers;
}
inline void ActivityClassificationMeta::set_has_integers() {
  _oneof_case_[0] = kIntegers;
}
inline void ActivityClassificationMeta::clear_integers() {
  if (has_integers()) {
    delete Label_.integers_;
    clear_has_Label();
  }
}
inline  const ::TuriCreate::Annotation::Specification::MetaInteger& ActivityClassificationMeta::integers() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.ActivityClassificationMeta.integers)
  return has_integers()
      ? *Label_.integers_
      : ::TuriCreate::Annotation::Specification::MetaInteger::default_instance();
}
inline ::TuriCreate::Annotation::Specification::MetaInteger* ActivityClassificationMeta::mutable_integers() {
  if (!has_integers()) {
    clear_Label();
    set_has_integers();
    Label_.integers_ = new ::TuriCreate::Annotation::Specification::MetaInteger;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.ActivityClassificationMeta.integers)
  return Label_.integers_;
}
inline ::TuriCreate::Annotation::Specification::MetaInteger* ActivityClassificationMeta::release_integers() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.ActivityClassificationMeta.integers)
  if (has_integers()) {
    clear_has_Label();
    ::TuriCreate::Annotation::Specification::MetaInteger* temp = Label_.integers_;
    Label_.integers_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ActivityClassificationMeta::set_allocated_integers(::TuriCreate::Annotation::Specification::MetaInteger* integers) {
  clear_Label();
  if (integers) {
    set_has_integers();
    Label_.integers_ = integers;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.ActivityClassificationMeta.integers)
}

inline bool ActivityClassificationMeta::has_Label() const {
  return Label_case() != LABEL_NOT_SET;
}
inline void ActivityClassificationMeta::clear_has_Label() {
  _oneof_case_[0] = LABEL_NOT_SET;
}
inline ActivityClassificationMeta::LabelCase ActivityClassificationMeta::Label_case() const {
  return ActivityClassificationMeta::LabelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AudioClassificationMeta

// .TuriCreate.Annotation.Specification.MetaString strings = 1;
inline bool AudioClassificationMeta::has_strings() const {
  return Label_case() == kStrings;
}
inline void AudioClassificationMeta::set_has_strings() {
  _oneof_case_[0] = kStrings;
}
inline void AudioClassificationMeta::clear_strings() {
  if (has_strings()) {
    delete Label_.strings_;
    clear_has_Label();
  }
}
inline  const ::TuriCreate::Annotation::Specification::MetaString& AudioClassificationMeta::strings() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.AudioClassificationMeta.strings)
  return has_strings()
      ? *Label_.strings_
      : ::TuriCreate::Annotation::Specification::MetaString::default_instance();
}
inline ::TuriCreate::Annotation::Specification::MetaString* AudioClassificationMeta::mutable_strings() {
  if (!has_strings()) {
    clear_Label();
    set_has_strings();
    Label_.strings_ = new ::TuriCreate::Annotation::Specification::MetaString;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.AudioClassificationMeta.strings)
  return Label_.strings_;
}
inline ::TuriCreate::Annotation::Specification::MetaString* AudioClassificationMeta::release_strings() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.AudioClassificationMeta.strings)
  if (has_strings()) {
    clear_has_Label();
    ::TuriCreate::Annotation::Specification::MetaString* temp = Label_.strings_;
    Label_.strings_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AudioClassificationMeta::set_allocated_strings(::TuriCreate::Annotation::Specification::MetaString* strings) {
  clear_Label();
  if (strings) {
    set_has_strings();
    Label_.strings_ = strings;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.AudioClassificationMeta.strings)
}

// .TuriCreate.Annotation.Specification.MetaInteger integers = 2;
inline bool AudioClassificationMeta::has_integers() const {
  return Label_case() == kIntegers;
}
inline void AudioClassificationMeta::set_has_integers() {
  _oneof_case_[0] = kIntegers;
}
inline void AudioClassificationMeta::clear_integers() {
  if (has_integers()) {
    delete Label_.integers_;
    clear_has_Label();
  }
}
inline  const ::TuriCreate::Annotation::Specification::MetaInteger& AudioClassificationMeta::integers() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.AudioClassificationMeta.integers)
  return has_integers()
      ? *Label_.integers_
      : ::TuriCreate::Annotation::Specification::MetaInteger::default_instance();
}
inline ::TuriCreate::Annotation::Specification::MetaInteger* AudioClassificationMeta::mutable_integers() {
  if (!has_integers()) {
    clear_Label();
    set_has_integers();
    Label_.integers_ = new ::TuriCreate::Annotation::Specification::MetaInteger;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.AudioClassificationMeta.integers)
  return Label_.integers_;
}
inline ::TuriCreate::Annotation::Specification::MetaInteger* AudioClassificationMeta::release_integers() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.AudioClassificationMeta.integers)
  if (has_integers()) {
    clear_has_Label();
    ::TuriCreate::Annotation::Specification::MetaInteger* temp = Label_.integers_;
    Label_.integers_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AudioClassificationMeta::set_allocated_integers(::TuriCreate::Annotation::Specification::MetaInteger* integers) {
  clear_Label();
  if (integers) {
    set_has_integers();
    Label_.integers_ = integers;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.AudioClassificationMeta.integers)
}

inline bool AudioClassificationMeta::has_Label() const {
  return Label_case() != LABEL_NOT_SET;
}
inline void AudioClassificationMeta::clear_has_Label() {
  _oneof_case_[0] = LABEL_NOT_SET;
}
inline AudioClassificationMeta::LabelCase AudioClassificationMeta::Label_case() const {
  return AudioClassificationMeta::LabelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DrawingClassificationMeta

// .TuriCreate.Annotation.Specification.MetaString strings = 1;
inline bool DrawingClassificationMeta::has_strings() const {
  return Label_case() == kStrings;
}
inline void DrawingClassificationMeta::set_has_strings() {
  _oneof_case_[0] = kStrings;
}
inline void DrawingClassificationMeta::clear_strings() {
  if (has_strings()) {
    delete Label_.strings_;
    clear_has_Label();
  }
}
inline  const ::TuriCreate::Annotation::Specification::MetaString& DrawingClassificationMeta::strings() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.DrawingClassificationMeta.strings)
  return has_strings()
      ? *Label_.strings_
      : ::TuriCreate::Annotation::Specification::MetaString::default_instance();
}
inline ::TuriCreate::Annotation::Specification::MetaString* DrawingClassificationMeta::mutable_strings() {
  if (!has_strings()) {
    clear_Label();
    set_has_strings();
    Label_.strings_ = new ::TuriCreate::Annotation::Specification::MetaString;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.DrawingClassificationMeta.strings)
  return Label_.strings_;
}
inline ::TuriCreate::Annotation::Specification::MetaString* DrawingClassificationMeta::release_strings() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.DrawingClassificationMeta.strings)
  if (has_strings()) {
    clear_has_Label();
    ::TuriCreate::Annotation::Specification::MetaString* temp = Label_.strings_;
    Label_.strings_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DrawingClassificationMeta::set_allocated_strings(::TuriCreate::Annotation::Specification::MetaString* strings) {
  clear_Label();
  if (strings) {
    set_has_strings();
    Label_.strings_ = strings;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.DrawingClassificationMeta.strings)
}

// .TuriCreate.Annotation.Specification.MetaInteger integers = 2;
inline bool DrawingClassificationMeta::has_integers() const {
  return Label_case() == kIntegers;
}
inline void DrawingClassificationMeta::set_has_integers() {
  _oneof_case_[0] = kIntegers;
}
inline void DrawingClassificationMeta::clear_integers() {
  if (has_integers()) {
    delete Label_.integers_;
    clear_has_Label();
  }
}
inline  const ::TuriCreate::Annotation::Specification::MetaInteger& DrawingClassificationMeta::integers() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.DrawingClassificationMeta.integers)
  return has_integers()
      ? *Label_.integers_
      : ::TuriCreate::Annotation::Specification::MetaInteger::default_instance();
}
inline ::TuriCreate::Annotation::Specification::MetaInteger* DrawingClassificationMeta::mutable_integers() {
  if (!has_integers()) {
    clear_Label();
    set_has_integers();
    Label_.integers_ = new ::TuriCreate::Annotation::Specification::MetaInteger;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.DrawingClassificationMeta.integers)
  return Label_.integers_;
}
inline ::TuriCreate::Annotation::Specification::MetaInteger* DrawingClassificationMeta::release_integers() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.DrawingClassificationMeta.integers)
  if (has_integers()) {
    clear_has_Label();
    ::TuriCreate::Annotation::Specification::MetaInteger* temp = Label_.integers_;
    Label_.integers_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void DrawingClassificationMeta::set_allocated_integers(::TuriCreate::Annotation::Specification::MetaInteger* integers) {
  clear_Label();
  if (integers) {
    set_has_integers();
    Label_.integers_ = integers;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.DrawingClassificationMeta.integers)
}

inline bool DrawingClassificationMeta::has_Label() const {
  return Label_case() != LABEL_NOT_SET;
}
inline void DrawingClassificationMeta::clear_has_Label() {
  _oneof_case_[0] = LABEL_NOT_SET;
}
inline DrawingClassificationMeta::LabelCase DrawingClassificationMeta::Label_case() const {
  return DrawingClassificationMeta::LabelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ImageClassificationMeta

// .TuriCreate.Annotation.Specification.MetaString strings = 1;
inline bool ImageClassificationMeta::has_strings() const {
  return Label_case() == kStrings;
}
inline void ImageClassificationMeta::set_has_strings() {
  _oneof_case_[0] = kStrings;
}
inline void ImageClassificationMeta::clear_strings() {
  if (has_strings()) {
    delete Label_.strings_;
    clear_has_Label();
  }
}
inline  const ::TuriCreate::Annotation::Specification::MetaString& ImageClassificationMeta::strings() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.ImageClassificationMeta.strings)
  return has_strings()
      ? *Label_.strings_
      : ::TuriCreate::Annotation::Specification::MetaString::default_instance();
}
inline ::TuriCreate::Annotation::Specification::MetaString* ImageClassificationMeta::mutable_strings() {
  if (!has_strings()) {
    clear_Label();
    set_has_strings();
    Label_.strings_ = new ::TuriCreate::Annotation::Specification::MetaString;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.ImageClassificationMeta.strings)
  return Label_.strings_;
}
inline ::TuriCreate::Annotation::Specification::MetaString* ImageClassificationMeta::release_strings() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.ImageClassificationMeta.strings)
  if (has_strings()) {
    clear_has_Label();
    ::TuriCreate::Annotation::Specification::MetaString* temp = Label_.strings_;
    Label_.strings_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ImageClassificationMeta::set_allocated_strings(::TuriCreate::Annotation::Specification::MetaString* strings) {
  clear_Label();
  if (strings) {
    set_has_strings();
    Label_.strings_ = strings;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.ImageClassificationMeta.strings)
}

// .TuriCreate.Annotation.Specification.MetaInteger integers = 2;
inline bool ImageClassificationMeta::has_integers() const {
  return Label_case() == kIntegers;
}
inline void ImageClassificationMeta::set_has_integers() {
  _oneof_case_[0] = kIntegers;
}
inline void ImageClassificationMeta::clear_integers() {
  if (has_integers()) {
    delete Label_.integers_;
    clear_has_Label();
  }
}
inline  const ::TuriCreate::Annotation::Specification::MetaInteger& ImageClassificationMeta::integers() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.ImageClassificationMeta.integers)
  return has_integers()
      ? *Label_.integers_
      : ::TuriCreate::Annotation::Specification::MetaInteger::default_instance();
}
inline ::TuriCreate::Annotation::Specification::MetaInteger* ImageClassificationMeta::mutable_integers() {
  if (!has_integers()) {
    clear_Label();
    set_has_integers();
    Label_.integers_ = new ::TuriCreate::Annotation::Specification::MetaInteger;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.ImageClassificationMeta.integers)
  return Label_.integers_;
}
inline ::TuriCreate::Annotation::Specification::MetaInteger* ImageClassificationMeta::release_integers() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.ImageClassificationMeta.integers)
  if (has_integers()) {
    clear_has_Label();
    ::TuriCreate::Annotation::Specification::MetaInteger* temp = Label_.integers_;
    Label_.integers_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ImageClassificationMeta::set_allocated_integers(::TuriCreate::Annotation::Specification::MetaInteger* integers) {
  clear_Label();
  if (integers) {
    set_has_integers();
    Label_.integers_ = integers;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.ImageClassificationMeta.integers)
}

inline bool ImageClassificationMeta::has_Label() const {
  return Label_case() != LABEL_NOT_SET;
}
inline void ImageClassificationMeta::clear_has_Label() {
  _oneof_case_[0] = LABEL_NOT_SET;
}
inline ImageClassificationMeta::LabelCase ImageClassificationMeta::Label_case() const {
  return ImageClassificationMeta::LabelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ObjectDetectionMeta

// .TuriCreate.Annotation.Specification.MetaString strings = 1;
inline bool ObjectDetectionMeta::has_strings() const {
  return Label_case() == kStrings;
}
inline void ObjectDetectionMeta::set_has_strings() {
  _oneof_case_[0] = kStrings;
}
inline void ObjectDetectionMeta::clear_strings() {
  if (has_strings()) {
    delete Label_.strings_;
    clear_has_Label();
  }
}
inline  const ::TuriCreate::Annotation::Specification::MetaString& ObjectDetectionMeta::strings() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.ObjectDetectionMeta.strings)
  return has_strings()
      ? *Label_.strings_
      : ::TuriCreate::Annotation::Specification::MetaString::default_instance();
}
inline ::TuriCreate::Annotation::Specification::MetaString* ObjectDetectionMeta::mutable_strings() {
  if (!has_strings()) {
    clear_Label();
    set_has_strings();
    Label_.strings_ = new ::TuriCreate::Annotation::Specification::MetaString;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.ObjectDetectionMeta.strings)
  return Label_.strings_;
}
inline ::TuriCreate::Annotation::Specification::MetaString* ObjectDetectionMeta::release_strings() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.ObjectDetectionMeta.strings)
  if (has_strings()) {
    clear_has_Label();
    ::TuriCreate::Annotation::Specification::MetaString* temp = Label_.strings_;
    Label_.strings_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectDetectionMeta::set_allocated_strings(::TuriCreate::Annotation::Specification::MetaString* strings) {
  clear_Label();
  if (strings) {
    set_has_strings();
    Label_.strings_ = strings;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.ObjectDetectionMeta.strings)
}

// .TuriCreate.Annotation.Specification.MetaInteger integers = 2;
inline bool ObjectDetectionMeta::has_integers() const {
  return Label_case() == kIntegers;
}
inline void ObjectDetectionMeta::set_has_integers() {
  _oneof_case_[0] = kIntegers;
}
inline void ObjectDetectionMeta::clear_integers() {
  if (has_integers()) {
    delete Label_.integers_;
    clear_has_Label();
  }
}
inline  const ::TuriCreate::Annotation::Specification::MetaInteger& ObjectDetectionMeta::integers() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.ObjectDetectionMeta.integers)
  return has_integers()
      ? *Label_.integers_
      : ::TuriCreate::Annotation::Specification::MetaInteger::default_instance();
}
inline ::TuriCreate::Annotation::Specification::MetaInteger* ObjectDetectionMeta::mutable_integers() {
  if (!has_integers()) {
    clear_Label();
    set_has_integers();
    Label_.integers_ = new ::TuriCreate::Annotation::Specification::MetaInteger;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.ObjectDetectionMeta.integers)
  return Label_.integers_;
}
inline ::TuriCreate::Annotation::Specification::MetaInteger* ObjectDetectionMeta::release_integers() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.ObjectDetectionMeta.integers)
  if (has_integers()) {
    clear_has_Label();
    ::TuriCreate::Annotation::Specification::MetaInteger* temp = Label_.integers_;
    Label_.integers_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectDetectionMeta::set_allocated_integers(::TuriCreate::Annotation::Specification::MetaInteger* integers) {
  clear_Label();
  if (integers) {
    set_has_integers();
    Label_.integers_ = integers;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.ObjectDetectionMeta.integers)
}

inline bool ObjectDetectionMeta::has_Label() const {
  return Label_case() != LABEL_NOT_SET;
}
inline void ObjectDetectionMeta::clear_has_Label() {
  _oneof_case_[0] = LABEL_NOT_SET;
}
inline ObjectDetectionMeta::LabelCase ObjectDetectionMeta::Label_case() const {
  return ObjectDetectionMeta::LabelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MetaData

// int64 num_examples = 1;
inline void MetaData::clear_num_examples() {
  num_examples_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MetaData::num_examples() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.num_examples)
  return num_examples_;
}
inline void MetaData::set_num_examples(::google::protobuf::int64 value) {
  
  num_examples_ = value;
  // @@protoc_insertion_point(field_set:TuriCreate.Annotation.Specification.MetaData.num_examples)
}

// .TuriCreate.Annotation.Specification.ActivityClassificationMeta activity_classification = 100;
inline bool MetaData::has_activity_classification() const {
  return Type_case() == kActivityClassification;
}
inline void MetaData::set_has_activity_classification() {
  _oneof_case_[0] = kActivityClassification;
}
inline void MetaData::clear_activity_classification() {
  if (has_activity_classification()) {
    delete Type_.activity_classification_;
    clear_has_Type();
  }
}
inline  const ::TuriCreate::Annotation::Specification::ActivityClassificationMeta& MetaData::activity_classification() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.activity_classification)
  return has_activity_classification()
      ? *Type_.activity_classification_
      : ::TuriCreate::Annotation::Specification::ActivityClassificationMeta::default_instance();
}
inline ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* MetaData::mutable_activity_classification() {
  if (!has_activity_classification()) {
    clear_Type();
    set_has_activity_classification();
    Type_.activity_classification_ = new ::TuriCreate::Annotation::Specification::ActivityClassificationMeta;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.MetaData.activity_classification)
  return Type_.activity_classification_;
}
inline ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* MetaData::release_activity_classification() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.MetaData.activity_classification)
  if (has_activity_classification()) {
    clear_has_Type();
    ::TuriCreate::Annotation::Specification::ActivityClassificationMeta* temp = Type_.activity_classification_;
    Type_.activity_classification_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MetaData::set_allocated_activity_classification(::TuriCreate::Annotation::Specification::ActivityClassificationMeta* activity_classification) {
  clear_Type();
  if (activity_classification) {
    set_has_activity_classification();
    Type_.activity_classification_ = activity_classification;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.MetaData.activity_classification)
}

// .TuriCreate.Annotation.Specification.AudioClassificationMeta audio_classification = 101;
inline bool MetaData::has_audio_classification() const {
  return Type_case() == kAudioClassification;
}
inline void MetaData::set_has_audio_classification() {
  _oneof_case_[0] = kAudioClassification;
}
inline void MetaData::clear_audio_classification() {
  if (has_audio_classification()) {
    delete Type_.audio_classification_;
    clear_has_Type();
  }
}
inline  const ::TuriCreate::Annotation::Specification::AudioClassificationMeta& MetaData::audio_classification() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.audio_classification)
  return has_audio_classification()
      ? *Type_.audio_classification_
      : ::TuriCreate::Annotation::Specification::AudioClassificationMeta::default_instance();
}
inline ::TuriCreate::Annotation::Specification::AudioClassificationMeta* MetaData::mutable_audio_classification() {
  if (!has_audio_classification()) {
    clear_Type();
    set_has_audio_classification();
    Type_.audio_classification_ = new ::TuriCreate::Annotation::Specification::AudioClassificationMeta;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.MetaData.audio_classification)
  return Type_.audio_classification_;
}
inline ::TuriCreate::Annotation::Specification::AudioClassificationMeta* MetaData::release_audio_classification() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.MetaData.audio_classification)
  if (has_audio_classification()) {
    clear_has_Type();
    ::TuriCreate::Annotation::Specification::AudioClassificationMeta* temp = Type_.audio_classification_;
    Type_.audio_classification_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MetaData::set_allocated_audio_classification(::TuriCreate::Annotation::Specification::AudioClassificationMeta* audio_classification) {
  clear_Type();
  if (audio_classification) {
    set_has_audio_classification();
    Type_.audio_classification_ = audio_classification;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.MetaData.audio_classification)
}

// .TuriCreate.Annotation.Specification.DrawingClassificationMeta drawing_classification = 102;
inline bool MetaData::has_drawing_classification() const {
  return Type_case() == kDrawingClassification;
}
inline void MetaData::set_has_drawing_classification() {
  _oneof_case_[0] = kDrawingClassification;
}
inline void MetaData::clear_drawing_classification() {
  if (has_drawing_classification()) {
    delete Type_.drawing_classification_;
    clear_has_Type();
  }
}
inline  const ::TuriCreate::Annotation::Specification::DrawingClassificationMeta& MetaData::drawing_classification() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.drawing_classification)
  return has_drawing_classification()
      ? *Type_.drawing_classification_
      : ::TuriCreate::Annotation::Specification::DrawingClassificationMeta::default_instance();
}
inline ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* MetaData::mutable_drawing_classification() {
  if (!has_drawing_classification()) {
    clear_Type();
    set_has_drawing_classification();
    Type_.drawing_classification_ = new ::TuriCreate::Annotation::Specification::DrawingClassificationMeta;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.MetaData.drawing_classification)
  return Type_.drawing_classification_;
}
inline ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* MetaData::release_drawing_classification() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.MetaData.drawing_classification)
  if (has_drawing_classification()) {
    clear_has_Type();
    ::TuriCreate::Annotation::Specification::DrawingClassificationMeta* temp = Type_.drawing_classification_;
    Type_.drawing_classification_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MetaData::set_allocated_drawing_classification(::TuriCreate::Annotation::Specification::DrawingClassificationMeta* drawing_classification) {
  clear_Type();
  if (drawing_classification) {
    set_has_drawing_classification();
    Type_.drawing_classification_ = drawing_classification;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.MetaData.drawing_classification)
}

// .TuriCreate.Annotation.Specification.ImageClassificationMeta image_classification = 103;
inline bool MetaData::has_image_classification() const {
  return Type_case() == kImageClassification;
}
inline void MetaData::set_has_image_classification() {
  _oneof_case_[0] = kImageClassification;
}
inline void MetaData::clear_image_classification() {
  if (has_image_classification()) {
    delete Type_.image_classification_;
    clear_has_Type();
  }
}
inline  const ::TuriCreate::Annotation::Specification::ImageClassificationMeta& MetaData::image_classification() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.image_classification)
  return has_image_classification()
      ? *Type_.image_classification_
      : ::TuriCreate::Annotation::Specification::ImageClassificationMeta::default_instance();
}
inline ::TuriCreate::Annotation::Specification::ImageClassificationMeta* MetaData::mutable_image_classification() {
  if (!has_image_classification()) {
    clear_Type();
    set_has_image_classification();
    Type_.image_classification_ = new ::TuriCreate::Annotation::Specification::ImageClassificationMeta;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.MetaData.image_classification)
  return Type_.image_classification_;
}
inline ::TuriCreate::Annotation::Specification::ImageClassificationMeta* MetaData::release_image_classification() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.MetaData.image_classification)
  if (has_image_classification()) {
    clear_has_Type();
    ::TuriCreate::Annotation::Specification::ImageClassificationMeta* temp = Type_.image_classification_;
    Type_.image_classification_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MetaData::set_allocated_image_classification(::TuriCreate::Annotation::Specification::ImageClassificationMeta* image_classification) {
  clear_Type();
  if (image_classification) {
    set_has_image_classification();
    Type_.image_classification_ = image_classification;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.MetaData.image_classification)
}

// .TuriCreate.Annotation.Specification.ObjectDetectionMeta object_detection = 104;
inline bool MetaData::has_object_detection() const {
  return Type_case() == kObjectDetection;
}
inline void MetaData::set_has_object_detection() {
  _oneof_case_[0] = kObjectDetection;
}
inline void MetaData::clear_object_detection() {
  if (has_object_detection()) {
    delete Type_.object_detection_;
    clear_has_Type();
  }
}
inline  const ::TuriCreate::Annotation::Specification::ObjectDetectionMeta& MetaData::object_detection() const {
  // @@protoc_insertion_point(field_get:TuriCreate.Annotation.Specification.MetaData.object_detection)
  return has_object_detection()
      ? *Type_.object_detection_
      : ::TuriCreate::Annotation::Specification::ObjectDetectionMeta::default_instance();
}
inline ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* MetaData::mutable_object_detection() {
  if (!has_object_detection()) {
    clear_Type();
    set_has_object_detection();
    Type_.object_detection_ = new ::TuriCreate::Annotation::Specification::ObjectDetectionMeta;
  }
  // @@protoc_insertion_point(field_mutable:TuriCreate.Annotation.Specification.MetaData.object_detection)
  return Type_.object_detection_;
}
inline ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* MetaData::release_object_detection() {
  // @@protoc_insertion_point(field_release:TuriCreate.Annotation.Specification.MetaData.object_detection)
  if (has_object_detection()) {
    clear_has_Type();
    ::TuriCreate::Annotation::Specification::ObjectDetectionMeta* temp = Type_.object_detection_;
    Type_.object_detection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MetaData::set_allocated_object_detection(::TuriCreate::Annotation::Specification::ObjectDetectionMeta* object_detection) {
  clear_Type();
  if (object_detection) {
    set_has_object_detection();
    Type_.object_detection_ = object_detection;
  }
  // @@protoc_insertion_point(field_set_allocated:TuriCreate.Annotation.Specification.MetaData.object_detection)
}

inline bool MetaData::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void MetaData::clear_has_Type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline MetaData::TypeCase MetaData::Type_case() const {
  return MetaData::TypeCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace Specification
}  // namespace Annotation
}  // namespace TuriCreate

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_meta_2eproto__INCLUDED
