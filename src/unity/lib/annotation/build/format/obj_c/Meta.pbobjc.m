// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meta.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Meta.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - MetaRoot

@implementation MetaRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - MetaRoot_FileDescriptor

static GPBFileDescriptor *MetaRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"TuriCreate.Annotation.Specification"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - MetaString

@implementation MetaString

@dynamic labelsArray, labelsArray_Count;

typedef struct MetaString__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *labelsArray;
} MetaString__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "labelsArray",
        .dataTypeSpecific.className = NULL,
        .number = MetaString_FieldNumber_LabelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MetaString__storage_, labelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MetaString class]
                                     rootClass:[MetaRoot class]
                                          file:MetaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetaString__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MetaInteger

@implementation MetaInteger

@dynamic labelsArray, labelsArray_Count;

typedef struct MetaInteger__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *labelsArray;
} MetaInteger__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "labelsArray",
        .dataTypeSpecific.className = NULL,
        .number = MetaInteger_FieldNumber_LabelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MetaInteger__storage_, labelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MetaInteger class]
                                     rootClass:[MetaRoot class]
                                          file:MetaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetaInteger__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ActivityClassificationMeta

@implementation ActivityClassificationMeta

@dynamic labelOneOfCase;
@dynamic strings;
@dynamic integers;

typedef struct ActivityClassificationMeta__storage_ {
  uint32_t _has_storage_[2];
  MetaString *strings;
  MetaInteger *integers;
} ActivityClassificationMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "strings",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaString),
        .number = ActivityClassificationMeta_FieldNumber_Strings,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ActivityClassificationMeta__storage_, strings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "integers",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaInteger),
        .number = ActivityClassificationMeta_FieldNumber_Integers,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ActivityClassificationMeta__storage_, integers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ActivityClassificationMeta class]
                                     rootClass:[MetaRoot class]
                                          file:MetaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ActivityClassificationMeta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "label",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ActivityClassificationMeta_ClearLabelOneOfCase(ActivityClassificationMeta *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - AudioClassificationMeta

@implementation AudioClassificationMeta

@dynamic labelOneOfCase;
@dynamic strings;
@dynamic integers;

typedef struct AudioClassificationMeta__storage_ {
  uint32_t _has_storage_[2];
  MetaString *strings;
  MetaInteger *integers;
} AudioClassificationMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "strings",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaString),
        .number = AudioClassificationMeta_FieldNumber_Strings,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(AudioClassificationMeta__storage_, strings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "integers",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaInteger),
        .number = AudioClassificationMeta_FieldNumber_Integers,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(AudioClassificationMeta__storage_, integers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AudioClassificationMeta class]
                                     rootClass:[MetaRoot class]
                                          file:MetaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AudioClassificationMeta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "label",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void AudioClassificationMeta_ClearLabelOneOfCase(AudioClassificationMeta *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - DrawingClassificationMeta

@implementation DrawingClassificationMeta

@dynamic labelOneOfCase;
@dynamic strings;
@dynamic integers;

typedef struct DrawingClassificationMeta__storage_ {
  uint32_t _has_storage_[2];
  MetaString *strings;
  MetaInteger *integers;
} DrawingClassificationMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "strings",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaString),
        .number = DrawingClassificationMeta_FieldNumber_Strings,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DrawingClassificationMeta__storage_, strings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "integers",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaInteger),
        .number = DrawingClassificationMeta_FieldNumber_Integers,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DrawingClassificationMeta__storage_, integers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DrawingClassificationMeta class]
                                     rootClass:[MetaRoot class]
                                          file:MetaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DrawingClassificationMeta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "label",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DrawingClassificationMeta_ClearLabelOneOfCase(DrawingClassificationMeta *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ImageClassificationMeta

@implementation ImageClassificationMeta

@dynamic labelOneOfCase;
@dynamic strings;
@dynamic integers;

typedef struct ImageClassificationMeta__storage_ {
  uint32_t _has_storage_[2];
  MetaString *strings;
  MetaInteger *integers;
} ImageClassificationMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "strings",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaString),
        .number = ImageClassificationMeta_FieldNumber_Strings,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ImageClassificationMeta__storage_, strings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "integers",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaInteger),
        .number = ImageClassificationMeta_FieldNumber_Integers,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ImageClassificationMeta__storage_, integers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ImageClassificationMeta class]
                                     rootClass:[MetaRoot class]
                                          file:MetaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ImageClassificationMeta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "label",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ImageClassificationMeta_ClearLabelOneOfCase(ImageClassificationMeta *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ObjectDetectionMeta

@implementation ObjectDetectionMeta

@dynamic labelOneOfCase;
@dynamic strings;
@dynamic integers;

typedef struct ObjectDetectionMeta__storage_ {
  uint32_t _has_storage_[2];
  MetaString *strings;
  MetaInteger *integers;
} ObjectDetectionMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "strings",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaString),
        .number = ObjectDetectionMeta_FieldNumber_Strings,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ObjectDetectionMeta__storage_, strings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "integers",
        .dataTypeSpecific.className = GPBStringifySymbol(MetaInteger),
        .number = ObjectDetectionMeta_FieldNumber_Integers,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ObjectDetectionMeta__storage_, integers),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ObjectDetectionMeta class]
                                     rootClass:[MetaRoot class]
                                          file:MetaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ObjectDetectionMeta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "label",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ObjectDetectionMeta_ClearLabelOneOfCase(ObjectDetectionMeta *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - MetaData

@implementation MetaData

@dynamic typeOneOfCase;
@dynamic numExamples;
@dynamic activityClassification;
@dynamic audioClassification;
@dynamic drawingClassification;
@dynamic imageClassification;
@dynamic objectDetection;

typedef struct MetaData__storage_ {
  uint32_t _has_storage_[2];
  ActivityClassificationMeta *activityClassification;
  AudioClassificationMeta *audioClassification;
  DrawingClassificationMeta *drawingClassification;
  ImageClassificationMeta *imageClassification;
  ObjectDetectionMeta *objectDetection;
  int64_t numExamples;
} MetaData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "numExamples",
        .dataTypeSpecific.className = NULL,
        .number = MetaData_FieldNumber_NumExamples,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MetaData__storage_, numExamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "activityClassification",
        .dataTypeSpecific.className = GPBStringifySymbol(ActivityClassificationMeta),
        .number = MetaData_FieldNumber_ActivityClassification,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MetaData__storage_, activityClassification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audioClassification",
        .dataTypeSpecific.className = GPBStringifySymbol(AudioClassificationMeta),
        .number = MetaData_FieldNumber_AudioClassification,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MetaData__storage_, audioClassification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "drawingClassification",
        .dataTypeSpecific.className = GPBStringifySymbol(DrawingClassificationMeta),
        .number = MetaData_FieldNumber_DrawingClassification,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MetaData__storage_, drawingClassification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imageClassification",
        .dataTypeSpecific.className = GPBStringifySymbol(ImageClassificationMeta),
        .number = MetaData_FieldNumber_ImageClassification,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MetaData__storage_, imageClassification),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "objectDetection",
        .dataTypeSpecific.className = GPBStringifySymbol(ObjectDetectionMeta),
        .number = MetaData_FieldNumber_ObjectDetection,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(MetaData__storage_, objectDetection),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MetaData class]
                                     rootClass:[MetaRoot class]
                                          file:MetaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MetaData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "type",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void MetaData_ClearTypeOneOfCase(MetaData *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
